(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var readout, Game;
readout = require('./readout');
Game = require('./game');
readout.install();
Game.start();
},{"./game":16,"./readout":29}],2:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var apply, curry, flip, fix, over;
apply = curry$(function(f, list){
  return f.apply(null, list);
});
curry = function(f){
  return curry$(f);
};
flip = curry$(function(f, x, y){
  return f(y, x);
});
fix = function(f){
  return function(g){
    return function(){
      return f(g(g)).apply(null, arguments);
    };
  }(function(g){
    return function(){
      return f(g(g)).apply(null, arguments);
    };
  });
};
over = curry$(function(f, g, x, y){
  return f(g(x), g(y));
});
module.exports = {
  curry: curry,
  flip: flip,
  fix: fix,
  apply: apply,
  over: over
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{}],3:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var each, map, compact, filter, reject, partition, find, head, first, tail, last, initial, empty, reverse, unique, uniqueBy, fold, foldl, fold1, foldl1, foldr, foldr1, unfoldr, concat, concatMap, flatten, difference, intersection, union, countBy, groupBy, andList, orList, any, all, sort, sortWith, sortBy, sum, product, mean, average, maximum, minimum, maximumBy, minimumBy, scan, scanl, scan1, scanl1, scanr, scanr1, slice, take, drop, splitAt, takeWhile, dropWhile, span, breakList, zip, zipWith, zipAll, zipAllWith, at, elemIndex, elemIndices, findIndex, findIndices, toString$ = {}.toString, slice$ = [].slice;
each = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    f(x);
  }
  return xs;
});
map = curry$(function(f, xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    results$.push(f(x));
  }
  return results$;
});
compact = function(xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (x) {
      results$.push(x);
    }
  }
  return results$;
};
filter = curry$(function(f, xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      results$.push(x);
    }
  }
  return results$;
});
reject = curry$(function(f, xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!f(x)) {
      results$.push(x);
    }
  }
  return results$;
});
partition = curry$(function(f, xs){
  var passed, failed, i$, len$, x;
  passed = [];
  failed = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    (f(x) ? passed : failed).push(x);
  }
  return [passed, failed];
});
find = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      return x;
    }
  }
});
head = first = function(xs){
  return xs[0];
};
tail = function(xs){
  if (!xs.length) {
    return;
  }
  return xs.slice(1);
};
last = function(xs){
  return xs[xs.length - 1];
};
initial = function(xs){
  if (!xs.length) {
    return;
  }
  return xs.slice(0, -1);
};
empty = function(xs){
  return !xs.length;
};
reverse = function(xs){
  return xs.concat().reverse();
};
unique = function(xs){
  var result, i$, len$, x;
  result = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!in$(x, result)) {
      result.push(x);
    }
  }
  return result;
};
uniqueBy = curry$(function(f, xs){
  var seen, i$, len$, x, val, results$ = [];
  seen = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    val = f(x);
    if (in$(val, seen)) {
      continue;
    }
    seen.push(val);
    results$.push(x);
  }
  return results$;
});
fold = foldl = curry$(function(f, memo, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    memo = f(memo, x);
  }
  return memo;
});
fold1 = foldl1 = curry$(function(f, xs){
  return fold(f, xs[0], xs.slice(1));
});
foldr = curry$(function(f, memo, xs){
  var i$, x;
  for (i$ = xs.length - 1; i$ >= 0; --i$) {
    x = xs[i$];
    memo = f(x, memo);
  }
  return memo;
});
foldr1 = curry$(function(f, xs){
  return foldr(f, xs[xs.length - 1], xs.slice(0, -1));
});
unfoldr = curry$(function(f, b){
  var result, x, that;
  result = [];
  x = b;
  while ((that = f(x)) != null) {
    result.push(that[0]);
    x = that[1];
  }
  return result;
});
concat = function(xss){
  return [].concat.apply([], xss);
};
concatMap = curry$(function(f, xs){
  var x;
  return [].concat.apply([], (function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      results$.push(f(x));
    }
    return results$;
  }()));
});
flatten = function(xs){
  var x;
  return [].concat.apply([], (function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      if (toString$.call(x).slice(8, -1) === 'Array') {
        results$.push(flatten(x));
      } else {
        results$.push(x);
      }
    }
    return results$;
  }()));
};
difference = function(xs){
  var yss, results, i$, len$, x, j$, len1$, ys;
  yss = slice$.call(arguments, 1);
  results = [];
  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
      ys = yss[j$];
      if (in$(x, ys)) {
        continue outer;
      }
    }
    results.push(x);
  }
  return results;
};
intersection = function(xs){
  var yss, results, i$, len$, x, j$, len1$, ys;
  yss = slice$.call(arguments, 1);
  results = [];
  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
      ys = yss[j$];
      if (!in$(x, ys)) {
        continue outer;
      }
    }
    results.push(x);
  }
  return results;
};
union = function(){
  var xss, results, i$, len$, xs, j$, len1$, x;
  xss = slice$.call(arguments);
  results = [];
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    for (j$ = 0, len1$ = xs.length; j$ < len1$; ++j$) {
      x = xs[j$];
      if (!in$(x, results)) {
        results.push(x);
      }
    }
  }
  return results;
};
countBy = curry$(function(f, xs){
  var results, i$, len$, x, key;
  results = {};
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    key = f(x);
    if (key in results) {
      results[key] += 1;
    } else {
      results[key] = 1;
    }
  }
  return results;
});
groupBy = curry$(function(f, xs){
  var results, i$, len$, x, key;
  results = {};
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    key = f(x);
    if (key in results) {
      results[key].push(x);
    } else {
      results[key] = [x];
    }
  }
  return results;
});
andList = function(xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!x) {
      return false;
    }
  }
  return true;
};
orList = function(xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (x) {
      return true;
    }
  }
  return false;
};
any = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      return true;
    }
  }
  return false;
});
all = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!f(x)) {
      return false;
    }
  }
  return true;
});
sort = function(xs){
  return xs.concat().sort(function(x, y){
    if (x > y) {
      return 1;
    } else if (x < y) {
      return -1;
    } else {
      return 0;
    }
  });
};
sortWith = curry$(function(f, xs){
  return xs.concat().sort(f);
});
sortBy = curry$(function(f, xs){
  return xs.concat().sort(function(x, y){
    if (f(x) > f(y)) {
      return 1;
    } else if (f(x) < f(y)) {
      return -1;
    } else {
      return 0;
    }
  });
});
sum = function(xs){
  var result, i$, len$, x;
  result = 0;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    result += x;
  }
  return result;
};
product = function(xs){
  var result, i$, len$, x;
  result = 1;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    result *= x;
  }
  return result;
};
mean = average = function(xs){
  var sum, i$, len$, x;
  sum = 0;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    sum += x;
  }
  return sum / xs.length;
};
maximum = function(xs){
  var max, i$, ref$, len$, x;
  max = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (x > max) {
      max = x;
    }
  }
  return max;
};
minimum = function(xs){
  var min, i$, ref$, len$, x;
  min = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (x < min) {
      min = x;
    }
  }
  return min;
};
maximumBy = curry$(function(f, xs){
  var max, i$, ref$, len$, x;
  max = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (f(x) > f(max)) {
      max = x;
    }
  }
  return max;
});
minimumBy = curry$(function(f, xs){
  var min, i$, ref$, len$, x;
  min = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (f(x) < f(min)) {
      min = x;
    }
  }
  return min;
});
scan = scanl = curry$(function(f, memo, xs){
  var last, x;
  last = memo;
  return [memo].concat((function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      results$.push(last = f(last, x));
    }
    return results$;
  }()));
});
scan1 = scanl1 = curry$(function(f, xs){
  if (!xs.length) {
    return;
  }
  return scan(f, xs[0], xs.slice(1));
});
scanr = curry$(function(f, memo, xs){
  xs = xs.concat().reverse();
  return scan(f, memo, xs).reverse();
});
scanr1 = curry$(function(f, xs){
  if (!xs.length) {
    return;
  }
  xs = xs.concat().reverse();
  return scan(f, xs[0], xs.slice(1)).reverse();
});
slice = curry$(function(x, y, xs){
  return xs.slice(x, y);
});
take = curry$(function(n, xs){
  if (n <= 0) {
    return xs.slice(0, 0);
  } else {
    return xs.slice(0, n);
  }
});
drop = curry$(function(n, xs){
  if (n <= 0) {
    return xs;
  } else {
    return xs.slice(n);
  }
});
splitAt = curry$(function(n, xs){
  return [take(n, xs), drop(n, xs)];
});
takeWhile = curry$(function(p, xs){
  var len, i;
  len = xs.length;
  if (!len) {
    return xs;
  }
  i = 0;
  while (i < len && p(xs[i])) {
    i += 1;
  }
  return xs.slice(0, i);
});
dropWhile = curry$(function(p, xs){
  var len, i;
  len = xs.length;
  if (!len) {
    return xs;
  }
  i = 0;
  while (i < len && p(xs[i])) {
    i += 1;
  }
  return xs.slice(i);
});
span = curry$(function(p, xs){
  return [takeWhile(p, xs), dropWhile(p, xs)];
});
breakList = curry$(function(p, xs){
  return span(function(){
    return not$(p.apply(this, arguments));
  }, xs);
});
zip = curry$(function(xs, ys){
  var result, len, i$, len$, i, x;
  result = [];
  len = ys.length;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (i === len) {
      break;
    }
    result.push([x, ys[i]]);
  }
  return result;
});
zipWith = curry$(function(f, xs, ys){
  var result, len, i$, len$, i, x;
  result = [];
  len = ys.length;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (i === len) {
      break;
    }
    result.push(f(x, ys[i]));
  }
  return result;
});
zipAll = function(){
  var xss, minLength, i$, len$, xs, ref$, i, lresult$, j$, results$ = [];
  xss = slice$.call(arguments);
  minLength = 9e9;
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    minLength <= (ref$ = xs.length) || (minLength = ref$);
  }
  for (i$ = 0; i$ < minLength; ++i$) {
    i = i$;
    lresult$ = [];
    for (j$ = 0, len$ = xss.length; j$ < len$; ++j$) {
      xs = xss[j$];
      lresult$.push(xs[i]);
    }
    results$.push(lresult$);
  }
  return results$;
};
zipAllWith = function(f){
  var xss, minLength, i$, len$, xs, ref$, i, results$ = [];
  xss = slice$.call(arguments, 1);
  minLength = 9e9;
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    minLength <= (ref$ = xs.length) || (minLength = ref$);
  }
  for (i$ = 0; i$ < minLength; ++i$) {
    i = i$;
    results$.push(f.apply(null, (fn$())));
  }
  return results$;
  function fn$(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xss).length; i$ < len$; ++i$) {
      xs = ref$[i$];
      results$.push(xs[i]);
    }
    return results$;
  }
};
at = curry$(function(n, xs){
  if (n < 0) {
    return xs[xs.length + n];
  } else {
    return xs[n];
  }
});
elemIndex = curry$(function(el, xs){
  var i$, len$, i, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (x === el) {
      return i;
    }
  }
});
elemIndices = curry$(function(el, xs){
  var i$, len$, i, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (x === el) {
      results$.push(i);
    }
  }
  return results$;
});
findIndex = curry$(function(f, xs){
  var i$, len$, i, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (f(x)) {
      return i;
    }
  }
});
findIndices = curry$(function(f, xs){
  var i$, len$, i, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (f(x)) {
      results$.push(i);
    }
  }
  return results$;
});
module.exports = {
  each: each,
  map: map,
  filter: filter,
  compact: compact,
  reject: reject,
  partition: partition,
  find: find,
  head: head,
  first: first,
  tail: tail,
  last: last,
  initial: initial,
  empty: empty,
  reverse: reverse,
  difference: difference,
  intersection: intersection,
  union: union,
  countBy: countBy,
  groupBy: groupBy,
  fold: fold,
  fold1: fold1,
  foldl: foldl,
  foldl1: foldl1,
  foldr: foldr,
  foldr1: foldr1,
  unfoldr: unfoldr,
  andList: andList,
  orList: orList,
  any: any,
  all: all,
  unique: unique,
  uniqueBy: uniqueBy,
  sort: sort,
  sortWith: sortWith,
  sortBy: sortBy,
  sum: sum,
  product: product,
  mean: mean,
  average: average,
  concat: concat,
  concatMap: concatMap,
  flatten: flatten,
  maximum: maximum,
  minimum: minimum,
  maximumBy: maximumBy,
  minimumBy: minimumBy,
  scan: scan,
  scan1: scan1,
  scanl: scanl,
  scanl1: scanl1,
  scanr: scanr,
  scanr1: scanr1,
  slice: slice,
  take: take,
  drop: drop,
  splitAt: splitAt,
  takeWhile: takeWhile,
  dropWhile: dropWhile,
  span: span,
  breakList: breakList,
  zip: zip,
  zipWith: zipWith,
  zipAll: zipAll,
  zipAllWith: zipAllWith,
  at: at,
  elemIndex: elemIndex,
  elemIndices: elemIndices,
  findIndex: findIndex,
  findIndices: findIndices
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
function in$(x, xs){
  var i = -1, l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}
function not$(x){ return !x; }
},{}],4:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var max, min, negate, abs, signum, quot, rem, div, mod, recip, pi, tau, exp, sqrt, ln, pow, sin, tan, cos, asin, acos, atan, atan2, truncate, round, ceiling, floor, isItNaN, even, odd, gcd, lcm;
max = curry$(function(x$, y$){
  return x$ > y$ ? x$ : y$;
});
min = curry$(function(x$, y$){
  return x$ < y$ ? x$ : y$;
});
negate = function(x){
  return -x;
};
abs = Math.abs;
signum = function(x){
  if (x < 0) {
    return -1;
  } else if (x > 0) {
    return 1;
  } else {
    return 0;
  }
};
quot = curry$(function(x, y){
  return ~~(x / y);
});
rem = curry$(function(x$, y$){
  return x$ % y$;
});
div = curry$(function(x, y){
  return Math.floor(x / y);
});
mod = curry$(function(x$, y$){
  var ref$;
  return ((x$) % (ref$ = y$) + ref$) % ref$;
});
recip = (function(it){
  return 1 / it;
});
pi = Math.PI;
tau = pi * 2;
exp = Math.exp;
sqrt = Math.sqrt;
ln = Math.log;
pow = curry$(function(x$, y$){
  return Math.pow(x$, y$);
});
sin = Math.sin;
tan = Math.tan;
cos = Math.cos;
asin = Math.asin;
acos = Math.acos;
atan = Math.atan;
atan2 = curry$(function(x, y){
  return Math.atan2(x, y);
});
truncate = function(x){
  return ~~x;
};
round = Math.round;
ceiling = Math.ceil;
floor = Math.floor;
isItNaN = function(x){
  return x !== x;
};
even = function(x){
  return x % 2 === 0;
};
odd = function(x){
  return x % 2 !== 0;
};
gcd = curry$(function(x, y){
  var z;
  x = Math.abs(x);
  y = Math.abs(y);
  while (y !== 0) {
    z = x % y;
    x = y;
    y = z;
  }
  return x;
});
lcm = curry$(function(x, y){
  return Math.abs(Math.floor(x / gcd(x, y) * y));
});
module.exports = {
  max: max,
  min: min,
  negate: negate,
  abs: abs,
  signum: signum,
  quot: quot,
  rem: rem,
  div: div,
  mod: mod,
  recip: recip,
  pi: pi,
  tau: tau,
  exp: exp,
  sqrt: sqrt,
  ln: ln,
  pow: pow,
  sin: sin,
  tan: tan,
  cos: cos,
  acos: acos,
  asin: asin,
  atan: atan,
  atan2: atan2,
  truncate: truncate,
  round: round,
  ceiling: ceiling,
  floor: floor,
  isItNaN: isItNaN,
  even: even,
  odd: odd,
  gcd: gcd,
  lcm: lcm
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{}],5:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var values, keys, pairsToObj, objToPairs, listsToObj, objToLists, empty, each, map, compact, filter, reject, partition, find;
values = function(object){
  var i$, x, results$ = [];
  for (i$ in object) {
    x = object[i$];
    results$.push(x);
  }
  return results$;
};
keys = function(object){
  var x, results$ = [];
  for (x in object) {
    results$.push(x);
  }
  return results$;
};
pairsToObj = function(object){
  var i$, len$, x, results$ = {};
  for (i$ = 0, len$ = object.length; i$ < len$; ++i$) {
    x = object[i$];
    results$[x[0]] = x[1];
  }
  return results$;
};
objToPairs = function(object){
  var key, value, results$ = [];
  for (key in object) {
    value = object[key];
    results$.push([key, value]);
  }
  return results$;
};
listsToObj = curry$(function(keys, values){
  var i$, len$, i, key, results$ = {};
  for (i$ = 0, len$ = keys.length; i$ < len$; ++i$) {
    i = i$;
    key = keys[i$];
    results$[key] = values[i];
  }
  return results$;
});
objToLists = function(object){
  var keys, values, key, value;
  keys = [];
  values = [];
  for (key in object) {
    value = object[key];
    keys.push(key);
    values.push(value);
  }
  return [keys, values];
};
empty = function(object){
  var x;
  for (x in object) {
    return false;
  }
  return true;
};
each = curry$(function(f, object){
  var i$, x;
  for (i$ in object) {
    x = object[i$];
    f(x);
  }
  return object;
});
map = curry$(function(f, object){
  var k, x, results$ = {};
  for (k in object) {
    x = object[k];
    results$[k] = f(x);
  }
  return results$;
});
compact = function(object){
  var k, x, results$ = {};
  for (k in object) {
    x = object[k];
if (x) {
      results$[k] = x;
    }
  }
  return results$;
};
filter = curry$(function(f, object){
  var k, x, results$ = {};
  for (k in object) {
    x = object[k];
if (f(x)) {
      results$[k] = x;
    }
  }
  return results$;
});
reject = curry$(function(f, object){
  var k, x, results$ = {};
  for (k in object) {
    x = object[k];
if (!f(x)) {
      results$[k] = x;
    }
  }
  return results$;
});
partition = curry$(function(f, object){
  var passed, failed, k, x;
  passed = {};
  failed = {};
  for (k in object) {
    x = object[k];
    (f(x) ? passed : failed)[k] = x;
  }
  return [passed, failed];
});
find = curry$(function(f, object){
  var i$, x;
  for (i$ in object) {
    x = object[i$];
    if (f(x)) {
      return x;
    }
  }
});
module.exports = {
  values: values,
  keys: keys,
  pairsToObj: pairsToObj,
  objToPairs: objToPairs,
  listsToObj: listsToObj,
  objToLists: objToLists,
  empty: empty,
  each: each,
  map: map,
  filter: filter,
  compact: compact,
  reject: reject,
  partition: partition,
  find: find
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{}],6:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var split, join, lines, unlines, words, unwords, chars, unchars, reverse, repeat, capitalize, camelize, dasherize;
split = curry$(function(sep, str){
  return str.split(sep);
});
join = curry$(function(sep, xs){
  return xs.join(sep);
});
lines = function(str){
  if (!str.length) {
    return [];
  }
  return str.split('\n');
};
unlines = function(it){
  return it.join('\n');
};
words = function(str){
  if (!str.length) {
    return [];
  }
  return str.split(/[ ]+/);
};
unwords = function(it){
  return it.join(' ');
};
chars = function(it){
  return it.split('');
};
unchars = function(it){
  return it.join('');
};
reverse = function(str){
  return str.split('').reverse().join('');
};
repeat = curry$(function(n, str){
  var result, i$;
  result = '';
  for (i$ = 0; i$ < n; ++i$) {
    result += str;
  }
  return result;
});
capitalize = function(str){
  return str.charAt(0).toUpperCase() + str.slice(1);
};
camelize = function(it){
  return it.replace(/[-_]+(.)?/g, function(arg$, c){
    return (c != null ? c : '').toUpperCase();
  });
};
dasherize = function(str){
  return str.replace(/([^-A-Z])([A-Z]+)/g, function(arg$, lower, upper){
    return lower + "-" + (upper.length > 1
      ? upper
      : upper.toLowerCase());
  }).replace(/^([A-Z]+)/, function(arg$, upper){
    if (upper.length > 1) {
      return upper + "-";
    } else {
      return upper.toLowerCase();
    }
  });
};
module.exports = {
  split: split,
  join: join,
  lines: lines,
  unlines: unlines,
  words: words,
  unwords: unwords,
  chars: chars,
  unchars: unchars,
  reverse: reverse,
  repeat: repeat,
  capitalize: capitalize,
  camelize: camelize,
  dasherize: dasherize
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{}],7:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var Func, List, Obj, Str, Num, id, isType, replicate, prelude, toString$ = {}.toString;
Func = require('./Func.js');
List = require('./List.js');
Obj = require('./Obj.js');
Str = require('./Str.js');
Num = require('./Num.js');
id = function(x){
  return x;
};
isType = curry$(function(type, x){
  return toString$.call(x).slice(8, -1) === type;
});
replicate = curry$(function(n, x){
  var i$, results$ = [];
  for (i$ = 0; i$ < n; ++i$) {
    results$.push(x);
  }
  return results$;
});
Str.empty = List.empty;
Str.slice = List.slice;
Str.take = List.take;
Str.drop = List.drop;
Str.splitAt = List.splitAt;
Str.takeWhile = List.takeWhile;
Str.dropWhile = List.dropWhile;
Str.span = List.span;
Str.breakStr = List.breakList;
prelude = {
  Func: Func,
  List: List,
  Obj: Obj,
  Str: Str,
  Num: Num,
  id: id,
  isType: isType,
  replicate: replicate
};
prelude.each = List.each;
prelude.map = List.map;
prelude.filter = List.filter;
prelude.compact = List.compact;
prelude.reject = List.reject;
prelude.partition = List.partition;
prelude.find = List.find;
prelude.head = List.head;
prelude.first = List.first;
prelude.tail = List.tail;
prelude.last = List.last;
prelude.initial = List.initial;
prelude.empty = List.empty;
prelude.reverse = List.reverse;
prelude.difference = List.difference;
prelude.intersection = List.intersection;
prelude.union = List.union;
prelude.countBy = List.countBy;
prelude.groupBy = List.groupBy;
prelude.fold = List.fold;
prelude.foldl = List.foldl;
prelude.fold1 = List.fold1;
prelude.foldl1 = List.foldl1;
prelude.foldr = List.foldr;
prelude.foldr1 = List.foldr1;
prelude.unfoldr = List.unfoldr;
prelude.andList = List.andList;
prelude.orList = List.orList;
prelude.any = List.any;
prelude.all = List.all;
prelude.unique = List.unique;
prelude.uniqueBy = List.uniqueBy;
prelude.sort = List.sort;
prelude.sortWith = List.sortWith;
prelude.sortBy = List.sortBy;
prelude.sum = List.sum;
prelude.product = List.product;
prelude.mean = List.mean;
prelude.average = List.average;
prelude.concat = List.concat;
prelude.concatMap = List.concatMap;
prelude.flatten = List.flatten;
prelude.maximum = List.maximum;
prelude.minimum = List.minimum;
prelude.maximumBy = List.maximumBy;
prelude.minimumBy = List.minimumBy;
prelude.scan = List.scan;
prelude.scanl = List.scanl;
prelude.scan1 = List.scan1;
prelude.scanl1 = List.scanl1;
prelude.scanr = List.scanr;
prelude.scanr1 = List.scanr1;
prelude.slice = List.slice;
prelude.take = List.take;
prelude.drop = List.drop;
prelude.splitAt = List.splitAt;
prelude.takeWhile = List.takeWhile;
prelude.dropWhile = List.dropWhile;
prelude.span = List.span;
prelude.breakList = List.breakList;
prelude.zip = List.zip;
prelude.zipWith = List.zipWith;
prelude.zipAll = List.zipAll;
prelude.zipAllWith = List.zipAllWith;
prelude.at = List.at;
prelude.elemIndex = List.elemIndex;
prelude.elemIndices = List.elemIndices;
prelude.findIndex = List.findIndex;
prelude.findIndices = List.findIndices;
prelude.apply = Func.apply;
prelude.curry = Func.curry;
prelude.flip = Func.flip;
prelude.fix = Func.fix;
prelude.over = Func.over;
prelude.split = Str.split;
prelude.join = Str.join;
prelude.lines = Str.lines;
prelude.unlines = Str.unlines;
prelude.words = Str.words;
prelude.unwords = Str.unwords;
prelude.chars = Str.chars;
prelude.unchars = Str.unchars;
prelude.repeat = Str.repeat;
prelude.capitalize = Str.capitalize;
prelude.camelize = Str.camelize;
prelude.dasherize = Str.dasherize;
prelude.values = Obj.values;
prelude.keys = Obj.keys;
prelude.pairsToObj = Obj.pairsToObj;
prelude.objToPairs = Obj.objToPairs;
prelude.listsToObj = Obj.listsToObj;
prelude.objToLists = Obj.objToLists;
prelude.max = Num.max;
prelude.min = Num.min;
prelude.negate = Num.negate;
prelude.abs = Num.abs;
prelude.signum = Num.signum;
prelude.quot = Num.quot;
prelude.rem = Num.rem;
prelude.div = Num.div;
prelude.mod = Num.mod;
prelude.recip = Num.recip;
prelude.pi = Num.pi;
prelude.tau = Num.tau;
prelude.exp = Num.exp;
prelude.sqrt = Num.sqrt;
prelude.ln = Num.ln;
prelude.pow = Num.pow;
prelude.sin = Num.sin;
prelude.tan = Num.tan;
prelude.cos = Num.cos;
prelude.acos = Num.acos;
prelude.asin = Num.asin;
prelude.atan = Num.atan;
prelude.atan2 = Num.atan2;
prelude.truncate = Num.truncate;
prelude.round = Num.round;
prelude.ceiling = Num.ceiling;
prelude.floor = Num.floor;
prelude.isItNaN = Num.isItNaN;
prelude.even = Num.even;
prelude.odd = Num.odd;
prelude.gcd = Num.gcd;
prelude.lcm = Num.lcm;
prelude.VERSION = '1.1.1';
module.exports = prelude;
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{"./Func.js":2,"./List.js":3,"./Num.js":4,"./Obj.js":5,"./Str.js":6}],8:[function(require,module,exports){
var std, units, kHalfTile, tileToPx, tileToGame, gameToPx, WALL_TILE, Sprite, ref$, SpriteState, State, Projectile, StarParticle, WallParticle, Rect, SpriteSource, kArmsSpritePath, kSpriteWidth, kSpriteHeight, kUpOffset, kDownOffset, kHorizontalOffset, kRightOffset, kLeftOffset, kPolarStarIndex, kProjectileSrcHorizontal, kProjectileSrcVertical, kNozzleHorizY, kNozzleHorizLeftX, kNozzleHorizRightX, kNozzleUpY, kNozzleUpLeftX, kNozzleUpRightX, kNozzleDownY, kNozzleDownLeftX, kNozzleDownRightX, kL1Lifespan, kL1Speed, kL1CollisionWidth, kL1CollisionHeight, UP, DOWN, LEFT, RIGHT, PolarStarProjectile, PolarStar, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
kHalfTile = units.kHalfTile, tileToPx = units.tileToPx, tileToGame = units.tileToGame, gameToPx = units.gameToPx;
WALL_TILE = require('./map').WALL_TILE;
Sprite = require('./sprite').Sprite;
ref$ = require('./spritestate'), SpriteState = ref$.SpriteState, State = ref$.State;
Projectile = require('./projectile').Projectile;
StarParticle = require('./star-particle').StarParticle;
WallParticle = require('./wall-particle').WallParticle;
ref$ = require('./rectangle'), Rect = ref$.Rectangle, SpriteSource = ref$.SpriteSource;
kArmsSpritePath = 'Arms';
kSpriteWidth = 1.5;
kSpriteHeight = 1.0;
kUpOffset = 2;
kDownOffset = 4;
kHorizontalOffset = 0;
kRightOffset = 1;
kLeftOffset = 0;
kPolarStarIndex = 2;
kProjectileSrcHorizontal = new SpriteSource(8, 2, 1, 1);
kProjectileSrcVertical = new SpriteSource(9, 2, 1, 1);
kNozzleHorizY = 23;
kNozzleHorizLeftX = 10;
kNozzleHorizRightX = 38;
kNozzleUpY = 4;
kNozzleUpLeftX = 27;
kNozzleUpRightX = 21;
kNozzleDownY = 28;
kNozzleDownLeftX = 29;
kNozzleDownRightX = 19;
kL1Lifespan = 7 * kHalfTile;
kL1Speed = 0.6;
kL1CollisionWidth = 32;
kL1CollisionHeight = 4;
ref$ = std['enum'], UP = ref$[0], DOWN = ref$[1], LEFT = ref$[2], RIGHT = ref$[3];
PolarStarProjectile = (function(superclass){
  var prototype = extend$((import$(PolarStarProjectile, superclass).displayName = 'PolarStarProjectile', PolarStarProjectile), superclass).prototype, constructor = PolarStarProjectile;
  function PolarStarProjectile(sprite, state, x, y){
    this.sprite = sprite;
    PolarStarProjectile.superclass.call(this, 1);
    this.offset = 0;
    this.lifespan = kL1Lifespan;
    this.alive = true;
    std.log('SFX: Pew!');
    if (state.HORIZONTAL) {
      this.width = kL1CollisionWidth;
      this.height = kL1CollisionHeight;
      this.vertical = false;
    } else {
      this.width = kL1CollisionHeight;
      this.height = kL1CollisionWidth;
      this.vertical = true;
    }
    this.mode = (function(){
      switch (true) {
      case state.UP:
        return UP;
      case state.DOWN:
        return DOWN;
      case state.LEFT:
        return LEFT;
      case state.RIGHT:
        return RIGHT;
      }
    }());
    Object.defineProperties(this, {
      x: {
        get: !state.HORIZONTAL
          ? function(){
            return x;
          }
          : state.LEFT
            ? function(){
              return x - this.offset;
            }
            : state.RIGHT ? function(){
              return x + this.offset;
            } : void 8
      },
      y: {
        get: state.HORIZONTAL
          ? function(){
            return y;
          }
          : state.UP
            ? function(){
              return y - this.offset;
            }
            : state.DOWN ? function(){
              return y + this.offset;
            } : void 8
      }
    });
  }
  prototype.collisionRectangle = function(){
    var adjust;
    adjust = 2;
    return new Rect(this.x + kHalfTile - this.width / 2, this.y + this.width / 2 - adjust, this.width, this.height);
  };
  prototype.update = function(elapsedTime, map, ptools){
    var i$, ref$, len$, tile, tileRect, particleX, particleY;
    this.offset += kL1Speed * elapsedTime;
    for (i$ = 0, len$ = (ref$ = map.getCollidingTiles(this.collisionRectangle())).length; i$ < len$; ++i$) {
      tile = ref$[i$];
      if (tile.type === WALL_TILE) {
        tileRect = new Rect(tileToGame(tile.col), tileToGame(tile.row), tileToGame(1), tileToGame(1));
        particleX = this.x;
        particleY = this.y;
        switch (this.mode) {
        case UP:
          particleY = tileRect.bottom - kHalfTile;
          break;
        case DOWN:
          particleY = tileRect.top - kHalfTile;
          break;
        case LEFT:
          particleX = tileRect.right - kHalfTile;
          break;
        case RIGHT:
          particleX = tileRect.left - kHalfTile;
        }
        ptools.frontSystem.addNewParticle(new WallParticle(ptools.graphics, particleX, particleY));
        return false;
      }
    }
    if (!this.alive) {
      return false;
    } else if (this.offset >= this.lifespan) {
      ptools.frontSystem.addNewParticle(new StarParticle(ptools.graphics, this.x, this.y));
      return false;
    } else {
      return true;
    }
  };
  prototype.draw = function(graphics){
    return this.sprite.draw(graphics, this.x, this.y);
  };
  prototype.collideWithEnemy = function(){
    return this.alive = false;
  };
  return PolarStarProjectile;
}(Projectile));
out$.PolarStar = PolarStar = (function(){
  PolarStar.displayName = 'PolarStar';
  var prototype = PolarStar.prototype, constructor = PolarStar;
  function PolarStar(graphics){
    this.projectileA = null;
    this.projectileB = null;
    this.sprites = this.initialiseSprites(graphics);
    this.hpSprite = new Sprite(graphics, 'bullet', kProjectileSrcHorizontal);
    this.vpSprite = new Sprite(graphics, 'bullet', kProjectileSrcVertical);
  }
  prototype.initialiseSprites = function(graphics){
    return SpriteState.generateWith(function(state){
      var tileY;
      tileY = state.LEFT ? kLeftOffset : kRightOffset;
      switch (true) {
      case state.HORIZONTAL:
        tileY += kHorizontalOffset;
        break;
      case state.UP:
        tileY += kUpOffset;
        break;
      case state.DOWN:
        tileY += kDownOffset;
      }
      return new Sprite(graphics, kArmsSpritePath, new SpriteSource(kPolarStarIndex * kSpriteWidth, tileY, kSpriteWidth, kSpriteHeight));
    });
  };
  prototype.startFire = function(state, playerX, playerY){
    var bulletX, bulletY;
    if (this.projectileA && this.projectileB) {
      return;
    }
    bulletX = this.gunX(state, playerX) - kHalfTile;
    bulletY = this.gunY(state, playerY) - kHalfTile;
    switch (true) {
    case state.HORIZONTAL:
      bulletY += kNozzleHorizY;
      bulletX += state.LEFT ? kNozzleHorizLeftX : kNozzleHorizRightX;
      break;
    case state.UP:
      bulletY += kNozzleUpY;
      bulletX += state.LEFT ? kNozzleUpLeftX : kNozzleUpRightX;
      break;
    case state.DOWN:
      bulletY += kNozzleDownY;
      bulletX += state.LEFT ? kNozzleDownLeftX : kNozzleDownRightX;
    }
    if (!this.projectileA) {
      return this.projectileA = new PolarStarProjectile(state.HORIZONTAL
        ? this.hpSprite
        : this.vpSprite, state, bulletX, bulletY);
    } else if (!this.projectileB) {
      return this.projectileB = new PolarStarProjectile(state.HORIZONTAL
        ? this.hpSprite
        : this.vpSprite, state, bulletX, bulletY);
    }
  };
  prototype.stopFire = function(){};
  prototype.gunX = function(state, playerX){
    if (state.LEFT) {
      return playerX - kHalfTile;
    } else {
      return playerX;
    }
  };
  prototype.gunY = function(state, playerY){
    if (state.UP) {
      playerY -= kHalfTile / 2;
    }
    if (state.DOWN) {
      playerY += kHalfTile / 2;
    }
    return playerY + this.gunBob(state);
  };
  prototype.gunBob = function(state){
    if (state.WALKING && (state.STRIDE_LEFT || state.STRIDE_RIGHT)) {
      return -2;
    } else {
      return 0;
    }
  };
  prototype.getProjectiles = function(){
    var projectiles, that;
    projectiles = [];
    if (that = this.projectileA) {
      projectiles.push(that);
    }
    if (that = this.projectileB) {
      projectiles.push(that);
    }
    return projectiles;
  };
  prototype.updateProjectiles = function(elapsedTime, map, ptools){
    var ref$;
    if (!((ref$ = this.projectileA) != null && ref$.update(elapsedTime, map, ptools))) {
      this.projectileA = null;
    }
    if (!((ref$ = this.projectileB) != null && ref$.update(elapsedTime, map, ptools))) {
      return this.projectileB = null;
    }
  };
  prototype.draw = function(graphics, playerX, playerY, state){
    var gunX, gunY, ref$;
    gunX = this.gunX(state, playerX);
    gunY = this.gunY(state, playerY);
    this.sprites[state.key].draw(graphics, gunX, gunY);
    if ((ref$ = this.projectileA) != null) {
      ref$.draw(graphics);
    }
    return (ref$ = this.projectileB) != null ? ref$.draw(graphics) : void 8;
  };
  return PolarStar;
}());
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{"./map":23,"./projectile":28,"./rectangle":30,"./sprite":39,"./spritestate":40,"./star-particle":41,"./units":44,"./wall-particle":45,"std":42}],9:[function(require,module,exports){
var std, SDL, units, config, kScreenWidth, kScreenHeight, kBackgroundSize, FixedBackdrop, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
SDL = require('SDL');
units = require('./units');
config = require('./config');
kScreenWidth = config.kScreenWidth, kScreenHeight = config.kScreenHeight;
kBackgroundSize = 4;
out$.FixedBackdrop = FixedBackdrop = (function(){
  FixedBackdrop.displayName = 'FixedBackdrop';
  var prototype = FixedBackdrop.prototype, constructor = FixedBackdrop;
  function FixedBackdrop(path, graphics){
    this.surface = graphics.loadImage(path);
  }
  prototype.draw = function(graphics){
    var i$, step$, to$, x, lresult$, j$, step1$, to1$, y, destRect, results$ = [];
    for (i$ = 0, to$ = units.tileToPx(kScreenWidth + kBackgroundSize), step$ = units.tileToPx(kBackgroundSize); step$ < 0 ? i$ >= to$ : i$ <= to$; i$ += step$) {
      x = i$;
      lresult$ = [];
      for (j$ = 0, to1$ = units.tileToPx(kScreenHeight + kBackgroundSize), step1$ = units.tileToPx(kBackgroundSize); step1$ < 0 ? j$ >= to1$ : j$ <= to1$; j$ += step1$) {
        y = j$;
        destRect = new SDL.Rect(x, y, units.tileToPx(kBackgroundSize), units.tileToPx(kBackgroundSize));
        lresult$.push(graphics.blitSurface(this.surface, null, destRect));
      }
      results$.push(lresult$);
    }
    return results$;
  };
  return FixedBackdrop;
}());
},{"./config":10,"./units":44,"SDL":33,"std":42}],10:[function(require,module,exports){
var kScreenWidth, kScreenHeight, kFps, kMaxFrameTime, kGraphicsQuality, debugFeatures, that, showCollisions, showSpritesheets, showReadout, assetPath, fileExt, findAsset, out$ = typeof exports != 'undefined' && exports || this;
out$.kScreenWidth = kScreenWidth = 20;
out$.kScreenHeight = kScreenHeight = 15;
out$.kFps = kFps = 60;
out$.kMaxFrameTime = kMaxFrameTime = 5 * 1000 / kFps;
out$.kGraphicsQuality = kGraphicsQuality = 32;
out$.debugFeatures = debugFeatures = (that = ENABLE_DEBUG_FEATURES) != null ? that : false;
out$.showCollisions = showCollisions = debugFeatures;
out$.showSpritesheets = showSpritesheets = debugFeatures;
out$.showReadout = showReadout = debugFeatures;
switch (kGraphicsQuality) {
case 16:
  out$.assetPath = assetPath = 'data/16x16/';
  out$.fileExt = fileExt = '.bmp';
  break;
case 32:
  out$.assetPath = assetPath = 'data/32x32/';
  out$.fileExt = fileExt = '.bmp';
}
out$.findAsset = findAsset = function(){
  return (function(it){
    return assetPath + it;
  })((function(it){
    return it + fileExt;
  }).apply(this, arguments));
};
},{}],11:[function(require,module,exports){
var std, units, Timer, NumberSprite, kVelocity, kVanishTime, DamageText, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
Timer = require('./timer').Timer;
NumberSprite = require('./sprite').NumberSprite;
kVelocity = -units.kHalfTile / 250;
kVanishTime = 2000;
out$.DamageText = DamageText = (function(){
  DamageText.displayName = 'DamageText';
  var prototype = DamageText.prototype, constructor = DamageText;
  function DamageText(graphics, centerX, centerY){
    this.centerX = centerX;
    this.centerY = centerY;
    this.timer = new Timer(kVanishTime);
    this.damage = 0;
    this.offsetY = 0;
    this.shouldRise = false;
  }
  prototype.setPosition = function(x, y){
    this.centerX = x;
    return this.centerY = y + this.offsetY;
  };
  prototype.setDamage = function(damage){
    this.shouldRise = this.damage === 0;
    if (this.shouldRise) {
      this.offsetY = 0;
    }
    this.damage += damage;
    return this.timer.reset();
  };
  prototype.update = function(elapsedTime){
    if (this.timer.isExpired) {
      this.damage = 0;
    }
    if (this.shouldRise) {
      this.offsetY = std.max(units.tileToGame(-1), this.offsetY + kVelocity * elapsedTime);
    }
    return this.expired;
  };
  prototype.draw = function(graphics){
    if (this.timer.isActive && this.damage > 0) {
      return new NumberSprite.DamageNumber(graphics, this.damage).drawCentered(graphics, this.centerX, this.centerY);
    }
  };
  Object.defineProperty(prototype, 'expired', {
    get: function(){
      return this.timer.isExpired;
    },
    configurable: true,
    enumerable: true
  });
  return DamageText;
}());
},{"./sprite":39,"./timer":43,"./units":44,"std":42}],12:[function(require,module,exports){
var std, allTexts, owners, reject, DamageTexts, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
allTexts = [];
owners = new WeakMap;
reject = std.flip(std.reject)(allTexts);
out$.DamageTexts = DamageTexts = {
  addDamageable: function(damageable){
    var text;
    text = damageable.getDamageText();
    allTexts.push(text);
    return owners.set(text, damageable);
  },
  update: function(elapsedTime){
    return allTexts = reject(function(text){
      var owner;
      if (!text.expired) {
        owner = owners.get(text);
        text.setPosition(owner.centerX, owner.centerY);
      }
      return text.update(elapsedTime);
    });
  },
  draw: function(graphics){
    var i$, ref$, len$, text, results$ = [];
    for (i$ = 0, len$ = (ref$ = allTexts).length; i$ < len$; ++i$) {
      text = ref$[i$];
      results$.push(text.draw(graphics));
    }
    return results$;
  }
};
},{"std":42}],13:[function(require,module,exports){
var std, InterfaceError, Damageable, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
InterfaceError = (function(superclass){
  var prototype = extend$((import$(InterfaceError, superclass).displayName = 'InterfaceError', InterfaceError), superclass).prototype, constructor = InterfaceError;
  function InterfaceError(message){
    this.message = message;
    this.name = 'InterfaceError';
  }
  return InterfaceError;
}(Error));
out$.Damageable = Damageable = (function(){
  Damageable.displayName = 'Damageable';
  var prototype = Damageable.prototype, constructor = Damageable;
  Object.defineProperty(prototype, 'centerX', {
    get: function(){
      throw new InterfaceError("Damageable - `center-x` getter not implemented");
    },
    configurable: true,
    enumerable: true
  });
  Object.defineProperty(prototype, 'centerY', {
    get: function(){
      throw new InterfaceError("Damageable - `center-y` getter not implemented");
    },
    configurable: true,
    enumerable: true
  });
  prototype.getDamageText = function(){
    throw new InterfaceError("Damageable - `get-damage-text` method not implemented");
  };
  function Damageable(){}
  return Damageable;
}());
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{"std":42}],14:[function(require,module,exports){
var std, units, kHalfTile, PolarVector, AnimatedSprite, SpriteSource, kSrc, kBaseVelocity, DeathCloudParticle, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
kHalfTile = units.kHalfTile;
PolarVector = require('./polar').PolarVector;
AnimatedSprite = require('./sprite').AnimatedSprite;
SpriteSource = require('./rectangle').SpriteSource;
kSrc = new SpriteSource(1, 0, 1, 1);
kBaseVelocity = 0.12;
out$.DeathCloudParticle = DeathCloudParticle = (function(){
  DeathCloudParticle.displayName = 'DeathCloudParticle';
  var prototype = DeathCloudParticle.prototype, constructor = DeathCloudParticle;
  function DeathCloudParticle(graphics, centerX, centerY, speed, angle){
    this.centerX = centerX;
    this.centerY = centerY;
    this.speed = speed;
    this.offset = new PolarVector(0, angle);
    this.sprite = new AnimatedSprite(graphics, 'Npc/NpcSym', kSrc, 18, [0, 1, 2, 3, 4, 5, 6]);
  }
  prototype.update = function(elapsedTime){
    this.sprite.update(elapsedTime);
    this.offset.mag += elapsedTime * this.speed;
    return this.sprite.numCompletedLoops === 0;
  };
  prototype.draw = function(graphics){
    return this.sprite.draw(graphics, this.centerX + this.offset.x - kHalfTile, this.centerY + this.offset.y - kHalfTile);
  };
  DeathCloudParticle.createRandomDeathClouds = function(ptools, centerX, centerY, num){
    var i$, ix, randomAngle, randomSpeed, results$ = [];
    for (i$ = 0; i$ <= num; ++i$) {
      ix = i$;
      randomAngle = std.rand(0, std.tau);
      randomSpeed = kBaseVelocity * std.rand(0, 2);
      results$.push(ptools.entitySystem.addNewParticle(new DeathCloudParticle(ptools.graphics, centerX, centerY, randomSpeed, randomAngle)));
    }
    return results$;
  };
  return DeathCloudParticle;
}());
},{"./polar":27,"./rectangle":30,"./sprite":39,"./units":44,"std":42}],15:[function(require,module,exports){
var std, units, config, tileToPx, tileToGame, kHalfTile, kTilePx, Damageable, DamageText, DamageTexts, ref$, Sprite, AnimatedSprite, Rect, SpriteSource, RIGHT, LEFT, kAngularVelocity, kFlyFps, kNumFlyFrames, kContactDamage, SpriteState, FirstCaveBat, slice$ = [].slice, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
config = require('./config');
tileToPx = units.tileToPx, tileToGame = units.tileToGame, kHalfTile = units.kHalfTile, kTilePx = units.kTilePx;
Damageable = require('./damageable').Damageable;
DamageText = require('./damage-text').DamageText;
DamageTexts = require('./damage-texts').DamageTexts;
ref$ = require('./sprite'), Sprite = ref$.Sprite, AnimatedSprite = ref$.AnimatedSprite;
ref$ = require('./rectangle'), Rect = ref$.Rectangle, SpriteSource = ref$.SpriteSource;
RIGHT = "R";
LEFT = "L";
kAngularVelocity = 120 / 1000;
kFlyFps = 15;
kNumFlyFrames = 3;
kContactDamage = 1;
SpriteState = function(){
  var args;
  args = slice$.call(arguments);
  return String(args.join('-'));
};
out$.FirstCaveBat = FirstCaveBat = (function(superclass){
  var prototype = extend$((import$(FirstCaveBat, superclass).displayName = 'FirstCaveBat', FirstCaveBat), superclass).prototype, constructor = FirstCaveBat;
  function FirstCaveBat(graphics, x, flightCenterY){
    this.x = x;
    this.flightCenterY = flightCenterY;
    this.y = this.flightCenterY;
    this.flightAngle = 0;
    this.alive = true;
    this.angularVelocity = kAngularVelocity;
    this.sprites = this.initialiseSprites(graphics);
    this.damageText = new DamageText(graphics);
    this.contactDamage = kContactDamage;
    DamageTexts.addDamageable(this);
  }
  Object.defineProperty(prototype, 'spritestate', {
    get: function(){
      return SpriteState(this.horizontalFacing);
    },
    configurable: true,
    enumerable: true
  });
  prototype.initialiseSprite = function(graphics, facing){
    var facingOffset;
    facingOffset = facing === RIGHT ? 1 : 0;
    return new AnimatedSprite(graphics, 'Npc/NpcCemet', new SpriteSource(2, 2 + facingOffset, 1, 1), kFlyFps, (function(){
      var i$, to$, results$ = [];
      for (i$ = 0, to$ = kNumFlyFrames; i$ < to$; ++i$) {
        results$.push(i$);
      }
      return results$;
    }()));
  };
  prototype.initialiseSprites = function(graphics, spriteMap){
    var i$, ref$, len$, facing;
    spriteMap == null && (spriteMap = {});
    for (i$ = 0, len$ = (ref$ = [LEFT, RIGHT]).length; i$ < len$; ++i$) {
      facing = ref$[i$];
      spriteMap[SpriteState(facing)] = this.initialiseSprite(graphics, facing);
    }
    return spriteMap;
  };
  prototype.update = function(elapsedTime, playerX){
    this.horizontalFacing = playerX < this.x ? LEFT : RIGHT;
    this.flightAngle += this.angularVelocity * elapsedTime;
    this.y = this.flightCenterY + units.tileToGame(5) / 2 * std.sin(units.degToRad(this.flightAngle));
    this.sprites[this.spritestate].update(elapsedTime);
    return this.alive;
  };
  prototype.draw = function(graphics){
    if (config.showCollisions) {
      graphics.visualiseRect(this.collisionRectangle());
    }
    return this.sprites[this.spritestate].draw(graphics, this.x, this.y);
  };
  prototype.damageCollision = function(){
    return new Rect(this.centerX, this.centerY, 1, 1);
  };
  prototype.collisionRectangle = function(){
    return new Rect(this.x, this.y, tileToGame(1), tileToGame(1));
  };
  prototype.takeDamage = function(damage){
    this.damageText.setDamage(damage);
    return this.alive = false;
  };
  Object.defineProperty(prototype, 'centerX', {
    get: function(){
      return this.x + kHalfTile;
    },
    configurable: true,
    enumerable: true
  });
  Object.defineProperty(prototype, 'centerY', {
    get: function(){
      return this.y + kHalfTile;
    },
    configurable: true,
    enumerable: true
  });
  prototype.getDamageText = function(){
    return this.damageText;
  };
  return FirstCaveBat;
}(Damageable));
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{"./config":10,"./damage-text":11,"./damage-texts":12,"./damageable":13,"./rectangle":30,"./sprite":39,"./units":44,"std":42}],16:[function(require,module,exports){
var std, SDL, input, units, config, readout, graphics, Map, tileToGame, Timer, Player, Rectangle, FirstCaveBat, FixedBackdrop, DamageTexts, ref$, ParticleTools, ParticleSystem, StarParticle, DeathCloudParticle, GunExperienceHUD, kScreenWidth, kScreenHeight, kFps, kMaxFrameTime, kDebugMode, running, player, bat, map, ptools, xpHud, timeFactor, lastFrameTime, anyKeysPressed, eventLoop, update, draw, createTestWorld, start, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
SDL = require('SDL');
input = require('./input');
units = require('./units');
config = require('./config');
readout = require('./readout');
graphics = require('./graphics');
Map = require('./map');
tileToGame = units.tileToGame;
Timer = require('./timer').Timer;
Player = require('./player').Player;
Rectangle = require('./rectangle').Rectangle;
FirstCaveBat = require('./first-cave-bat').FirstCaveBat;
FixedBackdrop = require('./backdrop').FixedBackdrop;
DamageTexts = require('./damage-texts').DamageTexts;
ref$ = require('./particle-system'), ParticleTools = ref$.ParticleTools, ParticleSystem = ref$.ParticleSystem;
StarParticle = require('./star-particle').StarParticle;
DeathCloudParticle = require('./death-cloud-particle').DeathCloudParticle;
GunExperienceHUD = require('./gun-xp-hud').GunExperienceHUD;
kScreenWidth = config.kScreenWidth, kScreenHeight = config.kScreenHeight, kFps = config.kFps, kMaxFrameTime = config.kMaxFrameTime, kDebugMode = config.kDebugMode;
running = true;
player = null;
bat = null;
map = null;
ptools = null;
xpHud = null;
timeFactor = 1;
lastFrameTime = 0;
anyKeysPressed = false;
eventLoop = function(){
  var startTime, event, Δt, elapsedTime;
  startTime = SDL.getTicks();
  input.beginNewFrame();
  while (event = SDL.pollEvent()) {
    anyKeysPressed = true;
    readout.update('willstop', false);
    switch (event.type) {
    case SDL.KEYDOWN:
      input.keyDownEvent(event);
      break;
    case SDL.KEYUP:
      input.keyUpEvent(event);
      break;
    default:
      throw new Error({
        message: "Unknown event type: " + event
      });
    }
  }
  if (input.wasKeyPressed(SDL.KEY.ESCAPE)) {
    running = false;
  }
  if (input.isKeyHeld(SDL.KEY.LEFT) && input.isKeyHeld(SDL.KEY.RIGHT)) {
    player.stopMoving();
  } else if (input.isKeyHeld(SDL.KEY.LEFT)) {
    player.startMovingLeft();
  } else if (input.isKeyHeld(SDL.KEY.RIGHT)) {
    player.startMovingRight();
  } else {
    player.stopMoving();
  }
  if (input.wasKeyPressed(SDL.KEY.Z)) {
    player.startJump();
  } else if (input.wasKeyReleased(SDL.KEY.Z)) {
    player.stopJump();
  }
  if (input.wasKeyPressed(SDL.KEY.X)) {
    player.startFire();
  } else if (input.wasKeyReleased(SDL.KEY.X)) {
    player.stopFire();
  }
  if (input.isKeyHeld(SDL.KEY.UP) && input.isKeyHeld(SDL.KEY.DOWN)) {
    player.lookHorizontal();
  } else if (input.isKeyHeld(SDL.KEY.UP)) {
    player.lookUp();
  } else if (input.isKeyHeld(SDL.KEY.DOWN)) {
    player.lookDown();
  } else {
    player.lookHorizontal();
  }
  if (input.wasKeyPressed(SDL.KEY.ONE)) {
    timeFactor = 1;
  }
  if (input.wasKeyPressed(SDL.KEY.TWO)) {
    timeFactor = 2;
  }
  if (input.wasKeyPressed(SDL.KEY.THREE)) {
    timeFactor = 3;
  }
  if (input.wasKeyPressed(SDL.KEY.FOUR)) {
    timeFactor = 4;
  }
  Δt = std.min(SDL.getTicks() - lastFrameTime, kMaxFrameTime);
  update(Δt / timeFactor);
  draw();
  if (running) {
    lastFrameTime = SDL.getTicks();
    elapsedTime = lastFrameTime - startTime;
    readout.update('frametime', std.floor(1000 / Δt));
    readout.update('drawtime', elapsedTime);
    return SDL.delay(1000 / kFps - elapsedTime, eventLoop);
  } else {
    return std.log('Game stopped.');
  }
};
update = function(elapsedTime){
  var i$, ref$, len$, projectile;
  Timer.updateAll(elapsedTime);
  player.update(elapsedTime, map, ptools);
  if (bat && !(bat != null && bat.update(elapsedTime, player.x))) {
    DeathCloudParticle.createRandomDeathClouds(ptools, bat.centerX, bat.centerY, 3);
    bat = null;
  }
  for (i$ = 0, len$ = (ref$ = player.getProjectiles()).length; i$ < len$; ++i$) {
    projectile = ref$[i$];
    if (bat != null && bat.collisionRectangle().collidesWith(projectile.collisionRectangle())) {
      projectile.collideWithEnemy();
      bat.takeDamage(projectile.contactDamage);
    }
  }
  if (bat != null && bat.damageCollision().collidesWith(player.damageCollision())) {
    player.takeDamage(bat.contactDamage);
  }
  DamageTexts.update(elapsedTime);
  return ptools.update(elapsedTime);
};
draw = function(){
  graphics.clear();
  map.drawBackground(graphics);
  if (bat != null) {
    bat.draw(graphics);
  }
  player.draw(graphics);
  ptools.entitySystem.draw(graphics);
  map.draw(graphics);
  player.drawHud(graphics);
  ptools.frontSystem.draw(graphics);
  DamageTexts.draw(graphics);
  return xpHud.draw(graphics, 2);
};
createTestWorld = function(){
  map = Map.createTestMap(graphics);
  player = new Player(graphics, units.tileToGame(kScreenWidth / 2), units.tileToGame(10));
  bat = new FirstCaveBat(graphics, units.tileToGame(7), units.tileToGame(8));
  ptools = new ParticleTools(graphics);
  return xpHud = new GunExperienceHUD(graphics);
};
out$.start = start = function(){
  SDL.init(SDL.INIT_EVERYTHING);
  readout.addReader('frametime', 'Frame time');
  readout.addReader('drawtime', 'Draw time');
  readout.addReader('willstop', 'Will stop', true);
  createTestWorld();
  eventLoop();
  return std.delay(5000, function(){
    if (!anyKeysPressed) {
      return running = false;
    } else {
      return std.log("Game being interacted with. Don't shut down");
    }
  });
};
},{"./backdrop":9,"./config":10,"./damage-texts":12,"./death-cloud-particle":14,"./first-cave-bat":15,"./graphics":17,"./gun-xp-hud":18,"./input":22,"./map":23,"./particle-system":24,"./player":26,"./readout":29,"./rectangle":30,"./star-particle":41,"./timer":43,"./units":44,"SDL":33,"std":42}],17:[function(require,module,exports){
var std, SDL, config, units, kScreenWidth, kScreenHeight, kTransparentColor, kScreenScaleFactor, spritesheets, screen, loadImage, blitSurface, clear, visualiseRect, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
SDL = require('SDL');
config = require('./config');
units = require('./units');
kScreenWidth = config.kScreenWidth, kScreenHeight = config.kScreenHeight;
kTransparentColor = [0, 0, 0];
kScreenScaleFactor = config.kGraphicsQuality === 16 ? 2 : 1;
spritesheets = {};
screen = SDL.setVideoMode(units.tileToPx(kScreenWidth), units.tileToPx(kScreenHeight), kScreenScaleFactor);
out$.loadImage = loadImage = function(filename, useTransparency){
  useTransparency == null && (useTransparency = false);
  if (spritesheets[filename] == null) {
    spritesheets[filename] = SDL.loadImage(config.findAsset(filename));
    if (useTransparency) {
      SDL.setColorKey(spritesheets[filename], kTransparentColor);
    }
    if (config.showSpritesheets) {
      document.body.appendChild(spritesheets[filename].canvas);
    }
  }
  return spritesheets[filename];
};
out$.blitSurface = blitSurface = function(source, srcRect, destRect){
  return SDL.blitSurface(source, srcRect, screen, destRect);
};
out$.clear = clear = bind$(screen, 'clear');
out$.visualiseRect = visualiseRect = function(rect, fill){
  var paintRect;
  paintRect = new SDL.Rect(units.gameToPx(rect.left), units.gameToPx(rect.top), units.gameToPx(rect.w), units.gameToPx(rect.h));
  if (fill) {
    return screen.drawRect(paintRect, 'red');
  } else {
    return screen.drawBox(paintRect, 'red');
  }
};
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}
},{"./config":10,"./units":44,"SDL":33,"std":42}],18:[function(require,module,exports){
var std, units, tileToGame, tileToPx, gameToPx, kHalfTile, SpriteSource, ref$, Sprite, NumberSprite, VaryingWidthSprite, kDrawY, kLvDrawX, kBarDrawX, kLvlNumDrawX, kSpriteName, kBarSrc, kLvSrc, GunExperienceHUD, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
tileToGame = units.tileToGame, tileToPx = units.tileToPx, gameToPx = units.gameToPx, kHalfTile = units.kHalfTile;
SpriteSource = require('./rectangle').SpriteSource;
ref$ = require('./sprite'), Sprite = ref$.Sprite, NumberSprite = ref$.NumberSprite, VaryingWidthSprite = ref$.VaryingWidthSprite;
kDrawY = tileToGame(1.5);
kLvDrawX = tileToGame(1.0);
kBarDrawX = tileToGame(2.5);
kLvlNumDrawX = tileToGame(2.0);
kSpriteName = 'TextBox';
kBarSrc = new SpriteSource(0, 4.5, 2.5, 0.5);
kLvSrc = {
  x: tileToPx(5),
  y: gameToPx(160),
  w: tileToPx(1),
  h: tileToPx(0.5)
};
out$.GunExperienceHUD = GunExperienceHUD = (function(){
  GunExperienceHUD.displayName = 'GunExperienceHUD';
  var prototype = GunExperienceHUD.prototype, constructor = GunExperienceHUD;
  function GunExperienceHUD(graphics){
    this.xpBarSprite = new Sprite(graphics, kSpriteName, kBarSrc);
    this.lvSprite = new Sprite(graphics, kSpriteName, kLvSrc);
  }
  prototype.draw = function(graphics, gunLvl){
    var lvlNumSprite;
    this.lvSprite.draw(graphics, kLvDrawX, kDrawY);
    this.xpBarSprite.draw(graphics, kBarDrawX, kDrawY);
    lvlNumSprite = NumberSprite.HUDNumber(graphics, gunLvl, 1);
    return lvlNumSprite.draw(graphics, kLvlNumDrawX, kDrawY);
  };
  return GunExperienceHUD;
}());
},{"./rectangle":30,"./sprite":39,"./units":44,"std":42}],19:[function(require,module,exports){
var std, units, px, Timer, Particle, Sprite, PolarVector, Rectangle, kSpriteSrc, kFlashPeriod, kLifeTime, kSpeed, HeadBumpParticle, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
px = units.gameToPx;
Timer = require('./timer').Timer;
Particle = require('./particle').Particle;
Sprite = require('./sprite').Sprite;
PolarVector = require('./polar').PolarVector;
Rectangle = require('./rectangle').Rectangle;
kSpriteSrc = new Rectangle(px(116), px(54), px(6), px(6));
kFlashPeriod = 25;
kLifeTime = 700;
kSpeed = 0.12;
out$.HeadBumpParticle = HeadBumpParticle = (function(superclass){
  var prototype = extend$((import$(HeadBumpParticle, superclass).displayName = 'HeadBumpParticle', HeadBumpParticle), superclass).prototype, constructor = HeadBumpParticle;
  function HeadBumpParticle(graphics, centerX, centerY){
    this.centerX = centerX;
    this.centerY = centerY;
    this.lifeTimer = new Timer(kLifeTime, true);
    this.particleA = new PolarVector(0, std.rand(0, std.tau));
    this.particleB = new PolarVector(0, std.rand(0, std.tau));
    this.maxOffsetA = std.floor(std.rand(4, 20));
    this.maxOffsetB = std.floor(std.rand(4, 20));
    this.sprite = new Sprite(graphics, 'Caret', kSpriteSrc);
  }
  prototype.update = function(elapsedTime){
    this.particleA.mag = std.min(this.maxOffsetA, this.particleA.mag + elapsedTime * kSpeed);
    this.particleB.mag = std.min(this.maxOffsetB, this.particleB.mag + elapsedTime * kSpeed);
    return this.lifeTimer.active();
  };
  prototype.draw = function(graphics){
    if ((this.lifeTimer.currentTime / kFlashPeriod) % 2 < 1) {
      this.sprite.draw(graphics, this.centerX + this.particleA.x, this.centerY + this.particleA.y);
      return this.sprite.draw(graphics, this.centerX + this.particleB.x, this.centerY + this.particleB.y);
    }
  };
  return HeadBumpParticle;
}(Particle));
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{"./particle":25,"./polar":27,"./rectangle":30,"./sprite":39,"./timer":43,"./units":44,"std":42}],20:[function(require,module,exports){
var std, units, div, kHalfTile, pxToTile, tileToPx, pxToGame, tileToGame, Timer, SpriteSource, ref$, Sprite, NumberSprite, VaryingWidthSprite, kHealthBarX, kHealthBarY, kHealthFillX, kHealthFillY, kHealthNumX, kHealthNumY, kMaxFillPx, kMaxFill, kDamageDelay, kSpritePath, kHealthBarSrc, kHealthFillSrc, kDamageFillSrc, Health, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
div = std.div;
kHalfTile = units.kHalfTile, pxToTile = units.pxToTile, tileToPx = units.tileToPx, pxToGame = units.pxToGame, tileToGame = units.tileToGame;
Timer = require('./timer').Timer;
SpriteSource = require('./rectangle').SpriteSource;
ref$ = require('./sprite'), Sprite = ref$.Sprite, NumberSprite = ref$.NumberSprite, VaryingWidthSprite = ref$.VaryingWidthSprite;
kHealthBarX = tileToGame(1);
kHealthBarY = tileToGame(2);
kHealthFillX = tileToGame(2.5);
kHealthFillY = tileToGame(2);
kHealthNumX = tileToGame(1.5);
kHealthNumY = tileToGame(2);
kMaxFillPx = tileToPx(2.5) - 1;
kMaxFill = pxToTile(kMaxFillPx);
kDamageDelay = 1500;
kSpritePath = 'TextBox';
kHealthBarSrc = new SpriteSource(0, 2.5, 4, 0.5);
kHealthFillSrc = new SpriteSource(0, 1.5, kMaxFill, 0.5);
kDamageFillSrc = new SpriteSource(0, 2.0, kMaxFill, 0.5);
out$.Health = Health = (function(){
  Health.displayName = 'Health';
  var prototype = Health.prototype, constructor = Health;
  function Health(graphics, maxHealth){
    this.maxHealth = maxHealth != null ? maxHealth : 6;
    this.currentHealth = this.maxHealth;
    this.damage = 0;
    this.damageTimer = new Timer(kDamageDelay);
    this.healthBarSprite = new Sprite(graphics, kSpritePath, kHealthBarSrc);
    this.healthFillSprite = new VaryingWidthSprite(graphics, kSpritePath, kHealthFillSrc);
    this.damageFillSprite = new VaryingWidthSprite(graphics, kSpritePath, kDamageFillSrc);
  }
  prototype.takeDamage = function(damage){
    if (this.currentHealth === 0) {
      return;
    }
    this.damageTimer.reset();
    this.healthFillSprite.setWidth(this.fillOffset(this.currentHealth - damage));
    this.damageFillSprite.setWidth(this.fillOffset(damage));
    this.damage = damage;
    return this.currentHealth - damage <= 0;
  };
  prototype.update = function(elapsedTime){
    if (this.damage > 0 && this.damageTimer.isExpired) {
      this.currentHealth = std.max(0, this.currentHealth - this.damage);
      return this.damage = 0;
    }
  };
  prototype.fillOffset = function(health){
    return kMaxFillPx * (health / this.maxHealth);
  };
  prototype.draw = function(graphics){
    var x;
    this.healthBarSprite.draw(graphics, kHealthBarX, kHealthBarY);
    if (this.currentHealth !== 0) {
      this.healthFillSprite.draw(graphics, kHealthFillX, kHealthFillY);
      if (this.damage) {
        x = kHealthFillX + pxToGame(this.fillOffset(this.currentHealth - this.damage));
        this.damageFillSprite.draw(graphics, x, kHealthFillY);
      }
    }
    return new NumberSprite.HUDNumber(graphics, this.currentHealth, 2).draw(graphics, kHealthNumX, kHealthNumY);
  };
  return Health;
}());
},{"./rectangle":30,"./sprite":39,"./timer":43,"./units":44,"std":42}],21:[function(require,module,exports){
var std, AnimatedSprite, ImmobileSingleLoopParticle, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
AnimatedSprite = require('./sprite').AnimatedSprite;
out$.ImmobileSingleLoopParticle = ImmobileSingleLoopParticle = (function(){
  ImmobileSingleLoopParticle.displayName = 'ImmobileSingleLoopParticle';
  var prototype = ImmobileSingleLoopParticle.prototype, constructor = ImmobileSingleLoopParticle;
  function ImmobileSingleLoopParticle(graphics, x, y, spritePath, spriteSource, fps, frames){
    this.x = x;
    this.y = y;
    this.sprite = new AnimatedSprite(graphics, spritePath, spriteSource, fps, (function(){
      var i$, to$, results$ = [];
      for (i$ = 0, to$ = frames; i$ < to$; ++i$) {
        results$.push(i$);
      }
      return results$;
    }()));
  }
  prototype.update = function(elapsedTime){
    this.sprite.update(elapsedTime);
    return this.sprite.numCompletedLoops === 0;
  };
  prototype.draw = function(graphics){
    return this.sprite.draw(graphics, this.x, this.y);
  };
  return ImmobileSingleLoopParticle;
}());
},{"./sprite":39,"std":42}],22:[function(require,module,exports){
var std, Input;
std = require('std');
Input = (function(){
  Input.displayName = 'Input';
  var prototype = Input.prototype, constructor = Input;
  function Input(){
    this.heldKeys = {};
    this.pressedKeys = {};
    this.releasedKeys = {};
  }
  prototype.beginNewFrame = function(){
    this.pressedKeys = {};
    return this.releasedKeys = {};
  };
  prototype.keyDownEvent = function(event){
    this.pressedKeys[event.key] = true;
    return this.heldKeys[event.key] = true;
  };
  prototype.keyUpEvent = function(event){
    this.releasedKeys[event.key] = true;
    return this.heldKeys[event.key] = false;
  };
  prototype.wasKeyPressed = function(key){
    return this.pressedKeys[key];
  };
  prototype.wasKeyReleased = function(key){
    return this.releasedKeys[key];
  };
  prototype.isKeyHeld = function(key){
    return this.heldKeys[key];
  };
  return Input;
}());
module.exports = new Input;
},{"std":42}],23:[function(require,module,exports){
var std, units, div, tileToPx, gameToPx, tileToGame, Sprite, FixedBackdrop, SpriteSource, ref$, AIR_TILE, WALL_TILE, kMapWidth, Tile, CollisionTile, Map;
std = require('std');
units = require('./units');
div = std.div;
tileToPx = units.tileToPx, gameToPx = units.gameToPx, tileToGame = units.tileToGame;
Sprite = require('./sprite').Sprite;
FixedBackdrop = require('./backdrop').FixedBackdrop;
SpriteSource = require('./rectangle').SpriteSource;
ref$ = std['enum'], AIR_TILE = ref$[0], WALL_TILE = ref$[1];
kMapWidth = 20;
Tile = (function(){
  Tile.displayName = 'Tile';
  var prototype = Tile.prototype, constructor = Tile;
  function Tile(type, sprite){
    this.type = type != null ? type : AIR_TILE;
    this.sprite = sprite;
  }
  return Tile;
}());
CollisionTile = (function(){
  CollisionTile.displayName = 'CollisionTile';
  var prototype = CollisionTile.prototype, constructor = CollisionTile;
  function CollisionTile(row, col, type){
    this.row = row;
    this.col = col;
    this.type = type;
  }
  return CollisionTile;
}());
module.exports = Map = (function(){
  Map.displayName = 'Map';
  var prototype = Map.prototype, constructor = Map;
  function Map(){
    this.backdrop = null;
    this.tiles = Map.createMatrix(new Tile, kMapWidth, 15);
    this.bgTiles = Map.createMatrix(null, kMapWidth, 15);
  }
  prototype.draw = function(graphics){
    var i$, ref$, len$, y, row, lresult$, j$, len1$, x, tile, ref1$, results$ = [];
    for (i$ = 0, len$ = (ref$ = this.tiles).length; i$ < len$; ++i$) {
      y = i$;
      row = ref$[i$];
      lresult$ = [];
      for (j$ = 0, len1$ = row.length; j$ < len1$; ++j$) {
        x = j$;
        tile = row[j$];
        lresult$.push((ref1$ = tile.sprite) != null ? ref1$.draw(graphics, tileToGame(x), tileToGame(y)) : void 8);
      }
      results$.push(lresult$);
    }
    return results$;
  };
  prototype.drawBackground = function(graphics){
    var i$, ref$, len$, y, row, lresult$, j$, len1$, x, sprite, results$ = [];
    this.backdrop.draw(graphics);
    for (i$ = 0, len$ = (ref$ = this.bgTiles).length; i$ < len$; ++i$) {
      y = i$;
      row = ref$[i$];
      lresult$ = [];
      for (j$ = 0, len1$ = row.length; j$ < len1$; ++j$) {
        x = j$;
        sprite = row[j$];
        lresult$.push(sprite != null ? sprite.draw(graphics, tileToGame(x), tileToGame(y)) : void 8);
      }
      results$.push(lresult$);
    }
    return results$;
  };
  prototype.getCollidingTiles = function(rect){
    var firstRow, lastRow, firstCol, lastCol, collisionTiles, i$, row, j$, col;
    firstRow = div(gameToPx(rect.top), tileToPx(1));
    lastRow = div(gameToPx(rect.bottom), tileToPx(1));
    firstCol = div(gameToPx(rect.left), tileToPx(1));
    lastCol = div(gameToPx(rect.right), tileToPx(1));
    collisionTiles = [];
    for (i$ = firstRow; i$ <= lastRow; ++i$) {
      row = i$;
      for (j$ = firstCol; j$ <= lastCol; ++j$) {
        col = j$;
        if (row < 0 || col < 0 || col >= kMapWidth) {
          collisionTiles.push(new CollisionTile(row, col, WALL_TILE));
        } else {
          collisionTiles.push(new CollisionTile(row, col, this.tiles[row][col].type));
        }
      }
    }
    return collisionTiles;
  };
  Map.createTestMap = function(graphics){
    var map, bgPath, fgPath, numRows, numCols, row, tile, i$, col, chainTop, chainMid, chainBtm;
    map = new Map;
    bgPath = 'bkBlue';
    fgPath = 'Stage/PrtCave';
    map.backdrop = new FixedBackdrop(bgPath, graphics);
    numRows = 15;
    numCols = 20;
    row = 11;
    tile = new Tile(WALL_TILE, new Sprite(graphics, fgPath, new SpriteSource(1, 0, 1, 1)));
    for (i$ = 0; i$ <= numCols; ++i$) {
      col = i$;
      map.tiles[row][col] = tile;
    }
    map.tiles[10][5] = tile;
    map.tiles[9][4] = tile;
    map.tiles[8][3] = tile;
    map.tiles[7][2] = tile;
    map.tiles[10][3] = tile;
    map.tiles[10][0] = tile;
    map.tiles[8][10] = tile;
    chainTop = new Sprite(graphics, fgPath, new SpriteSource(11, 2));
    chainMid = new Sprite(graphics, fgPath, new SpriteSource(12, 2));
    chainBtm = new Sprite(graphics, fgPath, new SpriteSource(13, 2));
    map.bgTiles[8][2] = chainTop;
    map.bgTiles[9][2] = chainMid;
    map.bgTiles[10][2] = chainBtm;
    return map;
  };
  Map.createMatrix = function(value, cols, rows){
    var i$, y, lresult$, j$, z, results$ = [];
    for (i$ = 0; i$ <= rows; ++i$) {
      y = i$;
      lresult$ = [];
      for (j$ = 0; j$ <= cols; ++j$) {
        z = j$;
        lresult$.push(value);
      }
      results$.push(lresult$);
    }
    return results$;
  };
  Map.WALL_TILE = WALL_TILE;
  Map.AIR_TILE = AIR_TILE;
  return Map;
}());
},{"./backdrop":9,"./rectangle":30,"./sprite":39,"./units":44,"std":42}],24:[function(require,module,exports){
var std, units, readout, ParticleTools, ParticleSystem, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
readout = require('./readout');
out$.ParticleTools = ParticleTools = (function(){
  ParticleTools.displayName = 'ParticleTools';
  var prototype = ParticleTools.prototype, constructor = ParticleTools;
  function ParticleTools(graphics){
    this.graphics = graphics;
    this.entitySystem = new ParticleSystem;
    this.frontSystem = new ParticleSystem;
  }
  prototype.update = function(elapsedTime){
    this.entitySystem.update(elapsedTime);
    return this.frontSystem.update(elapsedTime);
  };
  return ParticleTools;
}());
out$.ParticleSystem = ParticleSystem = (function(){
  ParticleSystem.displayName = 'ParticleSystem';
  var prototype = ParticleSystem.prototype, constructor = ParticleSystem;
  function ParticleSystem(){
    readout.addReader('particles', 'Particles', 0);
    this.particles = [];
  }
  prototype.addNewParticle = function(it){
    return this.particles.push(it);
  };
  prototype.update = function(elapsedTime){
    readout.update('particles', this.particles.length);
    return this.particles = std.filter(function(it){
      return it.update(elapsedTime);
    }, this.particles);
  };
  prototype.draw = function(graphics){
    return this.particles.forEach(function(it){
      return it.draw(graphics);
    });
  };
  return ParticleSystem;
}());
},{"./readout":29,"./units":44,"std":42}],25:[function(require,module,exports){
var InterfaceError, Particle, out$ = typeof exports != 'undefined' && exports || this;
InterfaceError = (function(superclass){
  var prototype = extend$((import$(InterfaceError, superclass).displayName = 'InterfaceError', InterfaceError), superclass).prototype, constructor = InterfaceError;
  function InterfaceError(message){
    this.message = message;
    this.name = 'InterfaceError';
  }
  return InterfaceError;
}(Error));
out$.Particle = Particle = (function(){
  Particle.displayName = 'Particle';
  var prototype = Particle.prototype, constructor = Particle;
  prototype.update = function(elapsedTime){
    throw new InterfaceError("Particle - `update` not implemented");
  };
  prototype.draw = function(graphics){
    throw new InterfaceError("Particle - `draw` not implemented");
  };
  function Particle(){}
  return Particle;
}());
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{}],26:[function(require,module,exports){
var std, units, config, readout, kHalfTile, tileToGame, tileToPx, WALL_TILE, Timer, Health, Damageable, DamageText, DamageTexts, PolarStar, ref$, SpriteState, State, Rect, SpriteSource, Sprite, AnimatedSprite, NumberSprite, HeadBumpParticle, kCharacterFrame, kWalkFrame, kStandFrame, kJumpFrame, kFallFrame, kUpFrameOffset, kDownFrame, kBackFrame, kNumWalkFrames, kWalkFps, kStrideMiddleFrameOffset, kStrideLeftFrameOffset, kStrideRightFrameOffset, kFriction, kGravity, kWalkingAcceleration, kAirAcceleration, kMaxSpeedX, kMaxSpeedY, kJumpSpeed, kShortJumpSpeed, kJumpGravity, kInvincibleTime, kInvincibleFlashTime, kCollisionX, kCollisionYTop, kCollisionYHeight, kCollisionYTopWidth, kCollisionYBottomWidth, kCollisionYTopLeft, kCollisionYBottomLeft, kCollisionYBottom, WalkingAnimation, Player, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
config = require('./config');
readout = require('./readout');
kHalfTile = units.kHalfTile, tileToGame = units.tileToGame, tileToPx = units.tileToPx;
WALL_TILE = require('./map').WALL_TILE;
Timer = require('./timer').Timer;
Health = require('./health').Health;
Damageable = require('./damageable').Damageable;
DamageText = require('./damage-text').DamageText;
DamageTexts = require('./damage-texts').DamageTexts;
PolarStar = require('./arms').PolarStar;
ref$ = require('./spritestate'), SpriteState = ref$.SpriteState, State = ref$.State;
ref$ = require('./rectangle'), Rect = ref$.Rectangle, SpriteSource = ref$.SpriteSource;
ref$ = require('./sprite'), Sprite = ref$.Sprite, AnimatedSprite = ref$.AnimatedSprite, NumberSprite = ref$.NumberSprite;
HeadBumpParticle = require('./head-bump-particle').HeadBumpParticle;
kCharacterFrame = 0;
kWalkFrame = 0;
kStandFrame = 0;
kJumpFrame = 1;
kFallFrame = 2;
kUpFrameOffset = 3;
kDownFrame = 6;
kBackFrame = 7;
kNumWalkFrames = 3;
kWalkFps = 15;
kStrideMiddleFrameOffset = 0;
kStrideLeftFrameOffset = 1;
kStrideRightFrameOffset = 2;
kFriction = 0.00049804687;
kGravity = 0.00078125;
kWalkingAcceleration = 0.00083007812;
kAirAcceleration = 0.0003125;
kMaxSpeedX = 0.15859375;
kMaxSpeedY = 0.2998046875;
kJumpSpeed = 0.25;
kShortJumpSpeed = 0.25 / 1.5;
kJumpGravity = 0.0003125;
kInvincibleTime = 3000;
kInvincibleFlashTime = 50;
kCollisionX = new Rect(6, 10, 20, 12);
kCollisionYTop = 2;
kCollisionYHeight = 30;
kCollisionYTopWidth = 18;
kCollisionYBottomWidth = 10;
kCollisionYTopLeft = (tileToGame(1) - kCollisionYTopWidth) / 2;
kCollisionYBottomLeft = (tileToGame(1) - kCollisionYBottomWidth) / 2;
kCollisionYBottom = kCollisionYTop + kCollisionYHeight;
WalkingAnimation = (function(){
  WalkingAnimation.displayName = 'WalkingAnimation';
  var prototype = WalkingAnimation.prototype, constructor = WalkingAnimation;
  function WalkingAnimation(numFrames, fps){
    this.numFrames = numFrames;
    this.fps = fps;
    this.frameTimer = new Timer(1000 / this.fps);
    this.forward = true;
    this.index = 0;
  }
  prototype.stride = function(){
    switch (this.index) {
    case 0:
      return State.STRIDE_LEFT;
    case 1:
      return State.STRIDE_MIDDLE;
    case 2:
      return State.STRIDE_RIGHT;
    default:
      return State.STRIDE_LEFT;
    }
  };
  prototype.update = function(){
    if (this.frameTimer.isExpired) {
      this.frameTimer.reset();
      if (this.forward) {
        this.index += 1;
        return this.forward = this.index !== this.numFrames - 1;
      } else {
        this.index -= 1;
        return this.forward = this.index === 0;
      }
    }
  };
  prototype.reset = function(){
    this.frameTimer.reset();
    this.index = 0;
    return this.forward = true;
  };
  return WalkingAnimation;
}());
out$.Player = Player = (function(superclass){
  var prototype = extend$((import$(Player, superclass).displayName = 'Player', Player), superclass).prototype, constructor = Player;
  function Player(graphics, x, y){
    this.x = x;
    this.y = y;
    this.velocityY = 0;
    this.velocityX = 0;
    this.accelerationX = 0;
    this.horizontalFacing = State.LEFT;
    this.intendedVerticalFacing = State.HORIZONTAL;
    this.onGround = false;
    this.jumpActive = false;
    this.interacting = false;
    this.walkAnimation = new WalkingAnimation(kNumWalkFrames, kWalkFps);
    this.invincibleTimer = new Timer(kInvincibleTime);
    this.health = new Health(graphics);
    this.sprites = this.initialiseSprites(graphics);
    this.damageText = new DamageText(graphics);
    DamageTexts.addDamageable(this);
    this.gun = new PolarStar(graphics);
  }
  prototype.initialiseSprites = function(graphics, spriteMap){
    spriteMap == null && (spriteMap = {});
    return SpriteState.generateWith(function(state){
      var tileX, tileY;
      tileX = (function(){
        switch (true) {
        case state.WALKING:
          return kWalkFrame;
        case state.STANDING:
          return kStandFrame;
        case state.JUMPING:
          return kJumpFrame;
        case state.FALLING:
          return kFallFrame;
        case state.INTERACTING:
          return kBackFrame;
        }
      }());
      if (state.UP) {
        tileX += kUpFrameOffset;
      }
      if (state.DOWN) {
        tileX = kDownFrame;
      }
      tileY = kCharacterFrame + (state.LEFT ? 0 : 1);
      if (state.WALKING) {
        tileX += (function(){
          switch (true) {
          case state.STRIDE_LEFT:
            return kStrideLeftFrameOffset;
          case state.STRIDE_RIGHT:
            return kStrideRightFrameOffset;
          case state.STRIDE_MIDDLE:
            return kStrideMiddleFrameOffset;
          }
        }());
      }
      return new Sprite(graphics, 'MyChar', new SpriteSource(tileX, tileY, 1, 1));
    });
  };
  prototype.update = function(elapsedTime, map, ptools){
    this.sprites[this.getSpriteState().key].update(elapsedTime);
    this.health.update(elapsedTime);
    this.gun.updateProjectiles(elapsedTime, map, ptools);
    this.updateX(elapsedTime, map);
    this.updateY(elapsedTime, map, ptools);
    return this.walkAnimation.update(elapsedTime);
  };
  prototype.updateX = function(elapsedTime, map){
    var accX, Δx;
    accX = this.onGround ? kWalkingAcceleration : kAirAcceleration;
    this.velocityX += this.accelerationX * accX * elapsedTime;
    if (this.accelerationX < 0) {
      this.velocityX = std.max(this.velocityX, -kMaxSpeedX);
    } else if (this.accelerationX > 0) {
      this.velocityX = std.min(this.velocityX, kMaxSpeedX);
    } else if (this.onGround) {
      this.velocityX = this.velocityX > 0
        ? std.max(0, this.velocityX - kFriction * elapsedTime)
        : std.min(0, this.velocityX + kFriction * elapsedTime);
    }
    Δx = this.velocityX * elapsedTime;
    if (Δx > 0) {
      this.onWallCollision(map, this.rightCollision(Δx), function(tile){
        if (tile) {
          this.x = units.tileToGame(tile.col) - kCollisionX.right;
          return this.velocityX = 0;
        } else {
          return this.x += Δx;
        }
      });
      return this.onWallCollision(map, this.leftCollision(0), function(tile){
        if (tile) {
          return this.x = units.tileToGame(tile.col) + kCollisionX.right;
        }
      });
    } else {
      this.onWallCollision(map, this.leftCollision(Δx), function(tile){
        if (tile) {
          this.x = units.tileToGame(tile.col) + kCollisionX.right;
          return this.velocityX = 0;
        } else {
          return this.x += Δx;
        }
      });
      return this.onWallCollision(map, this.rightCollision(0), function(tile){
        if (tile) {
          return this.x = units.tileToGame(tile.col) - kCollisionX.right;
        }
      });
    }
  };
  prototype.updateY = function(elapsedTime, map, ptools){
    var gravity, Δy;
    gravity = this.jumpActive && this.velocityY < 0 ? kJumpGravity : kGravity;
    this.velocityY = std.min(this.velocityY + gravity * elapsedTime, kMaxSpeedY);
    Δy = this.velocityY * elapsedTime;
    if (Δy > 0) {
      this.onWallCollision(map, this.bottomCollision(Δy), function(tile){
        if (tile) {
          this.y = units.tileToGame(tile.row) - kCollisionYBottom;
          this.velocityY = 0;
          return this.onGround = true;
        } else {
          this.y += Δy;
          return this.onGround = false;
        }
      });
      return this.onWallCollision(map, this.topCollision(0), function(tile){
        if (tile) {
          return this.y = units.tileToGame(tile.row) + kCollisionYHeight;
        }
      });
    } else {
      this.onWallCollision(map, this.topCollision(Δy), function(tile){
        if (tile) {
          this.y = units.tileToGame(tile.row) + kCollisionYHeight;
          this.velocityY = 0;
          return ptools.frontSystem.addNewParticle(new HeadBumpParticle(ptools.graphics, this.centerX, this.y + kCollisionYTop));
        } else {
          this.y += Δy;
          return this.onGround = false;
        }
      });
      return this.onWallCollision(map, this.bottomCollision(0), function(tile){
        if (tile) {
          this.y = units.tileToGame(tile.row) - kCollisionYBottom;
          return this.onGround = true;
        }
      });
    }
  };
  prototype.takeDamage = function(damage){
    damage == null && (damage = 1);
    if (!this.invincibleTimer.isActive) {
      this.health.takeDamage(damage);
      this.velocityY = std.min(-kShortJumpSpeed, this.velocityY);
      this.invincible = true;
      this.invincibleTimer.reset();
      return this.damageText.setDamage(damage);
    }
  };
  prototype.spriteIsVisible = function(){
    var duty;
    duty = std.div(this.invincibleTimer.currentTime, kInvincibleFlashTime) % 2 === 0;
    return !(this.invincibleTimer.isActive && duty);
  };
  prototype.draw = function(graphics){
    var state;
    if (config.showCollisions) {
      graphics.visualiseRect(this.damageCollision());
    }
    if (this.spriteIsVisible()) {
      state = this.getSpriteState();
      this.gun.draw(graphics, this.x, this.y, state);
      return this.sprites[state.key].draw(graphics, this.x, this.y);
    }
  };
  prototype.drawHud = function(graphics){
    if (!this.spriteIsVisible()) {
      return;
    }
    return this.health.draw(graphics);
  };
  prototype.getSpriteState = function(){
    var motionType;
    motionType = this.interacting
      ? State.INTERACTING
      : this.onGround
        ? this.accelerationX === 0
          ? State.STANDING
          : State.WALKING
        : this.velocityY < 0
          ? State.JUMPING
          : State.FALLING;
    return SpriteState.make(this.horizontalFacing, this.verticalFacing(), motionType, this.walkAnimation.stride());
  };
  prototype.leftCollision = function(Δ){
    return new Rect(this.x + kCollisionX.left + Δ, this.y + kCollisionX.top, kCollisionX.w / 2 - Δ, kCollisionX.h);
  };
  prototype.rightCollision = function(Δ){
    return new Rect(this.x + kCollisionX.left + kCollisionX.w / 2, this.y + kCollisionX.top, kCollisionX.w / 2 + Δ, kCollisionX.h);
  };
  prototype.topCollision = function(Δ){
    return new Rect(this.x + kCollisionYTopLeft, this.y + kCollisionYTop + Δ, kCollisionYTopWidth, kCollisionYHeight / 2 - Δ);
  };
  prototype.bottomCollision = function(Δ){
    return new Rect(this.x + kCollisionYBottomLeft, this.y + kCollisionYTop + kCollisionYHeight / 2 + Δ, kCollisionYBottomWidth, kCollisionYHeight / 2 + Δ);
  };
  prototype.damageCollision = function(){
    return new Rect(this.x + kCollisionX.left, this.y + kCollisionYTop, kCollisionX.w, kCollisionYHeight);
  };
  prototype.onWallCollision = function(map, rect, λ){
    var i$, ref$, len$, tile;
    for (i$ = 0, len$ = (ref$ = map.getCollidingTiles(rect)).length; i$ < len$; ++i$) {
      tile = ref$[i$];
      if (tile.type === WALL_TILE) {
        return λ.call(this, tile);
      }
    }
    return λ.call(this);
  };
  prototype.startMovingLeft = function(){
    if (this.onGround && this.accelerationX === 0) {
      this.walkAnimation.reset();
    }
    this.horizontalFacing = State.LEFT;
    this.accelerationX = -1;
    return this.interacting = false;
  };
  prototype.startMovingRight = function(){
    if (this.onGround && this.accelerationX === 0) {
      this.walkAnimation.reset();
    }
    this.horizontalFacing = State.RIGHT;
    this.accelerationX = 1;
    return this.interacting = false;
  };
  prototype.stopMoving = function(){
    return this.accelerationX = 0;
  };
  prototype.startJump = function(){
    this.jumpActive = true;
    this.interacting = false;
    if (this.onGround) {
      return this.velocityY = -kJumpSpeed;
    }
  };
  prototype.stopJump = function(){
    return this.jumpActive = false;
  };
  prototype.startFire = function(){
    return this.gun.startFire(this.getSpriteState(), this.x, this.y);
  };
  prototype.stopFire = function(){
    return this.gun.stopFire();
  };
  prototype.lookUp = function(){
    this.intendedVerticalFacing = State.UP;
    return this.interacting = false;
  };
  prototype.lookDown = function(){
    if (this.intendedVerticalFacing === State.DOWN) {
      return;
    }
    this.intendedVerticalFacing = State.DOWN;
    return this.interacting = this.onGround;
  };
  prototype.lookHorizontal = function(){
    return this.intendedVerticalFacing = State.HORIZONTAL;
  };
  Object.defineProperty(prototype, 'centerX', {
    get: function(){
      return this.x + kHalfTile;
    },
    configurable: true,
    enumerable: true
  });
  Object.defineProperty(prototype, 'centerY', {
    get: function(){
      return this.y + kHalfTile;
    },
    configurable: true,
    enumerable: true
  });
  prototype.getDamageText = function(){
    return this.damageText;
  };
  prototype.getProjectiles = function(){
    return this.gun.getProjectiles();
  };
  prototype.verticalFacing = function(){
    if (this.onGround && this.intendedVerticalFacing === State.DOWN) {
      return State.HORIZONTAL;
    } else {
      return this.intendedVerticalFacing;
    }
  };
  return Player;
}(Damageable));
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{"./arms":8,"./config":10,"./damage-text":11,"./damage-texts":12,"./damageable":13,"./head-bump-particle":19,"./health":20,"./map":23,"./readout":29,"./rectangle":30,"./sprite":39,"./spritestate":40,"./timer":43,"./units":44,"std":42}],27:[function(require,module,exports){
var std, PolarVector, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
out$.PolarVector = PolarVector = (function(){
  PolarVector.displayName = 'PolarVector';
  var prototype = PolarVector.prototype, constructor = PolarVector;
  function PolarVector(mag, angle){
    this.mag = mag;
    this.angle = angle;
  }
  Object.defineProperty(prototype, 'x', {
    get: function(){
      return this.mag * std.cos(this.angle);
    },
    configurable: true,
    enumerable: true
  });
  Object.defineProperty(prototype, 'y', {
    get: function(){
      return this.mag * std.sin(this.angle);
    },
    configurable: true,
    enumerable: true
  });
  return PolarVector;
}());
},{"std":42}],28:[function(require,module,exports){
var Projectile, out$ = typeof exports != 'undefined' && exports || this;
out$.Projectile = Projectile = (function(){
  Projectile.displayName = 'Projectile';
  var prototype = Projectile.prototype, constructor = Projectile;
  function Projectile(damage){
    this.contactDamage = damage;
  }
  prototype.collisionRectangle = function(){};
  prototype.collideWithEnemy = function(){};
  return Projectile;
}());
},{}],29:[function(require,module,exports){
var config, elm, applyStyles, Reader, host, readers, install, addReader, update, removeReader, out$ = typeof exports != 'undefined' && exports || this;
config = require('./config');
elm = bind$(document, 'createElement');
applyStyles = function(el, styles){
  var k, v, results$ = [];
  for (k in styles) {
    v = styles[k];
    results$.push(el.style[k] = v);
  }
  return results$;
};
Reader = (function(){
  Reader.displayName = 'Reader';
  var prototype = Reader.prototype, constructor = Reader;
  function Reader(name, labelText, value){
    var that;
    this.name = name;
    this.labelText = labelText;
    this.value = value;
    this.dom = elm('tr');
    this.label = elm('td');
    this.output = elm('td');
    this.dom.appendChild(this.label);
    this.dom.appendChild(this.output);
    this.label.innerHTML = this.labelText;
    if (that = this.value) {
      this.output.innerHTML = that;
    }
  }
  prototype.update = function(value){
    this.value = value;
    return this.output.innerHTML = this.value;
  };
  prototype.hide = function(){
    return this.dom.styles.display = 'none';
  };
  prototype.show = function(){
    return this.dom.styles.display = 'block';
  };
  prototype.install = function(host){
    return host.appendChild(this.dom);
  };
  prototype['delete'] = function(){
    return this.dom.parentNode.removeChild(this.dom);
  };
  return Reader;
}());
host = elm('table');
readers = {};
applyStyles(host, {
  fontFamily: 'monospace',
  width: '100%',
  paddingLeft: '10px',
  color: 'lightgrey',
  borderWidth: "3px 1px"
});
out$.install = install = function(){
  if (config.showReadout) {
    return document.body.appendChild(host);
  }
};
out$.addReader = addReader = function(name, label, value){
  readers[name] = new Reader(name, label, value);
  return readers[name].install(host);
};
out$.update = update = function(readerName, value){
  var ref$;
  return (ref$ = readers[readerName]) != null ? ref$.update(value) : void 8;
};
out$.removeReader = removeReader = function(name){
  var ref$;
  readers[name]['delete']();
  return ref$ = readers[name], delete readers[name], ref$;
};
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}
},{"./config":10}],30:[function(require,module,exports){
var units, Rectangle, SpriteSource, out$ = typeof exports != 'undefined' && exports || this;
units = require('./units');
out$.Rectangle = Rectangle = (function(){
  Rectangle.displayName = 'Rectangle';
  var prototype = Rectangle.prototype, constructor = Rectangle;
  function Rectangle(x, y, w, h, m){
    m == null && (m = 1);
    this.x = x * m;
    this.y = y * m;
    this.w = w * m;
    this.h = h * m;
    this.top = this.y;
    this.left = this.x;
    this.right = this.x + this.w;
    this.bottom = this.y + this.h;
  }
  prototype.collidesWith = function(other){
    return this.right >= other.left && this.left <= other.right && this.top <= other.bottom && this.bottom >= other.top;
  };
  return Rectangle;
}());
out$.SpriteSource = SpriteSource = (function(){
  SpriteSource.displayName = 'SpriteSource';
  var prototype = SpriteSource.prototype, constructor = SpriteSource;
  function SpriteSource(tileX, tileY, tileW, tileH){
    tileW == null && (tileW = 1);
    tileH == null && (tileH = 1);
    this.x = units.tileToPx(tileX);
    this.y = units.tileToPx(tileY);
    this.w = units.tileToPx(tileW);
    this.h = units.tileToPx(tileH);
  }
  return SpriteSource;
}());
},{"./units":44}],31:[function(require,module,exports){
var raf, out$ = typeof exports != 'undefined' && exports || this;
raf = requestAnimationFrame;
import$(out$, {
  delay: function(time, λ){
    return raf(λ);
  }
});
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{}],32:[function(require,module,exports){
var std, queue, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
queue = [];
import$(out$, {
  pushEvent: function(event){
    return queue.push(event);
  },
  pollEvent: function(){
    if (queue.length) {
      return queue.shift();
    }
  }
});
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{"std":42}],33:[function(require,module,exports){
var std, delay, timer, screen, keyboard, eventQueue, Rect, Surface, ref$, INIT_EVERYTHING, FULLSCREEN, init, KEY, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
delay = require('./delay');
timer = require('./timer');
screen = require('./screen');
keyboard = require('./keyboard');
eventQueue = require('./event-queue');
out$.Rect = Rect = require('./rect');
out$.Surface = Surface = require('./surface');
ref$ = std['enum'], INIT_EVERYTHING = ref$[0], FULLSCREEN = ref$[1];
out$.init = init = function(mode){
  std.log("SDL::Init - with mode:", mode);
  timer.init();
  return keyboard.init();
};
out$.INIT_EVERYTHING = INIT_EVERYTHING;
out$.FULLSCREEN = FULLSCREEN;
out$.KEYDOWN = keyboard.KEYDOWN;
out$.KEYUP = keyboard.KEYUP;
out$.KEY = KEY = keyboard.KEYCODES;
out$.delay = delay.delay;
out$.getTicks = timer.getTicks;
out$.pollEvent = eventQueue.pollEvent;
out$.setVideoMode = screen.setVideoMode;
out$.blitSurface = Surface.blitSurface;
out$.setColorKey = Surface.setColorKey;
out$.loadImage = Surface.loadImage;
},{"./delay":31,"./event-queue":32,"./keyboard":34,"./rect":35,"./screen":36,"./surface":37,"./timer":38,"std":42}],34:[function(require,module,exports){
var std, queue, ref$, KEYDOWN, KEYUP, KEYCODES, monitorKeys, init, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
queue = require('./event-queue');
ref$ = std['enum'], KEYDOWN = ref$[0], KEYUP = ref$[1];
out$.KEYCODES = KEYCODES = {
  ESCAPE: 27,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  ONE: 49,
  TWO: 50,
  THREE: 51,
  FOUR: 52,
  FIVE: 53,
  SIX: 54,
  SEVEN: 55,
  EIGHT: 56,
  NINE: 57,
  A: 65,
  Q: 81,
  S: 83,
  W: 87,
  X: 88,
  Z: 90
};
monitorKeys = function(){
  document.addEventListener('keydown', function(event){
    var which;
    which = event.which;
    queue.pushEvent({
      type: KEYDOWN,
      key: which
    });
    if (which === KEYCODES.UP || which === KEYCODES.DOWN || which === KEYCODES.LEFT || which === KEYCODES.RIGHT) {
      return event.preventDefault();
    }
  });
  return document.addEventListener('keyup', function(event){
    var which;
    which = event.which;
    queue.pushEvent({
      type: KEYUP,
      key: which
    });
    return event.preventDefault();
  });
};
out$.init = init = function(){
  std.log("SDL::Keyboard - Monitoring key input");
  return monitorKeys();
};
out$.KEYDOWN = KEYDOWN;
out$.KEYUP = KEYUP;
},{"./event-queue":32,"std":42}],35:[function(require,module,exports){
var Rect;
module.exports = Rect = (function(){
  Rect.displayName = 'Rect';
  var prototype = Rect.prototype, constructor = Rect;
  function Rect(x, y, w, h){
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }
  Rect.clone = function(arg$){
    var x, y, w, h;
    x = arg$.x, y = arg$.y, w = arg$.w, h = arg$.h;
    return new Rect(x, y, w, h);
  };
  return Rect;
}());
},{}],36:[function(require,module,exports){
var std, Surface, applyScaleStyles, createNewScreen, setVideoMode, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
Surface = require('./surface');
applyScaleStyles = function(canvas, scaleFactor){
  if (scaleFactor !== 0) {
    return canvas.style.width = canvas.width * scaleFactor + 'px';
  }
};
createNewScreen = function(w, h, scaleFactor){
  var screen;
  screen = new Surface(null, w, h);
  document.body.appendChild(screen.canvas);
  applyScaleStyles(screen.canvas, scaleFactor);
  return screen;
};
out$.setVideoMode = setVideoMode = function(width, height, scaleFactor){
  scaleFactor == null && (scaleFactor = 1);
  return createNewScreen(width, height, scaleFactor);
};
},{"./surface":37,"std":42}],37:[function(require,module,exports){
var std, Rect, makeTransparent, Surface;
std = require('std');
Rect = require('./rect');
makeTransparent = function(data, color){
  var canvas, context, pixels, i$, to$, i;
  canvas = document.createElement('canvas');
  canvas.width = data.width;
  canvas.height = data.height;
  context = canvas.getContext('2d');
  context.drawImage(data, 0, 0);
  pixels = context.getImageData(0, 0, canvas.width, canvas.height);
  for (i$ = 0, to$ = pixels.data.length; i$ <= to$; i$ += 4) {
    i = i$;
    if (pixels.data[i + 0] === color[0] && pixels.data[i + 1] === color[1] && pixels.data[i + 2] === color[2]) {
      pixels.data[i + 3] = 0;
    }
  }
  context.putImageData(pixels, 0, 0);
  return canvas;
};
module.exports = Surface = (function(){
  Surface.displayName = 'Surface';
  var prototype = Surface.prototype, constructor = Surface;
  function Surface(src, width, height){
    this.width = width;
    this.height = height;
    this.canvas = document.createElement('canvas');
    this.ctx = this.canvas.getContext('2d');
    this.ready = false;
    this.colorKey = null;
    this.resetCanvasSize();
    this.ctx.fillStyle = 'red';
    this.ctx.fillRect(0, 0, this.width, this.height);
    if (typeof src === 'string') {
      this.loadImageData(src);
    } else if (src != null) {
      this.saveImageData(src);
    } else {}
  }
  prototype.resetCanvasSize = function(){
    this.canvas.width = this.width;
    return this.canvas.height = this.height;
  };
  prototype.inheritSizeFromImage = function(data){
    if (this.width == null && this.height == null) {
      this.width = data.naturalWidth;
      this.height = data.naturalHeight;
      return this.resetCanvasSize();
    }
  };
  prototype.loadImageData = function(path){
    var data, this$ = this;
    data = new Image;
    data.onload = function(){
      this$.inheritSizeFromImage(data);
      return this$.saveImageData(data);
    };
    data.onerror = function(){
      std.log("Cant load:", path);
      return this$.ctx.fillRect(0, 0, this$.width, this$.height);
    };
    return data.src = path;
  };
  prototype.saveImageData = function(data){
    this.data = this.colorKey ? makeTransparent(data, this.colorKey) : data;
    this.ready = true;
    this.ctx.clearRect(0, 0, this.width, this.height);
    return this.ctx.drawImage(this.data, 0, 0, this.width, this.height);
  };
  prototype.setColorKey = function(color){
    this.colorKey = color;
    if (this.ready) {
      return this.saveImageData(this.data);
    }
  };
  prototype.drawRect = function(rect, color){
    color == null && (color = 'black');
    this.ctx.fillStyle = color;
    return this.ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
  };
  prototype.drawBox = function(rect, color){
    color == null && (color = 'black');
    this.ctx.strokeStyle = color;
    this.ctx.beginPath();
    this.ctx.moveTo(0.5 + rect.x, 0.5 + rect.y);
    this.ctx.lineTo(0.5 + rect.x, -0.5 + rect.y + rect.h);
    this.ctx.lineTo(-0.5 + rect.x + rect.w, -0.5 + rect.y + rect.h);
    this.ctx.lineTo(-0.5 + rect.x + rect.w, 0.5 + rect.y);
    this.ctx.lineTo(0.5 + rect.x, 0.5 + rect.y);
    this.ctx.stroke();
    return this.ctx.closePath();
  };
  prototype.clear = function(){
    return this.ctx.clearRect(0, 0, this.width, this.height);
  };
  Surface.setColorKey = function(surface, color){
    return surface.setColorKey(color);
  };
  Surface.blitSurface = function(source, srcRect, dest, destRect){
    if (srcRect) {
      return dest.ctx.drawImage(source.canvas, srcRect.x, srcRect.y, srcRect.w, srcRect.h, destRect.x, destRect.y, destRect.w, destRect.h);
    } else {
      return dest.ctx.drawImage(source.canvas, destRect.x, destRect.y, destRect.w, destRect.h);
    }
  };
  Surface.loadImage = function(path){
    return new Surface(path);
  };
  return Surface;
}());
},{"./rect":35,"std":42}],38:[function(require,module,exports){
var startTime, out$ = typeof exports != 'undefined' && exports || this;
startTime = 0;
import$(out$, {
  init: function(){
    return startTime = Date.now();
  },
  getTicks: function(){
    return Date.now() - startTime;
  }
});
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{}],39:[function(require,module,exports){
var SDL, std, units, div, kHalfTile, tileToPx, gameToPx, Timer, ref$, Rect, SpriteSource, Sprite, AnimatedSprite, NumberSprite, VaryingWidthSprite, out$ = typeof exports != 'undefined' && exports || this;
SDL = require('SDL');
std = require('std');
units = require('./units');
div = std.div;
kHalfTile = units.kHalfTile, tileToPx = units.tileToPx, gameToPx = units.gameToPx;
Timer = require('./timer').Timer;
ref$ = require('./rectangle'), Rect = ref$.Rectangle, SpriteSource = ref$.SpriteSource;
out$.Sprite = Sprite = (function(){
  Sprite.displayName = 'Sprite';
  var prototype = Sprite.prototype, constructor = Sprite;
  function Sprite(graphics, path, src){
    this.src = src;
    this.sourceRect = new SDL.Rect.clone(this.src);
    this.spriteSheet = graphics.loadImage(path, true);
  }
  prototype.update = function(){};
  prototype.draw = function(graphics, x, y){
    var destRect;
    destRect = new SDL.Rect(gameToPx(x), gameToPx(y), this.src.w, this.src.h);
    return graphics.blitSurface(this.spriteSheet, this.sourceRect, destRect);
  };
  return Sprite;
}());
out$.AnimatedSprite = AnimatedSprite = (function(superclass){
  var prototype = extend$((import$(AnimatedSprite, superclass).displayName = 'AnimatedSprite', AnimatedSprite), superclass).prototype, constructor = AnimatedSprite;
  function AnimatedSprite(graphics, path, src, fps, keyframes){
    this.src = src;
    this.fps = fps;
    this.keyframes = keyframes;
    AnimatedSprite.superclass.apply(this, arguments);
    this.frameTimer = new Timer(1000 / this.fps);
    this.currentFrame = 0;
    this.currentKeyframe = this.keyframes[0];
    this.originX = this.src.x;
    this.numCompletedLoops = 0;
  }
  prototype.draw = function(graphics, x, y, frameOffset){
    var destRect;
    frameOffset == null && (frameOffset = this.currentKeyframe);
    this.sourceRect.x = this.originX + frameOffset * this.sourceRect.w;
    destRect = new SDL.Rect(gameToPx(x), gameToPx(y), this.src.w, this.src.h);
    return graphics.blitSurface(this.spriteSheet, this.sourceRect, destRect);
  };
  prototype.update = function(){
    if (this.frameTimer.isExpired) {
      this.frameTimer.reset();
      this.currentFrame += 1;
      if (this.currentFrame >= this.keyframes.length) {
        this.numCompletedLoops += 1;
        this.currentFrame = 0;
      }
      return this.currentKeyframe = this.keyframes[this.currentFrame];
    }
  };
  return AnimatedSprite;
}(Sprite));
out$.NumberSprite = NumberSprite = (function(){
  NumberSprite.displayName = 'NumberSprite';
  var kDigitSrcY, kOpPlusSrcX, kOpMinusSrcX, kOpSrcY, kDigitSize, kRadix, ref$, WHITE, RED, PLUS, MINUS, NONE, prototype = NumberSprite.prototype, constructor = NumberSprite;
  kDigitSrcY = 3.5;
  kOpPlusSrcX = 2;
  kOpMinusSrcX = 2.5;
  kOpSrcY = 3;
  kDigitSize = units.kHalfTile;
  kRadix = 10;
  ref$ = std['enum'], WHITE = ref$[0], RED = ref$[1];
  ref$ = std['enum'], PLUS = ref$[0], MINUS = ref$[1], NONE = ref$[2];
  function NumberSprite(graphics, num, len, color, op){
    var srcY;
    this.num = num;
    this.len = len;
    this.color = color;
    this.op = op;
    this.digits = NumberSprite.seperateDigits(this.num);
    this.numDigits = this.digits.length;
    this.padding = this.len === 0
      ? 0
      : kDigitSize * (this.len - this.numDigits);
    srcY = this.color === WHITE
      ? kDigitSrcY
      : kDigitSrcY + 0.5;
    this.glyphs = this.digits.map(function(it){
      return new Sprite(graphics, 'TextBox', new SpriteSource(0.5 * it, srcY, 0.5, 0.5));
    });
    if (this.op === PLUS) {
      this.glyphs.push(new Sprite(graphics, 'TextBox', new SpriteSource(kOpPlusSrcX, kOpSrcY, 0.5, 0.5)));
    }
    if (this.op === MINUS) {
      this.glyphs.push(new Sprite(graphics, 'TextBox', new SpriteSource(kOpMinusSrcX, kOpSrcY, 0.5, 0.5)));
    }
    this.width = kHalfTile * this.glyphs.length;
    this.height = kHalfTile;
  }
  prototype.draw = function(graphics, x, y){
    var i$, ref$, len$, i, glyph, offset, results$ = [];
    for (i$ = 0, len$ = (ref$ = this.glyphs).length; i$ < len$; ++i$) {
      i = i$;
      glyph = ref$[i$];
      offset = kDigitSize * (this.glyphs.length - 1 - i);
      results$.push(glyph.draw(graphics, x + this.padding + offset, y));
    }
    return results$;
  };
  prototype.drawCentered = function(graphics, x, y){
    return this.draw(graphics, x - this.width / 2, y - this.height / 2);
  };
  NumberSprite.seperateDigits = function(num){
    var digit, results$ = [];
    if (num === 0) {
      return [0];
    } else {
      while (num !== 0) {
        digit = num % kRadix;
        num = div(num, kRadix);
        results$.push(digit);
      }
      return results$;
    }
  };
  NumberSprite.HUDNumber = function(graphics, num, len){
    this.num = num;
    this.len = len;
    return new NumberSprite(graphics, this.num, this.len, WHITE, NONE);
  };
  NumberSprite.DamageNumber = function(graphics, num){
    this.num = num;
    return new NumberSprite(graphics, this.num, 0, RED, MINUS);
  };
  NumberSprite.ExperienceNumber = function(graphics, num){
    this.num = num;
    return new NumberSprite(graphics, this.num, 0, WHITE, PLUS);
  };
  return NumberSprite;
}());
out$.VaryingWidthSprite = VaryingWidthSprite = (function(superclass){
  var prototype = extend$((import$(VaryingWidthSprite, superclass).displayName = 'VaryingWidthSprite', VaryingWidthSprite), superclass).prototype, constructor = VaryingWidthSprite;
  function VaryingWidthSprite(graphics, path, src){
    this.src = src;
    VaryingWidthSprite.superclass.apply(this, arguments);
  }
  prototype.setWidth = function(width){
    return this.src.w = width;
  };
  return VaryingWidthSprite;
}(Sprite));
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{"./rectangle":30,"./timer":43,"./units":44,"SDL":33,"std":42}],40:[function(require,module,exports){
var std, units, NONE, STANDING, WALKING, JUMPING, FALLING, INTERACTING, LEFT, RIGHT, UP, DOWN, HORIZONTAL, STRIDE_LEFT, STRIDE_RIGHT, STRIDE_MIDDLE, State, motions, hfacings, vfacings, strides, SpriteState, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
NONE = Math.pow(2, 0);
STANDING = Math.pow(2, 1);
WALKING = Math.pow(2, 2);
JUMPING = Math.pow(2, 3);
FALLING = Math.pow(2, 4);
INTERACTING = Math.pow(2, 5);
LEFT = Math.pow(2, 6);
RIGHT = Math.pow(2, 7);
UP = Math.pow(2, 8);
DOWN = Math.pow(2, 9);
HORIZONTAL = Math.pow(2, 10);
STRIDE_LEFT = Math.pow(2, 11);
STRIDE_RIGHT = Math.pow(2, 12);
STRIDE_MIDDLE = Math.pow(2, 13);
out$.State = State = {
  NONE: NONE,
  STANDING: STANDING,
  WALKING: WALKING,
  JUMPING: JUMPING,
  FALLING: FALLING,
  INTERACTING: INTERACTING,
  LEFT: LEFT,
  RIGHT: RIGHT,
  UP: UP,
  DOWN: DOWN,
  HORIZONTAL: HORIZONTAL,
  STRIDE_LEFT: STRIDE_LEFT,
  STRIDE_RIGHT: STRIDE_RIGHT,
  STRIDE_MIDDLE: STRIDE_MIDDLE
};
out$.motions = motions = [STANDING, WALKING, JUMPING, FALLING, INTERACTING];
out$.hfacings = hfacings = [LEFT, RIGHT];
out$.vfacings = vfacings = [UP, DOWN, HORIZONTAL];
out$.strides = strides = [STRIDE_LEFT, STRIDE_RIGHT, STRIDE_MIDDLE];
out$.SpriteState = SpriteState = {
  make: function(hfacing, vfacing, motion, stride){
    motion == null && (motion = NONE);
    stride == null && (stride = NONE);
    return {
      key: hfacing | vfacing | motion | stride,
      UP: vfacing === UP,
      DOWN: vfacing === DOWN,
      LEFT: hfacing === LEFT,
      RIGHT: hfacing === RIGHT,
      WALKING: motion === WALKING,
      JUMPING: motion === JUMPING,
      FALLING: motion === FALLING,
      STANDING: motion === STANDING,
      HORIZONTAL: vfacing === HORIZONTAL,
      INTERACTING: motion === INTERACTING,
      STRIDE_LEFT: stride === STRIDE_LEFT,
      STRIDE_RIGHT: stride === STRIDE_RIGHT,
      STRIDE_MIDDLE: stride === STRIDE_MIDDLE
    };
  },
  generateWith: function(fn){
    var m, h, v, s, ss;
    return std.mash((function(){
      var i$, ref$, len$, j$, ref1$, len1$, k$, ref2$, len2$, l$, ref3$, len3$, results$ = [];
      for (i$ = 0, len$ = (ref$ = motions).length; i$ < len$; ++i$) {
        m = ref$[i$];
        for (j$ = 0, len1$ = (ref1$ = hfacings).length; j$ < len1$; ++j$) {
          h = ref1$[j$];
          for (k$ = 0, len2$ = (ref2$ = vfacings).length; k$ < len2$; ++k$) {
            v = ref2$[k$];
            for (l$ = 0, len3$ = (ref3$ = strides).length; l$ < len3$; ++l$) {
              s = ref3$[l$];
              ss = SpriteState.make(h, v, m, s);
              results$.push([ss.key, fn(ss)]);
            }
          }
        }
      }
      return results$;
    }()));
  }
};
},{"./units":44,"std":42}],41:[function(require,module,exports){
var std, SpriteSource, ImmobileSingleLoopParticle, kStarSrc, StarParticle, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
SpriteSource = require('./rectangle').SpriteSource;
ImmobileSingleLoopParticle = require('./immobile-single-loop-particle').ImmobileSingleLoopParticle;
kStarSrc = new SpriteSource(0, 3);
out$.StarParticle = StarParticle = (function(superclass){
  var prototype = extend$((import$(StarParticle, superclass).displayName = 'StarParticle', StarParticle), superclass).prototype, constructor = StarParticle;
  function StarParticle(graphics, x, y){
    StarParticle.superclass.call(this, graphics, x, y, 'Caret', kStarSrc, 18, 4);
  }
  return StarParticle;
}(ImmobileSingleLoopParticle));
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{"./immobile-single-loop-particle":21,"./rectangle":30,"std":42}],42:[function(require,module,exports){
var ref$, id, map, filter, reject, any, div, log, info, objMap, mash, flip, delay, round, floor, abs, max, min, sin, cos, pi, tau, rand, out$ = typeof exports != 'undefined' && exports || this;
ref$ = require('prelude-ls'), id = ref$.id, map = ref$.map, filter = ref$.filter, reject = ref$.reject, any = ref$.any, div = ref$.div;
out$.log = log = function(){
  console.log.apply(console, arguments);
  return arguments[0];
};
out$.info = info = function(){
  console.info.apply(console, arguments);
  return arguments[0];
};
out$.objMap = objMap = curry$(function(λ, o){
  var k, v, results$ = [];
  for (k in o) {
    v = o[k];
    results$.push(λ(k, v));
  }
  return results$;
});
out$.mash = mash = function(it){
  var i$, len$, ref$, k, v, results$ = {};
  for (i$ = 0, len$ = it.length; i$ < len$; ++i$) {
    ref$ = it[i$], k = ref$[0], v = ref$[1];
    results$[k] = v;
  }
  return results$;
};
out$.flip = flip = function(λ){
  return curry$(function(a, b){
    return λ(b, a);
  });
};
out$.delay = delay = flip(setTimeout);
out$.round = round = Math.round;
out$.floor = floor = Math.floor;
out$.abs = abs = Math.abs;
out$.max = max = Math.max;
out$.min = min = Math.min;
out$.sin = sin = Math.sin;
out$.cos = cos = Math.cos;
out$.pi = pi = Math.PI;
out$.tau = tau = Math.PI * 2;
out$.rand = rand = function(min, max){
  return min + Math.random() * (max - min);
};
ref$ = out$;
ref$.id = id;
ref$.any = any;
ref$.map = map;
ref$.filter = filter;
ref$.reject = reject;
ref$.div = div;
ref$['enum'] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20];
ref$.bitmask = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096];
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{"prelude-ls":7}],43:[function(require,module,exports){
var std, units, Timer, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
out$.Timer = Timer = (function(){
  Timer.displayName = 'Timer';
  var allTimers, prototype = Timer.prototype, constructor = Timer;
  allTimers = [];
  function Timer(expirationTime, startActive){
    this.expirationTime = expirationTime;
    startActive == null && (startActive = false);
    this.currentTime = startActive
      ? 0
      : this.expirationTime;
    allTimers.push(this);
  }
  prototype.update = function(elapsedTime){
    return this.currentTime += elapsedTime;
  };
  prototype.reset = function(){
    return this.currentTime = 0;
  };
  Object.defineProperty(prototype, 'isActive', {
    get: function(){
      return this.currentTime < this.expirationTime;
    },
    configurable: true,
    enumerable: true
  });
  Object.defineProperty(prototype, 'isExpired', {
    get: function(){
      return !this.isActive;
    },
    configurable: true,
    enumerable: true
  });
  prototype.active = function(){
    return this.currentTime < this.expirationTime;
  };
  prototype.expired = function(){
    return !(this.currentTime < this.expirationTime);
  };
  Timer.updateAll = function(elapsedTime){
    return allTimers.map(function(it){
      return it.update(elapsedTime);
    });
  };
  return Timer;
}());
},{"./units":44,"std":42}],44:[function(require,module,exports){
var std, config, kPi, kGameUnitsPerTile, kPixelScaleFactor, Game, Pixel, Tile, Degrees, GunLevel, FPS, MS, Velocity, Acceleration, HP, gameToPx, gameToTile, tileToGame, tileToPx, pxToGame, pxToTile, degToRad, kOneTile, kHalfTile, kTilePx, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
config = require('./config');
kPi = Math.PI;
kGameUnitsPerTile = 32;
kPixelScaleFactor = kGameUnitsPerTile / config.kGraphicsQuality;
out$.Game = Game = std.id;
out$.Pixel = Pixel = std.floor;
out$.Tile = Tile = function(){
  return std.abs(std.floor.apply(this, arguments));
};
out$.Degrees = Degrees = std.id;
out$.GunLevel = GunLevel = std.floor;
out$.FPS = FPS = std.id;
out$.MS = MS = std.id;
out$.Velocity = Velocity = std.id;
out$.Acceleration = Acceleration = std.id;
out$.HP = HP = std.floor;
out$.gameToPx = gameToPx = function(){
  return Pixel((function(it){
    return it / kPixelScaleFactor;
  }).apply(this, arguments));
};
out$.gameToTile = gameToTile = function(){
  return Tile((function(it){
    return it / kGameUnitsPerTile;
  }).apply(this, arguments));
};
out$.tileToGame = tileToGame = (function(it){
  return it * kGameUnitsPerTile;
});
out$.tileToPx = tileToPx = function(){
  return gameToPx(tileToGame.apply(this, arguments));
};
out$.pxToGame = pxToGame = (function(it){
  return it * kPixelScaleFactor;
});
out$.pxToTile = pxToTile = function(){
  return (function(it){
    return it / kGameUnitsPerTile;
  })(pxToGame.apply(this, arguments));
};
out$.degToRad = degToRad = (function(it){
  return it * kPi / 180;
});
out$.kOneTile = kOneTile = tileToGame(1);
out$.kHalfTile = kHalfTile = tileToGame(0.5);
out$.kTilePx = kTilePx = tileToPx(1);
},{"./config":10,"std":42}],45:[function(require,module,exports){
var std, units, SpriteSource, ImmobileSingleLoopParticle, kWallSrc, WallParticle, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
SpriteSource = require('./rectangle').SpriteSource;
ImmobileSingleLoopParticle = require('./immobile-single-loop-particle').ImmobileSingleLoopParticle;
kWallSrc = new SpriteSource(11, 0);
out$.WallParticle = WallParticle = (function(superclass){
  var prototype = extend$((import$(WallParticle, superclass).displayName = 'WallParticle', WallParticle), superclass).prototype, constructor = WallParticle;
  function WallParticle(graphics, x, y){
    WallParticle.superclass.call(this, graphics, x, y, 'Caret', kWallSrc, 18, 4);
  }
  return WallParticle;
}(ImmobileSingleLoopParticle));
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{"./immobile-single-loop-particle":21,"./rectangle":30,"./units":44,"std":42}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi4vc3JjL2luZGV4LmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9ub2RlX21vZHVsZXMvcHJlbHVkZS1scy9saWIvRnVuYy5qcyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvbm9kZV9tb2R1bGVzL3ByZWx1ZGUtbHMvbGliL0xpc3QuanMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L25vZGVfbW9kdWxlcy9wcmVsdWRlLWxzL2xpYi9OdW0uanMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L25vZGVfbW9kdWxlcy9wcmVsdWRlLWxzL2xpYi9PYmouanMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L25vZGVfbW9kdWxlcy9wcmVsdWRlLWxzL2xpYi9TdHIuanMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L25vZGVfbW9kdWxlcy9wcmVsdWRlLWxzL2xpYi9pbmRleC5qcyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL2FybXMubHMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L3NyYy9iYWNrZHJvcC5scyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL2NvbmZpZy5scyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL2RhbWFnZS10ZXh0LmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9zcmMvZGFtYWdlLXRleHRzLmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9zcmMvZGFtYWdlYWJsZS5scyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL2RlYXRoLWNsb3VkLXBhcnRpY2xlLmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9zcmMvZmlyc3QtY2F2ZS1iYXQubHMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L3NyYy9nYW1lLmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9zcmMvZ3JhcGhpY3MubHMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L3NyYy9ndW4teHAtaHVkLmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9zcmMvaGVhZC1idW1wLXBhcnRpY2xlLmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9zcmMvaGVhbHRoLmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9zcmMvaW1tb2JpbGUtc2luZ2xlLWxvb3AtcGFydGljbGUubHMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L3NyYy9pbnB1dC5scyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL21hcC5scyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL3BhcnRpY2xlLXN5c3RlbS5scyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL3BhcnRpY2xlLmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9zcmMvcGxheWVyLmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9zcmMvcG9sYXIubHMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L3NyYy9wcm9qZWN0aWxlLmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9zcmMvcmVhZG91dC5scyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL3JlY3RhbmdsZS5scyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL3NkbC9kZWxheS5scyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL3NkbC9ldmVudC1xdWV1ZS5scyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL3NkbC9pbmRleC5scyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL3NkbC9rZXlib2FyZC5scyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL3NkbC9yZWN0LmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9zcmMvc2RsL3NjcmVlbi5scyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL3NkbC9zdXJmYWNlLmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9zcmMvc2RsL3RpbWVyLmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9zcmMvc3ByaXRlLmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9zcmMvc3ByaXRlc3RhdGUubHMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L3NyYy9zdGFyLXBhcnRpY2xlLmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9zcmMvc3RkL2luZGV4LmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9zcmMvdGltZXIubHMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L3NyYy91bml0cy5scyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL3dhbGwtcGFydGljbGUubHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2paQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJ2YXIgcmVhZG91dCwgR2FtZTtcbnJlYWRvdXQgPSByZXF1aXJlKCcuL3JlYWRvdXQnKTtcbkdhbWUgPSByZXF1aXJlKCcuL2dhbWUnKTtcbnJlYWRvdXQuaW5zdGFsbCgpO1xuR2FtZS5zdGFydCgpOyIsIi8vIEdlbmVyYXRlZCBieSBMaXZlU2NyaXB0IDEuMi4wXG52YXIgYXBwbHksIGN1cnJ5LCBmbGlwLCBmaXgsIG92ZXI7XG5hcHBseSA9IGN1cnJ5JChmdW5jdGlvbihmLCBsaXN0KXtcbiAgcmV0dXJuIGYuYXBwbHkobnVsbCwgbGlzdCk7XG59KTtcbmN1cnJ5ID0gZnVuY3Rpb24oZil7XG4gIHJldHVybiBjdXJyeSQoZik7XG59O1xuZmxpcCA9IGN1cnJ5JChmdW5jdGlvbihmLCB4LCB5KXtcbiAgcmV0dXJuIGYoeSwgeCk7XG59KTtcbmZpeCA9IGZ1bmN0aW9uKGYpe1xuICByZXR1cm4gZnVuY3Rpb24oZyl7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZihnKGcpKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0oZnVuY3Rpb24oZyl7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZihnKGcpKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0pO1xufTtcbm92ZXIgPSBjdXJyeSQoZnVuY3Rpb24oZiwgZywgeCwgeSl7XG4gIHJldHVybiBmKGcoeCksIGcoeSkpO1xufSk7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3Vycnk6IGN1cnJ5LFxuICBmbGlwOiBmbGlwLFxuICBmaXg6IGZpeCxcbiAgYXBwbHk6IGFwcGx5LFxuICBvdmVyOiBvdmVyXG59O1xuZnVuY3Rpb24gY3VycnkkKGYsIGJvdW5kKXtcbiAgdmFyIGNvbnRleHQsXG4gIF9jdXJyeSA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICByZXR1cm4gZi5sZW5ndGggPiAxID8gZnVuY3Rpb24oKXtcbiAgICAgIHZhciBwYXJhbXMgPSBhcmdzID8gYXJncy5jb25jYXQoKSA6IFtdO1xuICAgICAgY29udGV4dCA9IGJvdW5kID8gY29udGV4dCB8fCB0aGlzIDogdGhpcztcbiAgICAgIHJldHVybiBwYXJhbXMucHVzaC5hcHBseShwYXJhbXMsIGFyZ3VtZW50cykgPFxuICAgICAgICAgIGYubGVuZ3RoICYmIGFyZ3VtZW50cy5sZW5ndGggP1xuICAgICAgICBfY3VycnkuY2FsbChjb250ZXh0LCBwYXJhbXMpIDogZi5hcHBseShjb250ZXh0LCBwYXJhbXMpO1xuICAgIH0gOiBmO1xuICB9O1xuICByZXR1cm4gX2N1cnJ5KCk7XG59IiwiLy8gR2VuZXJhdGVkIGJ5IExpdmVTY3JpcHQgMS4yLjBcbnZhciBlYWNoLCBtYXAsIGNvbXBhY3QsIGZpbHRlciwgcmVqZWN0LCBwYXJ0aXRpb24sIGZpbmQsIGhlYWQsIGZpcnN0LCB0YWlsLCBsYXN0LCBpbml0aWFsLCBlbXB0eSwgcmV2ZXJzZSwgdW5pcXVlLCB1bmlxdWVCeSwgZm9sZCwgZm9sZGwsIGZvbGQxLCBmb2xkbDEsIGZvbGRyLCBmb2xkcjEsIHVuZm9sZHIsIGNvbmNhdCwgY29uY2F0TWFwLCBmbGF0dGVuLCBkaWZmZXJlbmNlLCBpbnRlcnNlY3Rpb24sIHVuaW9uLCBjb3VudEJ5LCBncm91cEJ5LCBhbmRMaXN0LCBvckxpc3QsIGFueSwgYWxsLCBzb3J0LCBzb3J0V2l0aCwgc29ydEJ5LCBzdW0sIHByb2R1Y3QsIG1lYW4sIGF2ZXJhZ2UsIG1heGltdW0sIG1pbmltdW0sIG1heGltdW1CeSwgbWluaW11bUJ5LCBzY2FuLCBzY2FubCwgc2NhbjEsIHNjYW5sMSwgc2NhbnIsIHNjYW5yMSwgc2xpY2UsIHRha2UsIGRyb3AsIHNwbGl0QXQsIHRha2VXaGlsZSwgZHJvcFdoaWxlLCBzcGFuLCBicmVha0xpc3QsIHppcCwgemlwV2l0aCwgemlwQWxsLCB6aXBBbGxXaXRoLCBhdCwgZWxlbUluZGV4LCBlbGVtSW5kaWNlcywgZmluZEluZGV4LCBmaW5kSW5kaWNlcywgdG9TdHJpbmckID0ge30udG9TdHJpbmcsIHNsaWNlJCA9IFtdLnNsaWNlO1xuZWFjaCA9IGN1cnJ5JChmdW5jdGlvbihmLCB4cyl7XG4gIHZhciBpJCwgbGVuJCwgeDtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSB4cy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHggPSB4c1tpJF07XG4gICAgZih4KTtcbiAgfVxuICByZXR1cm4geHM7XG59KTtcbm1hcCA9IGN1cnJ5JChmdW5jdGlvbihmLCB4cyl7XG4gIHZhciBpJCwgbGVuJCwgeCwgcmVzdWx0cyQgPSBbXTtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSB4cy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHggPSB4c1tpJF07XG4gICAgcmVzdWx0cyQucHVzaChmKHgpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cyQ7XG59KTtcbmNvbXBhY3QgPSBmdW5jdGlvbih4cyl7XG4gIHZhciBpJCwgbGVuJCwgeCwgcmVzdWx0cyQgPSBbXTtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSB4cy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHggPSB4c1tpJF07XG4gICAgaWYgKHgpIHtcbiAgICAgIHJlc3VsdHMkLnB1c2goeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRzJDtcbn07XG5maWx0ZXIgPSBjdXJyeSQoZnVuY3Rpb24oZiwgeHMpe1xuICB2YXIgaSQsIGxlbiQsIHgsIHJlc3VsdHMkID0gW107XG4gIGZvciAoaSQgPSAwLCBsZW4kID0geHMubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4ID0geHNbaSRdO1xuICAgIGlmIChmKHgpKSB7XG4gICAgICByZXN1bHRzJC5wdXNoKHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0cyQ7XG59KTtcbnJlamVjdCA9IGN1cnJ5JChmdW5jdGlvbihmLCB4cyl7XG4gIHZhciBpJCwgbGVuJCwgeCwgcmVzdWx0cyQgPSBbXTtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSB4cy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHggPSB4c1tpJF07XG4gICAgaWYgKCFmKHgpKSB7XG4gICAgICByZXN1bHRzJC5wdXNoKHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0cyQ7XG59KTtcbnBhcnRpdGlvbiA9IGN1cnJ5JChmdW5jdGlvbihmLCB4cyl7XG4gIHZhciBwYXNzZWQsIGZhaWxlZCwgaSQsIGxlbiQsIHg7XG4gIHBhc3NlZCA9IFtdO1xuICBmYWlsZWQgPSBbXTtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSB4cy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHggPSB4c1tpJF07XG4gICAgKGYoeCkgPyBwYXNzZWQgOiBmYWlsZWQpLnB1c2goeCk7XG4gIH1cbiAgcmV0dXJuIFtwYXNzZWQsIGZhaWxlZF07XG59KTtcbmZpbmQgPSBjdXJyeSQoZnVuY3Rpb24oZiwgeHMpe1xuICB2YXIgaSQsIGxlbiQsIHg7XG4gIGZvciAoaSQgPSAwLCBsZW4kID0geHMubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4ID0geHNbaSRdO1xuICAgIGlmIChmKHgpKSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gIH1cbn0pO1xuaGVhZCA9IGZpcnN0ID0gZnVuY3Rpb24oeHMpe1xuICByZXR1cm4geHNbMF07XG59O1xudGFpbCA9IGZ1bmN0aW9uKHhzKXtcbiAgaWYgKCF4cy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIHhzLnNsaWNlKDEpO1xufTtcbmxhc3QgPSBmdW5jdGlvbih4cyl7XG4gIHJldHVybiB4c1t4cy5sZW5ndGggLSAxXTtcbn07XG5pbml0aWFsID0gZnVuY3Rpb24oeHMpe1xuICBpZiAoIXhzLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4geHMuc2xpY2UoMCwgLTEpO1xufTtcbmVtcHR5ID0gZnVuY3Rpb24oeHMpe1xuICByZXR1cm4gIXhzLmxlbmd0aDtcbn07XG5yZXZlcnNlID0gZnVuY3Rpb24oeHMpe1xuICByZXR1cm4geHMuY29uY2F0KCkucmV2ZXJzZSgpO1xufTtcbnVuaXF1ZSA9IGZ1bmN0aW9uKHhzKXtcbiAgdmFyIHJlc3VsdCwgaSQsIGxlbiQsIHg7XG4gIHJlc3VsdCA9IFtdO1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IHhzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeCA9IHhzW2kkXTtcbiAgICBpZiAoIWluJCh4LCByZXN1bHQpKSB7XG4gICAgICByZXN1bHQucHVzaCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG51bmlxdWVCeSA9IGN1cnJ5JChmdW5jdGlvbihmLCB4cyl7XG4gIHZhciBzZWVuLCBpJCwgbGVuJCwgeCwgdmFsLCByZXN1bHRzJCA9IFtdO1xuICBzZWVuID0gW107XG4gIGZvciAoaSQgPSAwLCBsZW4kID0geHMubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4ID0geHNbaSRdO1xuICAgIHZhbCA9IGYoeCk7XG4gICAgaWYgKGluJCh2YWwsIHNlZW4pKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgc2Vlbi5wdXNoKHZhbCk7XG4gICAgcmVzdWx0cyQucHVzaCh4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cyQ7XG59KTtcbmZvbGQgPSBmb2xkbCA9IGN1cnJ5JChmdW5jdGlvbihmLCBtZW1vLCB4cyl7XG4gIHZhciBpJCwgbGVuJCwgeDtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSB4cy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHggPSB4c1tpJF07XG4gICAgbWVtbyA9IGYobWVtbywgeCk7XG4gIH1cbiAgcmV0dXJuIG1lbW87XG59KTtcbmZvbGQxID0gZm9sZGwxID0gY3VycnkkKGZ1bmN0aW9uKGYsIHhzKXtcbiAgcmV0dXJuIGZvbGQoZiwgeHNbMF0sIHhzLnNsaWNlKDEpKTtcbn0pO1xuZm9sZHIgPSBjdXJyeSQoZnVuY3Rpb24oZiwgbWVtbywgeHMpe1xuICB2YXIgaSQsIHg7XG4gIGZvciAoaSQgPSB4cy5sZW5ndGggLSAxOyBpJCA+PSAwOyAtLWkkKSB7XG4gICAgeCA9IHhzW2kkXTtcbiAgICBtZW1vID0gZih4LCBtZW1vKTtcbiAgfVxuICByZXR1cm4gbWVtbztcbn0pO1xuZm9sZHIxID0gY3VycnkkKGZ1bmN0aW9uKGYsIHhzKXtcbiAgcmV0dXJuIGZvbGRyKGYsIHhzW3hzLmxlbmd0aCAtIDFdLCB4cy5zbGljZSgwLCAtMSkpO1xufSk7XG51bmZvbGRyID0gY3VycnkkKGZ1bmN0aW9uKGYsIGIpe1xuICB2YXIgcmVzdWx0LCB4LCB0aGF0O1xuICByZXN1bHQgPSBbXTtcbiAgeCA9IGI7XG4gIHdoaWxlICgodGhhdCA9IGYoeCkpICE9IG51bGwpIHtcbiAgICByZXN1bHQucHVzaCh0aGF0WzBdKTtcbiAgICB4ID0gdGhhdFsxXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5jb25jYXQgPSBmdW5jdGlvbih4c3Mpe1xuICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCB4c3MpO1xufTtcbmNvbmNhdE1hcCA9IGN1cnJ5JChmdW5jdGlvbihmLCB4cyl7XG4gIHZhciB4O1xuICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCAoZnVuY3Rpb24oKXtcbiAgICB2YXIgaSQsIHJlZiQsIGxlbiQsIHJlc3VsdHMkID0gW107XG4gICAgZm9yIChpJCA9IDAsIGxlbiQgPSAocmVmJCA9IHhzKS5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgICAgeCA9IHJlZiRbaSRdO1xuICAgICAgcmVzdWx0cyQucHVzaChmKHgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHMkO1xuICB9KCkpKTtcbn0pO1xuZmxhdHRlbiA9IGZ1bmN0aW9uKHhzKXtcbiAgdmFyIHg7XG4gIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIChmdW5jdGlvbigpe1xuICAgIHZhciBpJCwgcmVmJCwgbGVuJCwgcmVzdWx0cyQgPSBbXTtcbiAgICBmb3IgKGkkID0gMCwgbGVuJCA9IChyZWYkID0geHMpLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgICB4ID0gcmVmJFtpJF07XG4gICAgICBpZiAodG9TdHJpbmckLmNhbGwoeCkuc2xpY2UoOCwgLTEpID09PSAnQXJyYXknKSB7XG4gICAgICAgIHJlc3VsdHMkLnB1c2goZmxhdHRlbih4KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRzJC5wdXNoKHgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cyQ7XG4gIH0oKSkpO1xufTtcbmRpZmZlcmVuY2UgPSBmdW5jdGlvbih4cyl7XG4gIHZhciB5c3MsIHJlc3VsdHMsIGkkLCBsZW4kLCB4LCBqJCwgbGVuMSQsIHlzO1xuICB5c3MgPSBzbGljZSQuY2FsbChhcmd1bWVudHMsIDEpO1xuICByZXN1bHRzID0gW107XG4gIG91dGVyOiBmb3IgKGkkID0gMCwgbGVuJCA9IHhzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeCA9IHhzW2kkXTtcbiAgICBmb3IgKGokID0gMCwgbGVuMSQgPSB5c3MubGVuZ3RoOyBqJCA8IGxlbjEkOyArK2okKSB7XG4gICAgICB5cyA9IHlzc1tqJF07XG4gICAgICBpZiAoaW4kKHgsIHlzKSkge1xuICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0cy5wdXNoKHgpO1xuICB9XG4gIHJldHVybiByZXN1bHRzO1xufTtcbmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKHhzKXtcbiAgdmFyIHlzcywgcmVzdWx0cywgaSQsIGxlbiQsIHgsIGokLCBsZW4xJCwgeXM7XG4gIHlzcyA9IHNsaWNlJC5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHJlc3VsdHMgPSBbXTtcbiAgb3V0ZXI6IGZvciAoaSQgPSAwLCBsZW4kID0geHMubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4ID0geHNbaSRdO1xuICAgIGZvciAoaiQgPSAwLCBsZW4xJCA9IHlzcy5sZW5ndGg7IGokIDwgbGVuMSQ7ICsraiQpIHtcbiAgICAgIHlzID0geXNzW2okXTtcbiAgICAgIGlmICghaW4kKHgsIHlzKSkge1xuICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0cy5wdXNoKHgpO1xuICB9XG4gIHJldHVybiByZXN1bHRzO1xufTtcbnVuaW9uID0gZnVuY3Rpb24oKXtcbiAgdmFyIHhzcywgcmVzdWx0cywgaSQsIGxlbiQsIHhzLCBqJCwgbGVuMSQsIHg7XG4gIHhzcyA9IHNsaWNlJC5jYWxsKGFyZ3VtZW50cyk7XG4gIHJlc3VsdHMgPSBbXTtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSB4c3MubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4cyA9IHhzc1tpJF07XG4gICAgZm9yIChqJCA9IDAsIGxlbjEkID0geHMubGVuZ3RoOyBqJCA8IGxlbjEkOyArK2okKSB7XG4gICAgICB4ID0geHNbaiRdO1xuICAgICAgaWYgKCFpbiQoeCwgcmVzdWx0cykpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn07XG5jb3VudEJ5ID0gY3VycnkkKGZ1bmN0aW9uKGYsIHhzKXtcbiAgdmFyIHJlc3VsdHMsIGkkLCBsZW4kLCB4LCBrZXk7XG4gIHJlc3VsdHMgPSB7fTtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSB4cy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHggPSB4c1tpJF07XG4gICAga2V5ID0gZih4KTtcbiAgICBpZiAoa2V5IGluIHJlc3VsdHMpIHtcbiAgICAgIHJlc3VsdHNba2V5XSArPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRzW2tleV0gPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn0pO1xuZ3JvdXBCeSA9IGN1cnJ5JChmdW5jdGlvbihmLCB4cyl7XG4gIHZhciByZXN1bHRzLCBpJCwgbGVuJCwgeCwga2V5O1xuICByZXN1bHRzID0ge307XG4gIGZvciAoaSQgPSAwLCBsZW4kID0geHMubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4ID0geHNbaSRdO1xuICAgIGtleSA9IGYoeCk7XG4gICAgaWYgKGtleSBpbiByZXN1bHRzKSB7XG4gICAgICByZXN1bHRzW2tleV0ucHVzaCh4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0c1trZXldID0gW3hdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn0pO1xuYW5kTGlzdCA9IGZ1bmN0aW9uKHhzKXtcbiAgdmFyIGkkLCBsZW4kLCB4O1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IHhzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeCA9IHhzW2kkXTtcbiAgICBpZiAoIXgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xub3JMaXN0ID0gZnVuY3Rpb24oeHMpe1xuICB2YXIgaSQsIGxlbiQsIHg7XG4gIGZvciAoaSQgPSAwLCBsZW4kID0geHMubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4ID0geHNbaSRdO1xuICAgIGlmICh4KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbmFueSA9IGN1cnJ5JChmdW5jdGlvbihmLCB4cyl7XG4gIHZhciBpJCwgbGVuJCwgeDtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSB4cy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHggPSB4c1tpJF07XG4gICAgaWYgKGYoeCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59KTtcbmFsbCA9IGN1cnJ5JChmdW5jdGlvbihmLCB4cyl7XG4gIHZhciBpJCwgbGVuJCwgeDtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSB4cy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHggPSB4c1tpJF07XG4gICAgaWYgKCFmKHgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufSk7XG5zb3J0ID0gZnVuY3Rpb24oeHMpe1xuICByZXR1cm4geHMuY29uY2F0KCkuc29ydChmdW5jdGlvbih4LCB5KXtcbiAgICBpZiAoeCA+IHkpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoeCA8IHkpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9KTtcbn07XG5zb3J0V2l0aCA9IGN1cnJ5JChmdW5jdGlvbihmLCB4cyl7XG4gIHJldHVybiB4cy5jb25jYXQoKS5zb3J0KGYpO1xufSk7XG5zb3J0QnkgPSBjdXJyeSQoZnVuY3Rpb24oZiwgeHMpe1xuICByZXR1cm4geHMuY29uY2F0KCkuc29ydChmdW5jdGlvbih4LCB5KXtcbiAgICBpZiAoZih4KSA+IGYoeSkpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZih4KSA8IGYoeSkpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9KTtcbn0pO1xuc3VtID0gZnVuY3Rpb24oeHMpe1xuICB2YXIgcmVzdWx0LCBpJCwgbGVuJCwgeDtcbiAgcmVzdWx0ID0gMDtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSB4cy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHggPSB4c1tpJF07XG4gICAgcmVzdWx0ICs9IHg7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5wcm9kdWN0ID0gZnVuY3Rpb24oeHMpe1xuICB2YXIgcmVzdWx0LCBpJCwgbGVuJCwgeDtcbiAgcmVzdWx0ID0gMTtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSB4cy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHggPSB4c1tpJF07XG4gICAgcmVzdWx0ICo9IHg7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5tZWFuID0gYXZlcmFnZSA9IGZ1bmN0aW9uKHhzKXtcbiAgdmFyIHN1bSwgaSQsIGxlbiQsIHg7XG4gIHN1bSA9IDA7XG4gIGZvciAoaSQgPSAwLCBsZW4kID0geHMubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4ID0geHNbaSRdO1xuICAgIHN1bSArPSB4O1xuICB9XG4gIHJldHVybiBzdW0gLyB4cy5sZW5ndGg7XG59O1xubWF4aW11bSA9IGZ1bmN0aW9uKHhzKXtcbiAgdmFyIG1heCwgaSQsIHJlZiQsIGxlbiQsIHg7XG4gIG1heCA9IHhzWzBdO1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IChyZWYkID0geHMuc2xpY2UoMSkpLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeCA9IHJlZiRbaSRdO1xuICAgIGlmICh4ID4gbWF4KSB7XG4gICAgICBtYXggPSB4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWF4O1xufTtcbm1pbmltdW0gPSBmdW5jdGlvbih4cyl7XG4gIHZhciBtaW4sIGkkLCByZWYkLCBsZW4kLCB4O1xuICBtaW4gPSB4c1swXTtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSAocmVmJCA9IHhzLnNsaWNlKDEpKS5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHggPSByZWYkW2kkXTtcbiAgICBpZiAoeCA8IG1pbikge1xuICAgICAgbWluID0geDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1pbjtcbn07XG5tYXhpbXVtQnkgPSBjdXJyeSQoZnVuY3Rpb24oZiwgeHMpe1xuICB2YXIgbWF4LCBpJCwgcmVmJCwgbGVuJCwgeDtcbiAgbWF4ID0geHNbMF07XG4gIGZvciAoaSQgPSAwLCBsZW4kID0gKHJlZiQgPSB4cy5zbGljZSgxKSkubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4ID0gcmVmJFtpJF07XG4gICAgaWYgKGYoeCkgPiBmKG1heCkpIHtcbiAgICAgIG1heCA9IHg7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXg7XG59KTtcbm1pbmltdW1CeSA9IGN1cnJ5JChmdW5jdGlvbihmLCB4cyl7XG4gIHZhciBtaW4sIGkkLCByZWYkLCBsZW4kLCB4O1xuICBtaW4gPSB4c1swXTtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSAocmVmJCA9IHhzLnNsaWNlKDEpKS5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHggPSByZWYkW2kkXTtcbiAgICBpZiAoZih4KSA8IGYobWluKSkge1xuICAgICAgbWluID0geDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1pbjtcbn0pO1xuc2NhbiA9IHNjYW5sID0gY3VycnkkKGZ1bmN0aW9uKGYsIG1lbW8sIHhzKXtcbiAgdmFyIGxhc3QsIHg7XG4gIGxhc3QgPSBtZW1vO1xuICByZXR1cm4gW21lbW9dLmNvbmNhdCgoZnVuY3Rpb24oKXtcbiAgICB2YXIgaSQsIHJlZiQsIGxlbiQsIHJlc3VsdHMkID0gW107XG4gICAgZm9yIChpJCA9IDAsIGxlbiQgPSAocmVmJCA9IHhzKS5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgICAgeCA9IHJlZiRbaSRdO1xuICAgICAgcmVzdWx0cyQucHVzaChsYXN0ID0gZihsYXN0LCB4KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzJDtcbiAgfSgpKSk7XG59KTtcbnNjYW4xID0gc2NhbmwxID0gY3VycnkkKGZ1bmN0aW9uKGYsIHhzKXtcbiAgaWYgKCF4cy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIHNjYW4oZiwgeHNbMF0sIHhzLnNsaWNlKDEpKTtcbn0pO1xuc2NhbnIgPSBjdXJyeSQoZnVuY3Rpb24oZiwgbWVtbywgeHMpe1xuICB4cyA9IHhzLmNvbmNhdCgpLnJldmVyc2UoKTtcbiAgcmV0dXJuIHNjYW4oZiwgbWVtbywgeHMpLnJldmVyc2UoKTtcbn0pO1xuc2NhbnIxID0gY3VycnkkKGZ1bmN0aW9uKGYsIHhzKXtcbiAgaWYgKCF4cy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgeHMgPSB4cy5jb25jYXQoKS5yZXZlcnNlKCk7XG4gIHJldHVybiBzY2FuKGYsIHhzWzBdLCB4cy5zbGljZSgxKSkucmV2ZXJzZSgpO1xufSk7XG5zbGljZSA9IGN1cnJ5JChmdW5jdGlvbih4LCB5LCB4cyl7XG4gIHJldHVybiB4cy5zbGljZSh4LCB5KTtcbn0pO1xudGFrZSA9IGN1cnJ5JChmdW5jdGlvbihuLCB4cyl7XG4gIGlmIChuIDw9IDApIHtcbiAgICByZXR1cm4geHMuc2xpY2UoMCwgMCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHhzLnNsaWNlKDAsIG4pO1xuICB9XG59KTtcbmRyb3AgPSBjdXJyeSQoZnVuY3Rpb24obiwgeHMpe1xuICBpZiAobiA8PSAwKSB7XG4gICAgcmV0dXJuIHhzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB4cy5zbGljZShuKTtcbiAgfVxufSk7XG5zcGxpdEF0ID0gY3VycnkkKGZ1bmN0aW9uKG4sIHhzKXtcbiAgcmV0dXJuIFt0YWtlKG4sIHhzKSwgZHJvcChuLCB4cyldO1xufSk7XG50YWtlV2hpbGUgPSBjdXJyeSQoZnVuY3Rpb24ocCwgeHMpe1xuICB2YXIgbGVuLCBpO1xuICBsZW4gPSB4cy5sZW5ndGg7XG4gIGlmICghbGVuKSB7XG4gICAgcmV0dXJuIHhzO1xuICB9XG4gIGkgPSAwO1xuICB3aGlsZSAoaSA8IGxlbiAmJiBwKHhzW2ldKSkge1xuICAgIGkgKz0gMTtcbiAgfVxuICByZXR1cm4geHMuc2xpY2UoMCwgaSk7XG59KTtcbmRyb3BXaGlsZSA9IGN1cnJ5JChmdW5jdGlvbihwLCB4cyl7XG4gIHZhciBsZW4sIGk7XG4gIGxlbiA9IHhzLmxlbmd0aDtcbiAgaWYgKCFsZW4pIHtcbiAgICByZXR1cm4geHM7XG4gIH1cbiAgaSA9IDA7XG4gIHdoaWxlIChpIDwgbGVuICYmIHAoeHNbaV0pKSB7XG4gICAgaSArPSAxO1xuICB9XG4gIHJldHVybiB4cy5zbGljZShpKTtcbn0pO1xuc3BhbiA9IGN1cnJ5JChmdW5jdGlvbihwLCB4cyl7XG4gIHJldHVybiBbdGFrZVdoaWxlKHAsIHhzKSwgZHJvcFdoaWxlKHAsIHhzKV07XG59KTtcbmJyZWFrTGlzdCA9IGN1cnJ5JChmdW5jdGlvbihwLCB4cyl7XG4gIHJldHVybiBzcGFuKGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIG5vdCQocC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfSwgeHMpO1xufSk7XG56aXAgPSBjdXJyeSQoZnVuY3Rpb24oeHMsIHlzKXtcbiAgdmFyIHJlc3VsdCwgbGVuLCBpJCwgbGVuJCwgaSwgeDtcbiAgcmVzdWx0ID0gW107XG4gIGxlbiA9IHlzLmxlbmd0aDtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSB4cy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIGkgPSBpJDtcbiAgICB4ID0geHNbaSRdO1xuICAgIGlmIChpID09PSBsZW4pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXN1bHQucHVzaChbeCwgeXNbaV1dKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG56aXBXaXRoID0gY3VycnkkKGZ1bmN0aW9uKGYsIHhzLCB5cyl7XG4gIHZhciByZXN1bHQsIGxlbiwgaSQsIGxlbiQsIGksIHg7XG4gIHJlc3VsdCA9IFtdO1xuICBsZW4gPSB5cy5sZW5ndGg7XG4gIGZvciAoaSQgPSAwLCBsZW4kID0geHMubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICBpID0gaSQ7XG4gICAgeCA9IHhzW2kkXTtcbiAgICBpZiAoaSA9PT0gbGVuKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goZih4LCB5c1tpXSkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcbnppcEFsbCA9IGZ1bmN0aW9uKCl7XG4gIHZhciB4c3MsIG1pbkxlbmd0aCwgaSQsIGxlbiQsIHhzLCByZWYkLCBpLCBscmVzdWx0JCwgaiQsIHJlc3VsdHMkID0gW107XG4gIHhzcyA9IHNsaWNlJC5jYWxsKGFyZ3VtZW50cyk7XG4gIG1pbkxlbmd0aCA9IDllOTtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSB4c3MubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4cyA9IHhzc1tpJF07XG4gICAgbWluTGVuZ3RoIDw9IChyZWYkID0geHMubGVuZ3RoKSB8fCAobWluTGVuZ3RoID0gcmVmJCk7XG4gIH1cbiAgZm9yIChpJCA9IDA7IGkkIDwgbWluTGVuZ3RoOyArK2kkKSB7XG4gICAgaSA9IGkkO1xuICAgIGxyZXN1bHQkID0gW107XG4gICAgZm9yIChqJCA9IDAsIGxlbiQgPSB4c3MubGVuZ3RoOyBqJCA8IGxlbiQ7ICsraiQpIHtcbiAgICAgIHhzID0geHNzW2okXTtcbiAgICAgIGxyZXN1bHQkLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXN1bHRzJC5wdXNoKGxyZXN1bHQkKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cyQ7XG59O1xuemlwQWxsV2l0aCA9IGZ1bmN0aW9uKGYpe1xuICB2YXIgeHNzLCBtaW5MZW5ndGgsIGkkLCBsZW4kLCB4cywgcmVmJCwgaSwgcmVzdWx0cyQgPSBbXTtcbiAgeHNzID0gc2xpY2UkLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgbWluTGVuZ3RoID0gOWU5O1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IHhzcy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHhzID0geHNzW2kkXTtcbiAgICBtaW5MZW5ndGggPD0gKHJlZiQgPSB4cy5sZW5ndGgpIHx8IChtaW5MZW5ndGggPSByZWYkKTtcbiAgfVxuICBmb3IgKGkkID0gMDsgaSQgPCBtaW5MZW5ndGg7ICsraSQpIHtcbiAgICBpID0gaSQ7XG4gICAgcmVzdWx0cyQucHVzaChmLmFwcGx5KG51bGwsIChmbiQoKSkpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cyQ7XG4gIGZ1bmN0aW9uIGZuJCgpe1xuICAgIHZhciBpJCwgcmVmJCwgbGVuJCwgcmVzdWx0cyQgPSBbXTtcbiAgICBmb3IgKGkkID0gMCwgbGVuJCA9IChyZWYkID0geHNzKS5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgICAgeHMgPSByZWYkW2kkXTtcbiAgICAgIHJlc3VsdHMkLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cyQ7XG4gIH1cbn07XG5hdCA9IGN1cnJ5JChmdW5jdGlvbihuLCB4cyl7XG4gIGlmIChuIDwgMCkge1xuICAgIHJldHVybiB4c1t4cy5sZW5ndGggKyBuXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geHNbbl07XG4gIH1cbn0pO1xuZWxlbUluZGV4ID0gY3VycnkkKGZ1bmN0aW9uKGVsLCB4cyl7XG4gIHZhciBpJCwgbGVuJCwgaSwgeDtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSB4cy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIGkgPSBpJDtcbiAgICB4ID0geHNbaSRdO1xuICAgIGlmICh4ID09PSBlbCkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG59KTtcbmVsZW1JbmRpY2VzID0gY3VycnkkKGZ1bmN0aW9uKGVsLCB4cyl7XG4gIHZhciBpJCwgbGVuJCwgaSwgeCwgcmVzdWx0cyQgPSBbXTtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSB4cy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIGkgPSBpJDtcbiAgICB4ID0geHNbaSRdO1xuICAgIGlmICh4ID09PSBlbCkge1xuICAgICAgcmVzdWx0cyQucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHMkO1xufSk7XG5maW5kSW5kZXggPSBjdXJyeSQoZnVuY3Rpb24oZiwgeHMpe1xuICB2YXIgaSQsIGxlbiQsIGksIHg7XG4gIGZvciAoaSQgPSAwLCBsZW4kID0geHMubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICBpID0gaSQ7XG4gICAgeCA9IHhzW2kkXTtcbiAgICBpZiAoZih4KSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG59KTtcbmZpbmRJbmRpY2VzID0gY3VycnkkKGZ1bmN0aW9uKGYsIHhzKXtcbiAgdmFyIGkkLCBsZW4kLCBpLCB4LCByZXN1bHRzJCA9IFtdO1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IHhzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgaSA9IGkkO1xuICAgIHggPSB4c1tpJF07XG4gICAgaWYgKGYoeCkpIHtcbiAgICAgIHJlc3VsdHMkLnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRzJDtcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVhY2g6IGVhY2gsXG4gIG1hcDogbWFwLFxuICBmaWx0ZXI6IGZpbHRlcixcbiAgY29tcGFjdDogY29tcGFjdCxcbiAgcmVqZWN0OiByZWplY3QsXG4gIHBhcnRpdGlvbjogcGFydGl0aW9uLFxuICBmaW5kOiBmaW5kLFxuICBoZWFkOiBoZWFkLFxuICBmaXJzdDogZmlyc3QsXG4gIHRhaWw6IHRhaWwsXG4gIGxhc3Q6IGxhc3QsXG4gIGluaXRpYWw6IGluaXRpYWwsXG4gIGVtcHR5OiBlbXB0eSxcbiAgcmV2ZXJzZTogcmV2ZXJzZSxcbiAgZGlmZmVyZW5jZTogZGlmZmVyZW5jZSxcbiAgaW50ZXJzZWN0aW9uOiBpbnRlcnNlY3Rpb24sXG4gIHVuaW9uOiB1bmlvbixcbiAgY291bnRCeTogY291bnRCeSxcbiAgZ3JvdXBCeTogZ3JvdXBCeSxcbiAgZm9sZDogZm9sZCxcbiAgZm9sZDE6IGZvbGQxLFxuICBmb2xkbDogZm9sZGwsXG4gIGZvbGRsMTogZm9sZGwxLFxuICBmb2xkcjogZm9sZHIsXG4gIGZvbGRyMTogZm9sZHIxLFxuICB1bmZvbGRyOiB1bmZvbGRyLFxuICBhbmRMaXN0OiBhbmRMaXN0LFxuICBvckxpc3Q6IG9yTGlzdCxcbiAgYW55OiBhbnksXG4gIGFsbDogYWxsLFxuICB1bmlxdWU6IHVuaXF1ZSxcbiAgdW5pcXVlQnk6IHVuaXF1ZUJ5LFxuICBzb3J0OiBzb3J0LFxuICBzb3J0V2l0aDogc29ydFdpdGgsXG4gIHNvcnRCeTogc29ydEJ5LFxuICBzdW06IHN1bSxcbiAgcHJvZHVjdDogcHJvZHVjdCxcbiAgbWVhbjogbWVhbixcbiAgYXZlcmFnZTogYXZlcmFnZSxcbiAgY29uY2F0OiBjb25jYXQsXG4gIGNvbmNhdE1hcDogY29uY2F0TWFwLFxuICBmbGF0dGVuOiBmbGF0dGVuLFxuICBtYXhpbXVtOiBtYXhpbXVtLFxuICBtaW5pbXVtOiBtaW5pbXVtLFxuICBtYXhpbXVtQnk6IG1heGltdW1CeSxcbiAgbWluaW11bUJ5OiBtaW5pbXVtQnksXG4gIHNjYW46IHNjYW4sXG4gIHNjYW4xOiBzY2FuMSxcbiAgc2Nhbmw6IHNjYW5sLFxuICBzY2FubDE6IHNjYW5sMSxcbiAgc2NhbnI6IHNjYW5yLFxuICBzY2FucjE6IHNjYW5yMSxcbiAgc2xpY2U6IHNsaWNlLFxuICB0YWtlOiB0YWtlLFxuICBkcm9wOiBkcm9wLFxuICBzcGxpdEF0OiBzcGxpdEF0LFxuICB0YWtlV2hpbGU6IHRha2VXaGlsZSxcbiAgZHJvcFdoaWxlOiBkcm9wV2hpbGUsXG4gIHNwYW46IHNwYW4sXG4gIGJyZWFrTGlzdDogYnJlYWtMaXN0LFxuICB6aXA6IHppcCxcbiAgemlwV2l0aDogemlwV2l0aCxcbiAgemlwQWxsOiB6aXBBbGwsXG4gIHppcEFsbFdpdGg6IHppcEFsbFdpdGgsXG4gIGF0OiBhdCxcbiAgZWxlbUluZGV4OiBlbGVtSW5kZXgsXG4gIGVsZW1JbmRpY2VzOiBlbGVtSW5kaWNlcyxcbiAgZmluZEluZGV4OiBmaW5kSW5kZXgsXG4gIGZpbmRJbmRpY2VzOiBmaW5kSW5kaWNlc1xufTtcbmZ1bmN0aW9uIGN1cnJ5JChmLCBib3VuZCl7XG4gIHZhciBjb250ZXh0LFxuICBfY3VycnkgPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgcmV0dXJuIGYubGVuZ3RoID4gMSA/IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgcGFyYW1zID0gYXJncyA/IGFyZ3MuY29uY2F0KCkgOiBbXTtcbiAgICAgIGNvbnRleHQgPSBib3VuZCA/IGNvbnRleHQgfHwgdGhpcyA6IHRoaXM7XG4gICAgICByZXR1cm4gcGFyYW1zLnB1c2guYXBwbHkocGFyYW1zLCBhcmd1bWVudHMpIDxcbiAgICAgICAgICBmLmxlbmd0aCAmJiBhcmd1bWVudHMubGVuZ3RoID9cbiAgICAgICAgX2N1cnJ5LmNhbGwoY29udGV4dCwgcGFyYW1zKSA6IGYuYXBwbHkoY29udGV4dCwgcGFyYW1zKTtcbiAgICB9IDogZjtcbiAgfTtcbiAgcmV0dXJuIF9jdXJyeSgpO1xufVxuZnVuY3Rpb24gaW4kKHgsIHhzKXtcbiAgdmFyIGkgPSAtMSwgbCA9IHhzLmxlbmd0aCA+Pj4gMDtcbiAgd2hpbGUgKCsraSA8IGwpIGlmICh4ID09PSB4c1tpXSkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG5vdCQoeCl7IHJldHVybiAheDsgfSIsIi8vIEdlbmVyYXRlZCBieSBMaXZlU2NyaXB0IDEuMi4wXG52YXIgbWF4LCBtaW4sIG5lZ2F0ZSwgYWJzLCBzaWdudW0sIHF1b3QsIHJlbSwgZGl2LCBtb2QsIHJlY2lwLCBwaSwgdGF1LCBleHAsIHNxcnQsIGxuLCBwb3csIHNpbiwgdGFuLCBjb3MsIGFzaW4sIGFjb3MsIGF0YW4sIGF0YW4yLCB0cnVuY2F0ZSwgcm91bmQsIGNlaWxpbmcsIGZsb29yLCBpc0l0TmFOLCBldmVuLCBvZGQsIGdjZCwgbGNtO1xubWF4ID0gY3VycnkkKGZ1bmN0aW9uKHgkLCB5JCl7XG4gIHJldHVybiB4JCA+IHkkID8geCQgOiB5JDtcbn0pO1xubWluID0gY3VycnkkKGZ1bmN0aW9uKHgkLCB5JCl7XG4gIHJldHVybiB4JCA8IHkkID8geCQgOiB5JDtcbn0pO1xubmVnYXRlID0gZnVuY3Rpb24oeCl7XG4gIHJldHVybiAteDtcbn07XG5hYnMgPSBNYXRoLmFicztcbnNpZ251bSA9IGZ1bmN0aW9uKHgpe1xuICBpZiAoeCA8IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoeCA+IDApIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcbnF1b3QgPSBjdXJyeSQoZnVuY3Rpb24oeCwgeSl7XG4gIHJldHVybiB+fih4IC8geSk7XG59KTtcbnJlbSA9IGN1cnJ5JChmdW5jdGlvbih4JCwgeSQpe1xuICByZXR1cm4geCQgJSB5JDtcbn0pO1xuZGl2ID0gY3VycnkkKGZ1bmN0aW9uKHgsIHkpe1xuICByZXR1cm4gTWF0aC5mbG9vcih4IC8geSk7XG59KTtcbm1vZCA9IGN1cnJ5JChmdW5jdGlvbih4JCwgeSQpe1xuICB2YXIgcmVmJDtcbiAgcmV0dXJuICgoeCQpICUgKHJlZiQgPSB5JCkgKyByZWYkKSAlIHJlZiQ7XG59KTtcbnJlY2lwID0gKGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIDEgLyBpdDtcbn0pO1xucGkgPSBNYXRoLlBJO1xudGF1ID0gcGkgKiAyO1xuZXhwID0gTWF0aC5leHA7XG5zcXJ0ID0gTWF0aC5zcXJ0O1xubG4gPSBNYXRoLmxvZztcbnBvdyA9IGN1cnJ5JChmdW5jdGlvbih4JCwgeSQpe1xuICByZXR1cm4gTWF0aC5wb3coeCQsIHkkKTtcbn0pO1xuc2luID0gTWF0aC5zaW47XG50YW4gPSBNYXRoLnRhbjtcbmNvcyA9IE1hdGguY29zO1xuYXNpbiA9IE1hdGguYXNpbjtcbmFjb3MgPSBNYXRoLmFjb3M7XG5hdGFuID0gTWF0aC5hdGFuO1xuYXRhbjIgPSBjdXJyeSQoZnVuY3Rpb24oeCwgeSl7XG4gIHJldHVybiBNYXRoLmF0YW4yKHgsIHkpO1xufSk7XG50cnVuY2F0ZSA9IGZ1bmN0aW9uKHgpe1xuICByZXR1cm4gfn54O1xufTtcbnJvdW5kID0gTWF0aC5yb3VuZDtcbmNlaWxpbmcgPSBNYXRoLmNlaWw7XG5mbG9vciA9IE1hdGguZmxvb3I7XG5pc0l0TmFOID0gZnVuY3Rpb24oeCl7XG4gIHJldHVybiB4ICE9PSB4O1xufTtcbmV2ZW4gPSBmdW5jdGlvbih4KXtcbiAgcmV0dXJuIHggJSAyID09PSAwO1xufTtcbm9kZCA9IGZ1bmN0aW9uKHgpe1xuICByZXR1cm4geCAlIDIgIT09IDA7XG59O1xuZ2NkID0gY3VycnkkKGZ1bmN0aW9uKHgsIHkpe1xuICB2YXIgejtcbiAgeCA9IE1hdGguYWJzKHgpO1xuICB5ID0gTWF0aC5hYnMoeSk7XG4gIHdoaWxlICh5ICE9PSAwKSB7XG4gICAgeiA9IHggJSB5O1xuICAgIHggPSB5O1xuICAgIHkgPSB6O1xuICB9XG4gIHJldHVybiB4O1xufSk7XG5sY20gPSBjdXJyeSQoZnVuY3Rpb24oeCwgeSl7XG4gIHJldHVybiBNYXRoLmFicyhNYXRoLmZsb29yKHggLyBnY2QoeCwgeSkgKiB5KSk7XG59KTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBtYXg6IG1heCxcbiAgbWluOiBtaW4sXG4gIG5lZ2F0ZTogbmVnYXRlLFxuICBhYnM6IGFicyxcbiAgc2lnbnVtOiBzaWdudW0sXG4gIHF1b3Q6IHF1b3QsXG4gIHJlbTogcmVtLFxuICBkaXY6IGRpdixcbiAgbW9kOiBtb2QsXG4gIHJlY2lwOiByZWNpcCxcbiAgcGk6IHBpLFxuICB0YXU6IHRhdSxcbiAgZXhwOiBleHAsXG4gIHNxcnQ6IHNxcnQsXG4gIGxuOiBsbixcbiAgcG93OiBwb3csXG4gIHNpbjogc2luLFxuICB0YW46IHRhbixcbiAgY29zOiBjb3MsXG4gIGFjb3M6IGFjb3MsXG4gIGFzaW46IGFzaW4sXG4gIGF0YW46IGF0YW4sXG4gIGF0YW4yOiBhdGFuMixcbiAgdHJ1bmNhdGU6IHRydW5jYXRlLFxuICByb3VuZDogcm91bmQsXG4gIGNlaWxpbmc6IGNlaWxpbmcsXG4gIGZsb29yOiBmbG9vcixcbiAgaXNJdE5hTjogaXNJdE5hTixcbiAgZXZlbjogZXZlbixcbiAgb2RkOiBvZGQsXG4gIGdjZDogZ2NkLFxuICBsY206IGxjbVxufTtcbmZ1bmN0aW9uIGN1cnJ5JChmLCBib3VuZCl7XG4gIHZhciBjb250ZXh0LFxuICBfY3VycnkgPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgcmV0dXJuIGYubGVuZ3RoID4gMSA/IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgcGFyYW1zID0gYXJncyA/IGFyZ3MuY29uY2F0KCkgOiBbXTtcbiAgICAgIGNvbnRleHQgPSBib3VuZCA/IGNvbnRleHQgfHwgdGhpcyA6IHRoaXM7XG4gICAgICByZXR1cm4gcGFyYW1zLnB1c2guYXBwbHkocGFyYW1zLCBhcmd1bWVudHMpIDxcbiAgICAgICAgICBmLmxlbmd0aCAmJiBhcmd1bWVudHMubGVuZ3RoID9cbiAgICAgICAgX2N1cnJ5LmNhbGwoY29udGV4dCwgcGFyYW1zKSA6IGYuYXBwbHkoY29udGV4dCwgcGFyYW1zKTtcbiAgICB9IDogZjtcbiAgfTtcbiAgcmV0dXJuIF9jdXJyeSgpO1xufSIsIi8vIEdlbmVyYXRlZCBieSBMaXZlU2NyaXB0IDEuMi4wXG52YXIgdmFsdWVzLCBrZXlzLCBwYWlyc1RvT2JqLCBvYmpUb1BhaXJzLCBsaXN0c1RvT2JqLCBvYmpUb0xpc3RzLCBlbXB0eSwgZWFjaCwgbWFwLCBjb21wYWN0LCBmaWx0ZXIsIHJlamVjdCwgcGFydGl0aW9uLCBmaW5kO1xudmFsdWVzID0gZnVuY3Rpb24ob2JqZWN0KXtcbiAgdmFyIGkkLCB4LCByZXN1bHRzJCA9IFtdO1xuICBmb3IgKGkkIGluIG9iamVjdCkge1xuICAgIHggPSBvYmplY3RbaSRdO1xuICAgIHJlc3VsdHMkLnB1c2goeCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHMkO1xufTtcbmtleXMgPSBmdW5jdGlvbihvYmplY3Qpe1xuICB2YXIgeCwgcmVzdWx0cyQgPSBbXTtcbiAgZm9yICh4IGluIG9iamVjdCkge1xuICAgIHJlc3VsdHMkLnB1c2goeCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHMkO1xufTtcbnBhaXJzVG9PYmogPSBmdW5jdGlvbihvYmplY3Qpe1xuICB2YXIgaSQsIGxlbiQsIHgsIHJlc3VsdHMkID0ge307XG4gIGZvciAoaSQgPSAwLCBsZW4kID0gb2JqZWN0Lmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeCA9IG9iamVjdFtpJF07XG4gICAgcmVzdWx0cyRbeFswXV0gPSB4WzFdO1xuICB9XG4gIHJldHVybiByZXN1bHRzJDtcbn07XG5vYmpUb1BhaXJzID0gZnVuY3Rpb24ob2JqZWN0KXtcbiAgdmFyIGtleSwgdmFsdWUsIHJlc3VsdHMkID0gW107XG4gIGZvciAoa2V5IGluIG9iamVjdCkge1xuICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgcmVzdWx0cyQucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9XG4gIHJldHVybiByZXN1bHRzJDtcbn07XG5saXN0c1RvT2JqID0gY3VycnkkKGZ1bmN0aW9uKGtleXMsIHZhbHVlcyl7XG4gIHZhciBpJCwgbGVuJCwgaSwga2V5LCByZXN1bHRzJCA9IHt9O1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IGtleXMubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICBpID0gaSQ7XG4gICAga2V5ID0ga2V5c1tpJF07XG4gICAgcmVzdWx0cyRba2V5XSA9IHZhbHVlc1tpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cyQ7XG59KTtcbm9ialRvTGlzdHMgPSBmdW5jdGlvbihvYmplY3Qpe1xuICB2YXIga2V5cywgdmFsdWVzLCBrZXksIHZhbHVlO1xuICBrZXlzID0gW107XG4gIHZhbHVlcyA9IFtdO1xuICBmb3IgKGtleSBpbiBvYmplY3QpIHtcbiAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gW2tleXMsIHZhbHVlc107XG59O1xuZW1wdHkgPSBmdW5jdGlvbihvYmplY3Qpe1xuICB2YXIgeDtcbiAgZm9yICh4IGluIG9iamVjdCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5lYWNoID0gY3VycnkkKGZ1bmN0aW9uKGYsIG9iamVjdCl7XG4gIHZhciBpJCwgeDtcbiAgZm9yIChpJCBpbiBvYmplY3QpIHtcbiAgICB4ID0gb2JqZWN0W2kkXTtcbiAgICBmKHgpO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59KTtcbm1hcCA9IGN1cnJ5JChmdW5jdGlvbihmLCBvYmplY3Qpe1xuICB2YXIgaywgeCwgcmVzdWx0cyQgPSB7fTtcbiAgZm9yIChrIGluIG9iamVjdCkge1xuICAgIHggPSBvYmplY3Rba107XG4gICAgcmVzdWx0cyRba10gPSBmKHgpO1xuICB9XG4gIHJldHVybiByZXN1bHRzJDtcbn0pO1xuY29tcGFjdCA9IGZ1bmN0aW9uKG9iamVjdCl7XG4gIHZhciBrLCB4LCByZXN1bHRzJCA9IHt9O1xuICBmb3IgKGsgaW4gb2JqZWN0KSB7XG4gICAgeCA9IG9iamVjdFtrXTtcbmlmICh4KSB7XG4gICAgICByZXN1bHRzJFtrXSA9IHg7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRzJDtcbn07XG5maWx0ZXIgPSBjdXJyeSQoZnVuY3Rpb24oZiwgb2JqZWN0KXtcbiAgdmFyIGssIHgsIHJlc3VsdHMkID0ge307XG4gIGZvciAoayBpbiBvYmplY3QpIHtcbiAgICB4ID0gb2JqZWN0W2tdO1xuaWYgKGYoeCkpIHtcbiAgICAgIHJlc3VsdHMkW2tdID0geDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHMkO1xufSk7XG5yZWplY3QgPSBjdXJyeSQoZnVuY3Rpb24oZiwgb2JqZWN0KXtcbiAgdmFyIGssIHgsIHJlc3VsdHMkID0ge307XG4gIGZvciAoayBpbiBvYmplY3QpIHtcbiAgICB4ID0gb2JqZWN0W2tdO1xuaWYgKCFmKHgpKSB7XG4gICAgICByZXN1bHRzJFtrXSA9IHg7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRzJDtcbn0pO1xucGFydGl0aW9uID0gY3VycnkkKGZ1bmN0aW9uKGYsIG9iamVjdCl7XG4gIHZhciBwYXNzZWQsIGZhaWxlZCwgaywgeDtcbiAgcGFzc2VkID0ge307XG4gIGZhaWxlZCA9IHt9O1xuICBmb3IgKGsgaW4gb2JqZWN0KSB7XG4gICAgeCA9IG9iamVjdFtrXTtcbiAgICAoZih4KSA/IHBhc3NlZCA6IGZhaWxlZClba10gPSB4O1xuICB9XG4gIHJldHVybiBbcGFzc2VkLCBmYWlsZWRdO1xufSk7XG5maW5kID0gY3VycnkkKGZ1bmN0aW9uKGYsIG9iamVjdCl7XG4gIHZhciBpJCwgeDtcbiAgZm9yIChpJCBpbiBvYmplY3QpIHtcbiAgICB4ID0gb2JqZWN0W2kkXTtcbiAgICBpZiAoZih4KSkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9XG59KTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICB2YWx1ZXM6IHZhbHVlcyxcbiAga2V5czoga2V5cyxcbiAgcGFpcnNUb09iajogcGFpcnNUb09iaixcbiAgb2JqVG9QYWlyczogb2JqVG9QYWlycyxcbiAgbGlzdHNUb09iajogbGlzdHNUb09iaixcbiAgb2JqVG9MaXN0czogb2JqVG9MaXN0cyxcbiAgZW1wdHk6IGVtcHR5LFxuICBlYWNoOiBlYWNoLFxuICBtYXA6IG1hcCxcbiAgZmlsdGVyOiBmaWx0ZXIsXG4gIGNvbXBhY3Q6IGNvbXBhY3QsXG4gIHJlamVjdDogcmVqZWN0LFxuICBwYXJ0aXRpb246IHBhcnRpdGlvbixcbiAgZmluZDogZmluZFxufTtcbmZ1bmN0aW9uIGN1cnJ5JChmLCBib3VuZCl7XG4gIHZhciBjb250ZXh0LFxuICBfY3VycnkgPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgcmV0dXJuIGYubGVuZ3RoID4gMSA/IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgcGFyYW1zID0gYXJncyA/IGFyZ3MuY29uY2F0KCkgOiBbXTtcbiAgICAgIGNvbnRleHQgPSBib3VuZCA/IGNvbnRleHQgfHwgdGhpcyA6IHRoaXM7XG4gICAgICByZXR1cm4gcGFyYW1zLnB1c2guYXBwbHkocGFyYW1zLCBhcmd1bWVudHMpIDxcbiAgICAgICAgICBmLmxlbmd0aCAmJiBhcmd1bWVudHMubGVuZ3RoID9cbiAgICAgICAgX2N1cnJ5LmNhbGwoY29udGV4dCwgcGFyYW1zKSA6IGYuYXBwbHkoY29udGV4dCwgcGFyYW1zKTtcbiAgICB9IDogZjtcbiAgfTtcbiAgcmV0dXJuIF9jdXJyeSgpO1xufSIsIi8vIEdlbmVyYXRlZCBieSBMaXZlU2NyaXB0IDEuMi4wXG52YXIgc3BsaXQsIGpvaW4sIGxpbmVzLCB1bmxpbmVzLCB3b3JkcywgdW53b3JkcywgY2hhcnMsIHVuY2hhcnMsIHJldmVyc2UsIHJlcGVhdCwgY2FwaXRhbGl6ZSwgY2FtZWxpemUsIGRhc2hlcml6ZTtcbnNwbGl0ID0gY3VycnkkKGZ1bmN0aW9uKHNlcCwgc3RyKXtcbiAgcmV0dXJuIHN0ci5zcGxpdChzZXApO1xufSk7XG5qb2luID0gY3VycnkkKGZ1bmN0aW9uKHNlcCwgeHMpe1xuICByZXR1cm4geHMuam9pbihzZXApO1xufSk7XG5saW5lcyA9IGZ1bmN0aW9uKHN0cil7XG4gIGlmICghc3RyLmxlbmd0aCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gc3RyLnNwbGl0KCdcXG4nKTtcbn07XG51bmxpbmVzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQuam9pbignXFxuJyk7XG59O1xud29yZHMgPSBmdW5jdGlvbihzdHIpe1xuICBpZiAoIXN0ci5sZW5ndGgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIHN0ci5zcGxpdCgvWyBdKy8pO1xufTtcbnVud29yZHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdC5qb2luKCcgJyk7XG59O1xuY2hhcnMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdC5zcGxpdCgnJyk7XG59O1xudW5jaGFycyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0LmpvaW4oJycpO1xufTtcbnJldmVyc2UgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJyk7XG59O1xucmVwZWF0ID0gY3VycnkkKGZ1bmN0aW9uKG4sIHN0cil7XG4gIHZhciByZXN1bHQsIGkkO1xuICByZXN1bHQgPSAnJztcbiAgZm9yIChpJCA9IDA7IGkkIDwgbjsgKytpJCkge1xuICAgIHJlc3VsdCArPSBzdHI7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59O1xuY2FtZWxpemUgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdC5yZXBsYWNlKC9bLV9dKyguKT8vZywgZnVuY3Rpb24oYXJnJCwgYyl7XG4gICAgcmV0dXJuIChjICE9IG51bGwgPyBjIDogJycpLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufTtcbmRhc2hlcml6ZSA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFteLUEtWl0pKFtBLVpdKykvZywgZnVuY3Rpb24oYXJnJCwgbG93ZXIsIHVwcGVyKXtcbiAgICByZXR1cm4gbG93ZXIgKyBcIi1cIiArICh1cHBlci5sZW5ndGggPiAxXG4gICAgICA/IHVwcGVyXG4gICAgICA6IHVwcGVyLnRvTG93ZXJDYXNlKCkpO1xuICB9KS5yZXBsYWNlKC9eKFtBLVpdKykvLCBmdW5jdGlvbihhcmckLCB1cHBlcil7XG4gICAgaWYgKHVwcGVyLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB1cHBlciArIFwiLVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdXBwZXIudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH0pO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzcGxpdDogc3BsaXQsXG4gIGpvaW46IGpvaW4sXG4gIGxpbmVzOiBsaW5lcyxcbiAgdW5saW5lczogdW5saW5lcyxcbiAgd29yZHM6IHdvcmRzLFxuICB1bndvcmRzOiB1bndvcmRzLFxuICBjaGFyczogY2hhcnMsXG4gIHVuY2hhcnM6IHVuY2hhcnMsXG4gIHJldmVyc2U6IHJldmVyc2UsXG4gIHJlcGVhdDogcmVwZWF0LFxuICBjYXBpdGFsaXplOiBjYXBpdGFsaXplLFxuICBjYW1lbGl6ZTogY2FtZWxpemUsXG4gIGRhc2hlcml6ZTogZGFzaGVyaXplXG59O1xuZnVuY3Rpb24gY3VycnkkKGYsIGJvdW5kKXtcbiAgdmFyIGNvbnRleHQsXG4gIF9jdXJyeSA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICByZXR1cm4gZi5sZW5ndGggPiAxID8gZnVuY3Rpb24oKXtcbiAgICAgIHZhciBwYXJhbXMgPSBhcmdzID8gYXJncy5jb25jYXQoKSA6IFtdO1xuICAgICAgY29udGV4dCA9IGJvdW5kID8gY29udGV4dCB8fCB0aGlzIDogdGhpcztcbiAgICAgIHJldHVybiBwYXJhbXMucHVzaC5hcHBseShwYXJhbXMsIGFyZ3VtZW50cykgPFxuICAgICAgICAgIGYubGVuZ3RoICYmIGFyZ3VtZW50cy5sZW5ndGggP1xuICAgICAgICBfY3VycnkuY2FsbChjb250ZXh0LCBwYXJhbXMpIDogZi5hcHBseShjb250ZXh0LCBwYXJhbXMpO1xuICAgIH0gOiBmO1xuICB9O1xuICByZXR1cm4gX2N1cnJ5KCk7XG59IiwiLy8gR2VuZXJhdGVkIGJ5IExpdmVTY3JpcHQgMS4yLjBcbnZhciBGdW5jLCBMaXN0LCBPYmosIFN0ciwgTnVtLCBpZCwgaXNUeXBlLCByZXBsaWNhdGUsIHByZWx1ZGUsIHRvU3RyaW5nJCA9IHt9LnRvU3RyaW5nO1xuRnVuYyA9IHJlcXVpcmUoJy4vRnVuYy5qcycpO1xuTGlzdCA9IHJlcXVpcmUoJy4vTGlzdC5qcycpO1xuT2JqID0gcmVxdWlyZSgnLi9PYmouanMnKTtcblN0ciA9IHJlcXVpcmUoJy4vU3RyLmpzJyk7XG5OdW0gPSByZXF1aXJlKCcuL051bS5qcycpO1xuaWQgPSBmdW5jdGlvbih4KXtcbiAgcmV0dXJuIHg7XG59O1xuaXNUeXBlID0gY3VycnkkKGZ1bmN0aW9uKHR5cGUsIHgpe1xuICByZXR1cm4gdG9TdHJpbmckLmNhbGwoeCkuc2xpY2UoOCwgLTEpID09PSB0eXBlO1xufSk7XG5yZXBsaWNhdGUgPSBjdXJyeSQoZnVuY3Rpb24obiwgeCl7XG4gIHZhciBpJCwgcmVzdWx0cyQgPSBbXTtcbiAgZm9yIChpJCA9IDA7IGkkIDwgbjsgKytpJCkge1xuICAgIHJlc3VsdHMkLnB1c2goeCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHMkO1xufSk7XG5TdHIuZW1wdHkgPSBMaXN0LmVtcHR5O1xuU3RyLnNsaWNlID0gTGlzdC5zbGljZTtcblN0ci50YWtlID0gTGlzdC50YWtlO1xuU3RyLmRyb3AgPSBMaXN0LmRyb3A7XG5TdHIuc3BsaXRBdCA9IExpc3Quc3BsaXRBdDtcblN0ci50YWtlV2hpbGUgPSBMaXN0LnRha2VXaGlsZTtcblN0ci5kcm9wV2hpbGUgPSBMaXN0LmRyb3BXaGlsZTtcblN0ci5zcGFuID0gTGlzdC5zcGFuO1xuU3RyLmJyZWFrU3RyID0gTGlzdC5icmVha0xpc3Q7XG5wcmVsdWRlID0ge1xuICBGdW5jOiBGdW5jLFxuICBMaXN0OiBMaXN0LFxuICBPYmo6IE9iaixcbiAgU3RyOiBTdHIsXG4gIE51bTogTnVtLFxuICBpZDogaWQsXG4gIGlzVHlwZTogaXNUeXBlLFxuICByZXBsaWNhdGU6IHJlcGxpY2F0ZVxufTtcbnByZWx1ZGUuZWFjaCA9IExpc3QuZWFjaDtcbnByZWx1ZGUubWFwID0gTGlzdC5tYXA7XG5wcmVsdWRlLmZpbHRlciA9IExpc3QuZmlsdGVyO1xucHJlbHVkZS5jb21wYWN0ID0gTGlzdC5jb21wYWN0O1xucHJlbHVkZS5yZWplY3QgPSBMaXN0LnJlamVjdDtcbnByZWx1ZGUucGFydGl0aW9uID0gTGlzdC5wYXJ0aXRpb247XG5wcmVsdWRlLmZpbmQgPSBMaXN0LmZpbmQ7XG5wcmVsdWRlLmhlYWQgPSBMaXN0LmhlYWQ7XG5wcmVsdWRlLmZpcnN0ID0gTGlzdC5maXJzdDtcbnByZWx1ZGUudGFpbCA9IExpc3QudGFpbDtcbnByZWx1ZGUubGFzdCA9IExpc3QubGFzdDtcbnByZWx1ZGUuaW5pdGlhbCA9IExpc3QuaW5pdGlhbDtcbnByZWx1ZGUuZW1wdHkgPSBMaXN0LmVtcHR5O1xucHJlbHVkZS5yZXZlcnNlID0gTGlzdC5yZXZlcnNlO1xucHJlbHVkZS5kaWZmZXJlbmNlID0gTGlzdC5kaWZmZXJlbmNlO1xucHJlbHVkZS5pbnRlcnNlY3Rpb24gPSBMaXN0LmludGVyc2VjdGlvbjtcbnByZWx1ZGUudW5pb24gPSBMaXN0LnVuaW9uO1xucHJlbHVkZS5jb3VudEJ5ID0gTGlzdC5jb3VudEJ5O1xucHJlbHVkZS5ncm91cEJ5ID0gTGlzdC5ncm91cEJ5O1xucHJlbHVkZS5mb2xkID0gTGlzdC5mb2xkO1xucHJlbHVkZS5mb2xkbCA9IExpc3QuZm9sZGw7XG5wcmVsdWRlLmZvbGQxID0gTGlzdC5mb2xkMTtcbnByZWx1ZGUuZm9sZGwxID0gTGlzdC5mb2xkbDE7XG5wcmVsdWRlLmZvbGRyID0gTGlzdC5mb2xkcjtcbnByZWx1ZGUuZm9sZHIxID0gTGlzdC5mb2xkcjE7XG5wcmVsdWRlLnVuZm9sZHIgPSBMaXN0LnVuZm9sZHI7XG5wcmVsdWRlLmFuZExpc3QgPSBMaXN0LmFuZExpc3Q7XG5wcmVsdWRlLm9yTGlzdCA9IExpc3Qub3JMaXN0O1xucHJlbHVkZS5hbnkgPSBMaXN0LmFueTtcbnByZWx1ZGUuYWxsID0gTGlzdC5hbGw7XG5wcmVsdWRlLnVuaXF1ZSA9IExpc3QudW5pcXVlO1xucHJlbHVkZS51bmlxdWVCeSA9IExpc3QudW5pcXVlQnk7XG5wcmVsdWRlLnNvcnQgPSBMaXN0LnNvcnQ7XG5wcmVsdWRlLnNvcnRXaXRoID0gTGlzdC5zb3J0V2l0aDtcbnByZWx1ZGUuc29ydEJ5ID0gTGlzdC5zb3J0Qnk7XG5wcmVsdWRlLnN1bSA9IExpc3Quc3VtO1xucHJlbHVkZS5wcm9kdWN0ID0gTGlzdC5wcm9kdWN0O1xucHJlbHVkZS5tZWFuID0gTGlzdC5tZWFuO1xucHJlbHVkZS5hdmVyYWdlID0gTGlzdC5hdmVyYWdlO1xucHJlbHVkZS5jb25jYXQgPSBMaXN0LmNvbmNhdDtcbnByZWx1ZGUuY29uY2F0TWFwID0gTGlzdC5jb25jYXRNYXA7XG5wcmVsdWRlLmZsYXR0ZW4gPSBMaXN0LmZsYXR0ZW47XG5wcmVsdWRlLm1heGltdW0gPSBMaXN0Lm1heGltdW07XG5wcmVsdWRlLm1pbmltdW0gPSBMaXN0Lm1pbmltdW07XG5wcmVsdWRlLm1heGltdW1CeSA9IExpc3QubWF4aW11bUJ5O1xucHJlbHVkZS5taW5pbXVtQnkgPSBMaXN0Lm1pbmltdW1CeTtcbnByZWx1ZGUuc2NhbiA9IExpc3Quc2NhbjtcbnByZWx1ZGUuc2NhbmwgPSBMaXN0LnNjYW5sO1xucHJlbHVkZS5zY2FuMSA9IExpc3Quc2NhbjE7XG5wcmVsdWRlLnNjYW5sMSA9IExpc3Quc2NhbmwxO1xucHJlbHVkZS5zY2FuciA9IExpc3Quc2NhbnI7XG5wcmVsdWRlLnNjYW5yMSA9IExpc3Quc2NhbnIxO1xucHJlbHVkZS5zbGljZSA9IExpc3Quc2xpY2U7XG5wcmVsdWRlLnRha2UgPSBMaXN0LnRha2U7XG5wcmVsdWRlLmRyb3AgPSBMaXN0LmRyb3A7XG5wcmVsdWRlLnNwbGl0QXQgPSBMaXN0LnNwbGl0QXQ7XG5wcmVsdWRlLnRha2VXaGlsZSA9IExpc3QudGFrZVdoaWxlO1xucHJlbHVkZS5kcm9wV2hpbGUgPSBMaXN0LmRyb3BXaGlsZTtcbnByZWx1ZGUuc3BhbiA9IExpc3Quc3BhbjtcbnByZWx1ZGUuYnJlYWtMaXN0ID0gTGlzdC5icmVha0xpc3Q7XG5wcmVsdWRlLnppcCA9IExpc3QuemlwO1xucHJlbHVkZS56aXBXaXRoID0gTGlzdC56aXBXaXRoO1xucHJlbHVkZS56aXBBbGwgPSBMaXN0LnppcEFsbDtcbnByZWx1ZGUuemlwQWxsV2l0aCA9IExpc3QuemlwQWxsV2l0aDtcbnByZWx1ZGUuYXQgPSBMaXN0LmF0O1xucHJlbHVkZS5lbGVtSW5kZXggPSBMaXN0LmVsZW1JbmRleDtcbnByZWx1ZGUuZWxlbUluZGljZXMgPSBMaXN0LmVsZW1JbmRpY2VzO1xucHJlbHVkZS5maW5kSW5kZXggPSBMaXN0LmZpbmRJbmRleDtcbnByZWx1ZGUuZmluZEluZGljZXMgPSBMaXN0LmZpbmRJbmRpY2VzO1xucHJlbHVkZS5hcHBseSA9IEZ1bmMuYXBwbHk7XG5wcmVsdWRlLmN1cnJ5ID0gRnVuYy5jdXJyeTtcbnByZWx1ZGUuZmxpcCA9IEZ1bmMuZmxpcDtcbnByZWx1ZGUuZml4ID0gRnVuYy5maXg7XG5wcmVsdWRlLm92ZXIgPSBGdW5jLm92ZXI7XG5wcmVsdWRlLnNwbGl0ID0gU3RyLnNwbGl0O1xucHJlbHVkZS5qb2luID0gU3RyLmpvaW47XG5wcmVsdWRlLmxpbmVzID0gU3RyLmxpbmVzO1xucHJlbHVkZS51bmxpbmVzID0gU3RyLnVubGluZXM7XG5wcmVsdWRlLndvcmRzID0gU3RyLndvcmRzO1xucHJlbHVkZS51bndvcmRzID0gU3RyLnVud29yZHM7XG5wcmVsdWRlLmNoYXJzID0gU3RyLmNoYXJzO1xucHJlbHVkZS51bmNoYXJzID0gU3RyLnVuY2hhcnM7XG5wcmVsdWRlLnJlcGVhdCA9IFN0ci5yZXBlYXQ7XG5wcmVsdWRlLmNhcGl0YWxpemUgPSBTdHIuY2FwaXRhbGl6ZTtcbnByZWx1ZGUuY2FtZWxpemUgPSBTdHIuY2FtZWxpemU7XG5wcmVsdWRlLmRhc2hlcml6ZSA9IFN0ci5kYXNoZXJpemU7XG5wcmVsdWRlLnZhbHVlcyA9IE9iai52YWx1ZXM7XG5wcmVsdWRlLmtleXMgPSBPYmoua2V5cztcbnByZWx1ZGUucGFpcnNUb09iaiA9IE9iai5wYWlyc1RvT2JqO1xucHJlbHVkZS5vYmpUb1BhaXJzID0gT2JqLm9ialRvUGFpcnM7XG5wcmVsdWRlLmxpc3RzVG9PYmogPSBPYmoubGlzdHNUb09iajtcbnByZWx1ZGUub2JqVG9MaXN0cyA9IE9iai5vYmpUb0xpc3RzO1xucHJlbHVkZS5tYXggPSBOdW0ubWF4O1xucHJlbHVkZS5taW4gPSBOdW0ubWluO1xucHJlbHVkZS5uZWdhdGUgPSBOdW0ubmVnYXRlO1xucHJlbHVkZS5hYnMgPSBOdW0uYWJzO1xucHJlbHVkZS5zaWdudW0gPSBOdW0uc2lnbnVtO1xucHJlbHVkZS5xdW90ID0gTnVtLnF1b3Q7XG5wcmVsdWRlLnJlbSA9IE51bS5yZW07XG5wcmVsdWRlLmRpdiA9IE51bS5kaXY7XG5wcmVsdWRlLm1vZCA9IE51bS5tb2Q7XG5wcmVsdWRlLnJlY2lwID0gTnVtLnJlY2lwO1xucHJlbHVkZS5waSA9IE51bS5waTtcbnByZWx1ZGUudGF1ID0gTnVtLnRhdTtcbnByZWx1ZGUuZXhwID0gTnVtLmV4cDtcbnByZWx1ZGUuc3FydCA9IE51bS5zcXJ0O1xucHJlbHVkZS5sbiA9IE51bS5sbjtcbnByZWx1ZGUucG93ID0gTnVtLnBvdztcbnByZWx1ZGUuc2luID0gTnVtLnNpbjtcbnByZWx1ZGUudGFuID0gTnVtLnRhbjtcbnByZWx1ZGUuY29zID0gTnVtLmNvcztcbnByZWx1ZGUuYWNvcyA9IE51bS5hY29zO1xucHJlbHVkZS5hc2luID0gTnVtLmFzaW47XG5wcmVsdWRlLmF0YW4gPSBOdW0uYXRhbjtcbnByZWx1ZGUuYXRhbjIgPSBOdW0uYXRhbjI7XG5wcmVsdWRlLnRydW5jYXRlID0gTnVtLnRydW5jYXRlO1xucHJlbHVkZS5yb3VuZCA9IE51bS5yb3VuZDtcbnByZWx1ZGUuY2VpbGluZyA9IE51bS5jZWlsaW5nO1xucHJlbHVkZS5mbG9vciA9IE51bS5mbG9vcjtcbnByZWx1ZGUuaXNJdE5hTiA9IE51bS5pc0l0TmFOO1xucHJlbHVkZS5ldmVuID0gTnVtLmV2ZW47XG5wcmVsdWRlLm9kZCA9IE51bS5vZGQ7XG5wcmVsdWRlLmdjZCA9IE51bS5nY2Q7XG5wcmVsdWRlLmxjbSA9IE51bS5sY207XG5wcmVsdWRlLlZFUlNJT04gPSAnMS4xLjEnO1xubW9kdWxlLmV4cG9ydHMgPSBwcmVsdWRlO1xuZnVuY3Rpb24gY3VycnkkKGYsIGJvdW5kKXtcbiAgdmFyIGNvbnRleHQsXG4gIF9jdXJyeSA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICByZXR1cm4gZi5sZW5ndGggPiAxID8gZnVuY3Rpb24oKXtcbiAgICAgIHZhciBwYXJhbXMgPSBhcmdzID8gYXJncy5jb25jYXQoKSA6IFtdO1xuICAgICAgY29udGV4dCA9IGJvdW5kID8gY29udGV4dCB8fCB0aGlzIDogdGhpcztcbiAgICAgIHJldHVybiBwYXJhbXMucHVzaC5hcHBseShwYXJhbXMsIGFyZ3VtZW50cykgPFxuICAgICAgICAgIGYubGVuZ3RoICYmIGFyZ3VtZW50cy5sZW5ndGggP1xuICAgICAgICBfY3VycnkuY2FsbChjb250ZXh0LCBwYXJhbXMpIDogZi5hcHBseShjb250ZXh0LCBwYXJhbXMpO1xuICAgIH0gOiBmO1xuICB9O1xuICByZXR1cm4gX2N1cnJ5KCk7XG59IiwidmFyIHN0ZCwgdW5pdHMsIGtIYWxmVGlsZSwgdGlsZVRvUHgsIHRpbGVUb0dhbWUsIGdhbWVUb1B4LCBXQUxMX1RJTEUsIFNwcml0ZSwgcmVmJCwgU3ByaXRlU3RhdGUsIFN0YXRlLCBQcm9qZWN0aWxlLCBTdGFyUGFydGljbGUsIFdhbGxQYXJ0aWNsZSwgUmVjdCwgU3ByaXRlU291cmNlLCBrQXJtc1Nwcml0ZVBhdGgsIGtTcHJpdGVXaWR0aCwga1Nwcml0ZUhlaWdodCwga1VwT2Zmc2V0LCBrRG93bk9mZnNldCwga0hvcml6b250YWxPZmZzZXQsIGtSaWdodE9mZnNldCwga0xlZnRPZmZzZXQsIGtQb2xhclN0YXJJbmRleCwga1Byb2plY3RpbGVTcmNIb3Jpem9udGFsLCBrUHJvamVjdGlsZVNyY1ZlcnRpY2FsLCBrTm96emxlSG9yaXpZLCBrTm96emxlSG9yaXpMZWZ0WCwga05venpsZUhvcml6UmlnaHRYLCBrTm96emxlVXBZLCBrTm96emxlVXBMZWZ0WCwga05venpsZVVwUmlnaHRYLCBrTm96emxlRG93blksIGtOb3p6bGVEb3duTGVmdFgsIGtOb3p6bGVEb3duUmlnaHRYLCBrTDFMaWZlc3Bhbiwga0wxU3BlZWQsIGtMMUNvbGxpc2lvbldpZHRoLCBrTDFDb2xsaXNpb25IZWlnaHQsIFVQLCBET1dOLCBMRUZULCBSSUdIVCwgUG9sYXJTdGFyUHJvamVjdGlsZSwgUG9sYXJTdGFyLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG51bml0cyA9IHJlcXVpcmUoJy4vdW5pdHMnKTtcbmtIYWxmVGlsZSA9IHVuaXRzLmtIYWxmVGlsZSwgdGlsZVRvUHggPSB1bml0cy50aWxlVG9QeCwgdGlsZVRvR2FtZSA9IHVuaXRzLnRpbGVUb0dhbWUsIGdhbWVUb1B4ID0gdW5pdHMuZ2FtZVRvUHg7XG5XQUxMX1RJTEUgPSByZXF1aXJlKCcuL21hcCcpLldBTExfVElMRTtcblNwcml0ZSA9IHJlcXVpcmUoJy4vc3ByaXRlJykuU3ByaXRlO1xucmVmJCA9IHJlcXVpcmUoJy4vc3ByaXRlc3RhdGUnKSwgU3ByaXRlU3RhdGUgPSByZWYkLlNwcml0ZVN0YXRlLCBTdGF0ZSA9IHJlZiQuU3RhdGU7XG5Qcm9qZWN0aWxlID0gcmVxdWlyZSgnLi9wcm9qZWN0aWxlJykuUHJvamVjdGlsZTtcblN0YXJQYXJ0aWNsZSA9IHJlcXVpcmUoJy4vc3Rhci1wYXJ0aWNsZScpLlN0YXJQYXJ0aWNsZTtcbldhbGxQYXJ0aWNsZSA9IHJlcXVpcmUoJy4vd2FsbC1wYXJ0aWNsZScpLldhbGxQYXJ0aWNsZTtcbnJlZiQgPSByZXF1aXJlKCcuL3JlY3RhbmdsZScpLCBSZWN0ID0gcmVmJC5SZWN0YW5nbGUsIFNwcml0ZVNvdXJjZSA9IHJlZiQuU3ByaXRlU291cmNlO1xua0FybXNTcHJpdGVQYXRoID0gJ0FybXMnO1xua1Nwcml0ZVdpZHRoID0gMS41O1xua1Nwcml0ZUhlaWdodCA9IDEuMDtcbmtVcE9mZnNldCA9IDI7XG5rRG93bk9mZnNldCA9IDQ7XG5rSG9yaXpvbnRhbE9mZnNldCA9IDA7XG5rUmlnaHRPZmZzZXQgPSAxO1xua0xlZnRPZmZzZXQgPSAwO1xua1BvbGFyU3RhckluZGV4ID0gMjtcbmtQcm9qZWN0aWxlU3JjSG9yaXpvbnRhbCA9IG5ldyBTcHJpdGVTb3VyY2UoOCwgMiwgMSwgMSk7XG5rUHJvamVjdGlsZVNyY1ZlcnRpY2FsID0gbmV3IFNwcml0ZVNvdXJjZSg5LCAyLCAxLCAxKTtcbmtOb3p6bGVIb3JpelkgPSAyMztcbmtOb3p6bGVIb3JpekxlZnRYID0gMTA7XG5rTm96emxlSG9yaXpSaWdodFggPSAzODtcbmtOb3p6bGVVcFkgPSA0O1xua05venpsZVVwTGVmdFggPSAyNztcbmtOb3p6bGVVcFJpZ2h0WCA9IDIxO1xua05venpsZURvd25ZID0gMjg7XG5rTm96emxlRG93bkxlZnRYID0gMjk7XG5rTm96emxlRG93blJpZ2h0WCA9IDE5O1xua0wxTGlmZXNwYW4gPSA3ICoga0hhbGZUaWxlO1xua0wxU3BlZWQgPSAwLjY7XG5rTDFDb2xsaXNpb25XaWR0aCA9IDMyO1xua0wxQ29sbGlzaW9uSGVpZ2h0ID0gNDtcbnJlZiQgPSBzdGRbJ2VudW0nXSwgVVAgPSByZWYkWzBdLCBET1dOID0gcmVmJFsxXSwgTEVGVCA9IHJlZiRbMl0sIFJJR0hUID0gcmVmJFszXTtcblBvbGFyU3RhclByb2plY3RpbGUgPSAoZnVuY3Rpb24oc3VwZXJjbGFzcyl7XG4gIHZhciBwcm90b3R5cGUgPSBleHRlbmQkKChpbXBvcnQkKFBvbGFyU3RhclByb2plY3RpbGUsIHN1cGVyY2xhc3MpLmRpc3BsYXlOYW1lID0gJ1BvbGFyU3RhclByb2plY3RpbGUnLCBQb2xhclN0YXJQcm9qZWN0aWxlKSwgc3VwZXJjbGFzcykucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IFBvbGFyU3RhclByb2plY3RpbGU7XG4gIGZ1bmN0aW9uIFBvbGFyU3RhclByb2plY3RpbGUoc3ByaXRlLCBzdGF0ZSwgeCwgeSl7XG4gICAgdGhpcy5zcHJpdGUgPSBzcHJpdGU7XG4gICAgUG9sYXJTdGFyUHJvamVjdGlsZS5zdXBlcmNsYXNzLmNhbGwodGhpcywgMSk7XG4gICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgIHRoaXMubGlmZXNwYW4gPSBrTDFMaWZlc3BhbjtcbiAgICB0aGlzLmFsaXZlID0gdHJ1ZTtcbiAgICBzdGQubG9nKCdTRlg6IFBldyEnKTtcbiAgICBpZiAoc3RhdGUuSE9SSVpPTlRBTCkge1xuICAgICAgdGhpcy53aWR0aCA9IGtMMUNvbGxpc2lvbldpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSBrTDFDb2xsaXNpb25IZWlnaHQ7XG4gICAgICB0aGlzLnZlcnRpY2FsID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2lkdGggPSBrTDFDb2xsaXNpb25IZWlnaHQ7XG4gICAgICB0aGlzLmhlaWdodCA9IGtMMUNvbGxpc2lvbldpZHRoO1xuICAgICAgdGhpcy52ZXJ0aWNhbCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMubW9kZSA9IChmdW5jdGlvbigpe1xuICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICBjYXNlIHN0YXRlLlVQOlxuICAgICAgICByZXR1cm4gVVA7XG4gICAgICBjYXNlIHN0YXRlLkRPV046XG4gICAgICAgIHJldHVybiBET1dOO1xuICAgICAgY2FzZSBzdGF0ZS5MRUZUOlxuICAgICAgICByZXR1cm4gTEVGVDtcbiAgICAgIGNhc2Ugc3RhdGUuUklHSFQ6XG4gICAgICAgIHJldHVybiBSSUdIVDtcbiAgICAgIH1cbiAgICB9KCkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIHg6IHtcbiAgICAgICAgZ2V0OiAhc3RhdGUuSE9SSVpPTlRBTFxuICAgICAgICAgID8gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICAgIH1cbiAgICAgICAgICA6IHN0YXRlLkxFRlRcbiAgICAgICAgICAgID8gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgcmV0dXJuIHggLSB0aGlzLm9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogc3RhdGUuUklHSFQgPyBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICByZXR1cm4geCArIHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgfSA6IHZvaWQgOFxuICAgICAgfSxcbiAgICAgIHk6IHtcbiAgICAgICAgZ2V0OiBzdGF0ZS5IT1JJWk9OVEFMXG4gICAgICAgICAgPyBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIDogc3RhdGUuVVBcbiAgICAgICAgICAgID8gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgcmV0dXJuIHkgLSB0aGlzLm9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogc3RhdGUuRE9XTiA/IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIHJldHVybiB5ICsgdGhpcy5vZmZzZXQ7XG4gICAgICAgICAgICB9IDogdm9pZCA4XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcHJvdG90eXBlLmNvbGxpc2lvblJlY3RhbmdsZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGFkanVzdDtcbiAgICBhZGp1c3QgPSAyO1xuICAgIHJldHVybiBuZXcgUmVjdCh0aGlzLnggKyBrSGFsZlRpbGUgLSB0aGlzLndpZHRoIC8gMiwgdGhpcy55ICsgdGhpcy53aWR0aCAvIDIgLSBhZGp1c3QsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgfTtcbiAgcHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGVsYXBzZWRUaW1lLCBtYXAsIHB0b29scyl7XG4gICAgdmFyIGkkLCByZWYkLCBsZW4kLCB0aWxlLCB0aWxlUmVjdCwgcGFydGljbGVYLCBwYXJ0aWNsZVk7XG4gICAgdGhpcy5vZmZzZXQgKz0ga0wxU3BlZWQgKiBlbGFwc2VkVGltZTtcbiAgICBmb3IgKGkkID0gMCwgbGVuJCA9IChyZWYkID0gbWFwLmdldENvbGxpZGluZ1RpbGVzKHRoaXMuY29sbGlzaW9uUmVjdGFuZ2xlKCkpKS5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgICAgdGlsZSA9IHJlZiRbaSRdO1xuICAgICAgaWYgKHRpbGUudHlwZSA9PT0gV0FMTF9USUxFKSB7XG4gICAgICAgIHRpbGVSZWN0ID0gbmV3IFJlY3QodGlsZVRvR2FtZSh0aWxlLmNvbCksIHRpbGVUb0dhbWUodGlsZS5yb3cpLCB0aWxlVG9HYW1lKDEpLCB0aWxlVG9HYW1lKDEpKTtcbiAgICAgICAgcGFydGljbGVYID0gdGhpcy54O1xuICAgICAgICBwYXJ0aWNsZVkgPSB0aGlzLnk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgICAgIGNhc2UgVVA6XG4gICAgICAgICAgcGFydGljbGVZID0gdGlsZVJlY3QuYm90dG9tIC0ga0hhbGZUaWxlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIERPV046XG4gICAgICAgICAgcGFydGljbGVZID0gdGlsZVJlY3QudG9wIC0ga0hhbGZUaWxlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIExFRlQ6XG4gICAgICAgICAgcGFydGljbGVYID0gdGlsZVJlY3QucmlnaHQgLSBrSGFsZlRpbGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUklHSFQ6XG4gICAgICAgICAgcGFydGljbGVYID0gdGlsZVJlY3QubGVmdCAtIGtIYWxmVGlsZTtcbiAgICAgICAgfVxuICAgICAgICBwdG9vbHMuZnJvbnRTeXN0ZW0uYWRkTmV3UGFydGljbGUobmV3IFdhbGxQYXJ0aWNsZShwdG9vbHMuZ3JhcGhpY3MsIHBhcnRpY2xlWCwgcGFydGljbGVZKSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLmFsaXZlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9mZnNldCA+PSB0aGlzLmxpZmVzcGFuKSB7XG4gICAgICBwdG9vbHMuZnJvbnRTeXN0ZW0uYWRkTmV3UGFydGljbGUobmV3IFN0YXJQYXJ0aWNsZShwdG9vbHMuZ3JhcGhpY3MsIHRoaXMueCwgdGhpcy55KSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcbiAgcHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihncmFwaGljcyl7XG4gICAgcmV0dXJuIHRoaXMuc3ByaXRlLmRyYXcoZ3JhcGhpY3MsIHRoaXMueCwgdGhpcy55KTtcbiAgfTtcbiAgcHJvdG90eXBlLmNvbGxpZGVXaXRoRW5lbXkgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmFsaXZlID0gZmFsc2U7XG4gIH07XG4gIHJldHVybiBQb2xhclN0YXJQcm9qZWN0aWxlO1xufShQcm9qZWN0aWxlKSk7XG5vdXQkLlBvbGFyU3RhciA9IFBvbGFyU3RhciA9IChmdW5jdGlvbigpe1xuICBQb2xhclN0YXIuZGlzcGxheU5hbWUgPSAnUG9sYXJTdGFyJztcbiAgdmFyIHByb3RvdHlwZSA9IFBvbGFyU3Rhci5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gUG9sYXJTdGFyO1xuICBmdW5jdGlvbiBQb2xhclN0YXIoZ3JhcGhpY3Mpe1xuICAgIHRoaXMucHJvamVjdGlsZUEgPSBudWxsO1xuICAgIHRoaXMucHJvamVjdGlsZUIgPSBudWxsO1xuICAgIHRoaXMuc3ByaXRlcyA9IHRoaXMuaW5pdGlhbGlzZVNwcml0ZXMoZ3JhcGhpY3MpO1xuICAgIHRoaXMuaHBTcHJpdGUgPSBuZXcgU3ByaXRlKGdyYXBoaWNzLCAnYnVsbGV0Jywga1Byb2plY3RpbGVTcmNIb3Jpem9udGFsKTtcbiAgICB0aGlzLnZwU3ByaXRlID0gbmV3IFNwcml0ZShncmFwaGljcywgJ2J1bGxldCcsIGtQcm9qZWN0aWxlU3JjVmVydGljYWwpO1xuICB9XG4gIHByb3RvdHlwZS5pbml0aWFsaXNlU3ByaXRlcyA9IGZ1bmN0aW9uKGdyYXBoaWNzKXtcbiAgICByZXR1cm4gU3ByaXRlU3RhdGUuZ2VuZXJhdGVXaXRoKGZ1bmN0aW9uKHN0YXRlKXtcbiAgICAgIHZhciB0aWxlWTtcbiAgICAgIHRpbGVZID0gc3RhdGUuTEVGVCA/IGtMZWZ0T2Zmc2V0IDoga1JpZ2h0T2Zmc2V0O1xuICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICBjYXNlIHN0YXRlLkhPUklaT05UQUw6XG4gICAgICAgIHRpbGVZICs9IGtIb3Jpem9udGFsT2Zmc2V0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugc3RhdGUuVVA6XG4gICAgICAgIHRpbGVZICs9IGtVcE9mZnNldDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHN0YXRlLkRPV046XG4gICAgICAgIHRpbGVZICs9IGtEb3duT2Zmc2V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBTcHJpdGUoZ3JhcGhpY3MsIGtBcm1zU3ByaXRlUGF0aCwgbmV3IFNwcml0ZVNvdXJjZShrUG9sYXJTdGFySW5kZXggKiBrU3ByaXRlV2lkdGgsIHRpbGVZLCBrU3ByaXRlV2lkdGgsIGtTcHJpdGVIZWlnaHQpKTtcbiAgICB9KTtcbiAgfTtcbiAgcHJvdG90eXBlLnN0YXJ0RmlyZSA9IGZ1bmN0aW9uKHN0YXRlLCBwbGF5ZXJYLCBwbGF5ZXJZKXtcbiAgICB2YXIgYnVsbGV0WCwgYnVsbGV0WTtcbiAgICBpZiAodGhpcy5wcm9qZWN0aWxlQSAmJiB0aGlzLnByb2plY3RpbGVCKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGJ1bGxldFggPSB0aGlzLmd1blgoc3RhdGUsIHBsYXllclgpIC0ga0hhbGZUaWxlO1xuICAgIGJ1bGxldFkgPSB0aGlzLmd1blkoc3RhdGUsIHBsYXllclkpIC0ga0hhbGZUaWxlO1xuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgIGNhc2Ugc3RhdGUuSE9SSVpPTlRBTDpcbiAgICAgIGJ1bGxldFkgKz0ga05venpsZUhvcml6WTtcbiAgICAgIGJ1bGxldFggKz0gc3RhdGUuTEVGVCA/IGtOb3p6bGVIb3JpekxlZnRYIDoga05venpsZUhvcml6UmlnaHRYO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBzdGF0ZS5VUDpcbiAgICAgIGJ1bGxldFkgKz0ga05venpsZVVwWTtcbiAgICAgIGJ1bGxldFggKz0gc3RhdGUuTEVGVCA/IGtOb3p6bGVVcExlZnRYIDoga05venpsZVVwUmlnaHRYO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBzdGF0ZS5ET1dOOlxuICAgICAgYnVsbGV0WSArPSBrTm96emxlRG93blk7XG4gICAgICBidWxsZXRYICs9IHN0YXRlLkxFRlQgPyBrTm96emxlRG93bkxlZnRYIDoga05venpsZURvd25SaWdodFg7XG4gICAgfVxuICAgIGlmICghdGhpcy5wcm9qZWN0aWxlQSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlsZUEgPSBuZXcgUG9sYXJTdGFyUHJvamVjdGlsZShzdGF0ZS5IT1JJWk9OVEFMXG4gICAgICAgID8gdGhpcy5ocFNwcml0ZVxuICAgICAgICA6IHRoaXMudnBTcHJpdGUsIHN0YXRlLCBidWxsZXRYLCBidWxsZXRZKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnByb2plY3RpbGVCKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aWxlQiA9IG5ldyBQb2xhclN0YXJQcm9qZWN0aWxlKHN0YXRlLkhPUklaT05UQUxcbiAgICAgICAgPyB0aGlzLmhwU3ByaXRlXG4gICAgICAgIDogdGhpcy52cFNwcml0ZSwgc3RhdGUsIGJ1bGxldFgsIGJ1bGxldFkpO1xuICAgIH1cbiAgfTtcbiAgcHJvdG90eXBlLnN0b3BGaXJlID0gZnVuY3Rpb24oKXt9O1xuICBwcm90b3R5cGUuZ3VuWCA9IGZ1bmN0aW9uKHN0YXRlLCBwbGF5ZXJYKXtcbiAgICBpZiAoc3RhdGUuTEVGVCkge1xuICAgICAgcmV0dXJuIHBsYXllclggLSBrSGFsZlRpbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwbGF5ZXJYO1xuICAgIH1cbiAgfTtcbiAgcHJvdG90eXBlLmd1blkgPSBmdW5jdGlvbihzdGF0ZSwgcGxheWVyWSl7XG4gICAgaWYgKHN0YXRlLlVQKSB7XG4gICAgICBwbGF5ZXJZIC09IGtIYWxmVGlsZSAvIDI7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5ET1dOKSB7XG4gICAgICBwbGF5ZXJZICs9IGtIYWxmVGlsZSAvIDI7XG4gICAgfVxuICAgIHJldHVybiBwbGF5ZXJZICsgdGhpcy5ndW5Cb2Ioc3RhdGUpO1xuICB9O1xuICBwcm90b3R5cGUuZ3VuQm9iID0gZnVuY3Rpb24oc3RhdGUpe1xuICAgIGlmIChzdGF0ZS5XQUxLSU5HICYmIChzdGF0ZS5TVFJJREVfTEVGVCB8fCBzdGF0ZS5TVFJJREVfUklHSFQpKSB7XG4gICAgICByZXR1cm4gLTI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfTtcbiAgcHJvdG90eXBlLmdldFByb2plY3RpbGVzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcHJvamVjdGlsZXMsIHRoYXQ7XG4gICAgcHJvamVjdGlsZXMgPSBbXTtcbiAgICBpZiAodGhhdCA9IHRoaXMucHJvamVjdGlsZUEpIHtcbiAgICAgIHByb2plY3RpbGVzLnB1c2godGhhdCk7XG4gICAgfVxuICAgIGlmICh0aGF0ID0gdGhpcy5wcm9qZWN0aWxlQikge1xuICAgICAgcHJvamVjdGlsZXMucHVzaCh0aGF0KTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2plY3RpbGVzO1xuICB9O1xuICBwcm90b3R5cGUudXBkYXRlUHJvamVjdGlsZXMgPSBmdW5jdGlvbihlbGFwc2VkVGltZSwgbWFwLCBwdG9vbHMpe1xuICAgIHZhciByZWYkO1xuICAgIGlmICghKChyZWYkID0gdGhpcy5wcm9qZWN0aWxlQSkgIT0gbnVsbCAmJiByZWYkLnVwZGF0ZShlbGFwc2VkVGltZSwgbWFwLCBwdG9vbHMpKSkge1xuICAgICAgdGhpcy5wcm9qZWN0aWxlQSA9IG51bGw7XG4gICAgfVxuICAgIGlmICghKChyZWYkID0gdGhpcy5wcm9qZWN0aWxlQikgIT0gbnVsbCAmJiByZWYkLnVwZGF0ZShlbGFwc2VkVGltZSwgbWFwLCBwdG9vbHMpKSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlsZUIgPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgcHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihncmFwaGljcywgcGxheWVyWCwgcGxheWVyWSwgc3RhdGUpe1xuICAgIHZhciBndW5YLCBndW5ZLCByZWYkO1xuICAgIGd1blggPSB0aGlzLmd1blgoc3RhdGUsIHBsYXllclgpO1xuICAgIGd1blkgPSB0aGlzLmd1blkoc3RhdGUsIHBsYXllclkpO1xuICAgIHRoaXMuc3ByaXRlc1tzdGF0ZS5rZXldLmRyYXcoZ3JhcGhpY3MsIGd1blgsIGd1blkpO1xuICAgIGlmICgocmVmJCA9IHRoaXMucHJvamVjdGlsZUEpICE9IG51bGwpIHtcbiAgICAgIHJlZiQuZHJhdyhncmFwaGljcyk7XG4gICAgfVxuICAgIHJldHVybiAocmVmJCA9IHRoaXMucHJvamVjdGlsZUIpICE9IG51bGwgPyByZWYkLmRyYXcoZ3JhcGhpY3MpIDogdm9pZCA4O1xuICB9O1xuICByZXR1cm4gUG9sYXJTdGFyO1xufSgpKTtcbmZ1bmN0aW9uIGV4dGVuZCQoc3ViLCBzdXApe1xuICBmdW5jdGlvbiBmdW4oKXt9IGZ1bi5wcm90b3R5cGUgPSAoc3ViLnN1cGVyY2xhc3MgPSBzdXApLnByb3RvdHlwZTtcbiAgKHN1Yi5wcm90b3R5cGUgPSBuZXcgZnVuKS5jb25zdHJ1Y3RvciA9IHN1YjtcbiAgaWYgKHR5cGVvZiBzdXAuZXh0ZW5kZWQgPT0gJ2Z1bmN0aW9uJykgc3VwLmV4dGVuZGVkKHN1Yik7XG4gIHJldHVybiBzdWI7XG59XG5mdW5jdGlvbiBpbXBvcnQkKG9iaiwgc3JjKXtcbiAgdmFyIG93biA9IHt9Lmhhc093blByb3BlcnR5O1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSBpZiAob3duLmNhbGwoc3JjLCBrZXkpKSBvYmpba2V5XSA9IHNyY1trZXldO1xuICByZXR1cm4gb2JqO1xufSIsInZhciBzdGQsIFNETCwgdW5pdHMsIGNvbmZpZywga1NjcmVlbldpZHRoLCBrU2NyZWVuSGVpZ2h0LCBrQmFja2dyb3VuZFNpemUsIEZpeGVkQmFja2Ryb3AsIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5zdGQgPSByZXF1aXJlKCdzdGQnKTtcblNETCA9IHJlcXVpcmUoJ1NETCcpO1xudW5pdHMgPSByZXF1aXJlKCcuL3VuaXRzJyk7XG5jb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xua1NjcmVlbldpZHRoID0gY29uZmlnLmtTY3JlZW5XaWR0aCwga1NjcmVlbkhlaWdodCA9IGNvbmZpZy5rU2NyZWVuSGVpZ2h0O1xua0JhY2tncm91bmRTaXplID0gNDtcbm91dCQuRml4ZWRCYWNrZHJvcCA9IEZpeGVkQmFja2Ryb3AgPSAoZnVuY3Rpb24oKXtcbiAgRml4ZWRCYWNrZHJvcC5kaXNwbGF5TmFtZSA9ICdGaXhlZEJhY2tkcm9wJztcbiAgdmFyIHByb3RvdHlwZSA9IEZpeGVkQmFja2Ryb3AucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IEZpeGVkQmFja2Ryb3A7XG4gIGZ1bmN0aW9uIEZpeGVkQmFja2Ryb3AocGF0aCwgZ3JhcGhpY3Mpe1xuICAgIHRoaXMuc3VyZmFjZSA9IGdyYXBoaWNzLmxvYWRJbWFnZShwYXRoKTtcbiAgfVxuICBwcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGdyYXBoaWNzKXtcbiAgICB2YXIgaSQsIHN0ZXAkLCB0byQsIHgsIGxyZXN1bHQkLCBqJCwgc3RlcDEkLCB0bzEkLCB5LCBkZXN0UmVjdCwgcmVzdWx0cyQgPSBbXTtcbiAgICBmb3IgKGkkID0gMCwgdG8kID0gdW5pdHMudGlsZVRvUHgoa1NjcmVlbldpZHRoICsga0JhY2tncm91bmRTaXplKSwgc3RlcCQgPSB1bml0cy50aWxlVG9QeChrQmFja2dyb3VuZFNpemUpOyBzdGVwJCA8IDAgPyBpJCA+PSB0byQgOiBpJCA8PSB0byQ7IGkkICs9IHN0ZXAkKSB7XG4gICAgICB4ID0gaSQ7XG4gICAgICBscmVzdWx0JCA9IFtdO1xuICAgICAgZm9yIChqJCA9IDAsIHRvMSQgPSB1bml0cy50aWxlVG9QeChrU2NyZWVuSGVpZ2h0ICsga0JhY2tncm91bmRTaXplKSwgc3RlcDEkID0gdW5pdHMudGlsZVRvUHgoa0JhY2tncm91bmRTaXplKTsgc3RlcDEkIDwgMCA/IGokID49IHRvMSQgOiBqJCA8PSB0bzEkOyBqJCArPSBzdGVwMSQpIHtcbiAgICAgICAgeSA9IGokO1xuICAgICAgICBkZXN0UmVjdCA9IG5ldyBTREwuUmVjdCh4LCB5LCB1bml0cy50aWxlVG9QeChrQmFja2dyb3VuZFNpemUpLCB1bml0cy50aWxlVG9QeChrQmFja2dyb3VuZFNpemUpKTtcbiAgICAgICAgbHJlc3VsdCQucHVzaChncmFwaGljcy5ibGl0U3VyZmFjZSh0aGlzLnN1cmZhY2UsIG51bGwsIGRlc3RSZWN0KSk7XG4gICAgICB9XG4gICAgICByZXN1bHRzJC5wdXNoKGxyZXN1bHQkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHMkO1xuICB9O1xuICByZXR1cm4gRml4ZWRCYWNrZHJvcDtcbn0oKSk7IiwidmFyIGtTY3JlZW5XaWR0aCwga1NjcmVlbkhlaWdodCwga0Zwcywga01heEZyYW1lVGltZSwga0dyYXBoaWNzUXVhbGl0eSwgZGVidWdGZWF0dXJlcywgdGhhdCwgc2hvd0NvbGxpc2lvbnMsIHNob3dTcHJpdGVzaGVldHMsIHNob3dSZWFkb3V0LCBhc3NldFBhdGgsIGZpbGVFeHQsIGZpbmRBc3NldCwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcbm91dCQua1NjcmVlbldpZHRoID0ga1NjcmVlbldpZHRoID0gMjA7XG5vdXQkLmtTY3JlZW5IZWlnaHQgPSBrU2NyZWVuSGVpZ2h0ID0gMTU7XG5vdXQkLmtGcHMgPSBrRnBzID0gNjA7XG5vdXQkLmtNYXhGcmFtZVRpbWUgPSBrTWF4RnJhbWVUaW1lID0gNSAqIDEwMDAgLyBrRnBzO1xub3V0JC5rR3JhcGhpY3NRdWFsaXR5ID0ga0dyYXBoaWNzUXVhbGl0eSA9IDMyO1xub3V0JC5kZWJ1Z0ZlYXR1cmVzID0gZGVidWdGZWF0dXJlcyA9ICh0aGF0ID0gRU5BQkxFX0RFQlVHX0ZFQVRVUkVTKSAhPSBudWxsID8gdGhhdCA6IGZhbHNlO1xub3V0JC5zaG93Q29sbGlzaW9ucyA9IHNob3dDb2xsaXNpb25zID0gZGVidWdGZWF0dXJlcztcbm91dCQuc2hvd1Nwcml0ZXNoZWV0cyA9IHNob3dTcHJpdGVzaGVldHMgPSBkZWJ1Z0ZlYXR1cmVzO1xub3V0JC5zaG93UmVhZG91dCA9IHNob3dSZWFkb3V0ID0gZGVidWdGZWF0dXJlcztcbnN3aXRjaCAoa0dyYXBoaWNzUXVhbGl0eSkge1xuY2FzZSAxNjpcbiAgb3V0JC5hc3NldFBhdGggPSBhc3NldFBhdGggPSAnZGF0YS8xNngxNi8nO1xuICBvdXQkLmZpbGVFeHQgPSBmaWxlRXh0ID0gJy5ibXAnO1xuICBicmVhaztcbmNhc2UgMzI6XG4gIG91dCQuYXNzZXRQYXRoID0gYXNzZXRQYXRoID0gJ2RhdGEvMzJ4MzIvJztcbiAgb3V0JC5maWxlRXh0ID0gZmlsZUV4dCA9ICcuYm1wJztcbn1cbm91dCQuZmluZEFzc2V0ID0gZmluZEFzc2V0ID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIChmdW5jdGlvbihpdCl7XG4gICAgcmV0dXJuIGFzc2V0UGF0aCArIGl0O1xuICB9KSgoZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiBpdCArIGZpbGVFeHQ7XG4gIH0pLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xufTsiLCJ2YXIgc3RkLCB1bml0cywgVGltZXIsIE51bWJlclNwcml0ZSwga1ZlbG9jaXR5LCBrVmFuaXNoVGltZSwgRGFtYWdlVGV4dCwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcbnN0ZCA9IHJlcXVpcmUoJ3N0ZCcpO1xudW5pdHMgPSByZXF1aXJlKCcuL3VuaXRzJyk7XG5UaW1lciA9IHJlcXVpcmUoJy4vdGltZXInKS5UaW1lcjtcbk51bWJlclNwcml0ZSA9IHJlcXVpcmUoJy4vc3ByaXRlJykuTnVtYmVyU3ByaXRlO1xua1ZlbG9jaXR5ID0gLXVuaXRzLmtIYWxmVGlsZSAvIDI1MDtcbmtWYW5pc2hUaW1lID0gMjAwMDtcbm91dCQuRGFtYWdlVGV4dCA9IERhbWFnZVRleHQgPSAoZnVuY3Rpb24oKXtcbiAgRGFtYWdlVGV4dC5kaXNwbGF5TmFtZSA9ICdEYW1hZ2VUZXh0JztcbiAgdmFyIHByb3RvdHlwZSA9IERhbWFnZVRleHQucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IERhbWFnZVRleHQ7XG4gIGZ1bmN0aW9uIERhbWFnZVRleHQoZ3JhcGhpY3MsIGNlbnRlclgsIGNlbnRlclkpe1xuICAgIHRoaXMuY2VudGVyWCA9IGNlbnRlclg7XG4gICAgdGhpcy5jZW50ZXJZID0gY2VudGVyWTtcbiAgICB0aGlzLnRpbWVyID0gbmV3IFRpbWVyKGtWYW5pc2hUaW1lKTtcbiAgICB0aGlzLmRhbWFnZSA9IDA7XG4gICAgdGhpcy5vZmZzZXRZID0gMDtcbiAgICB0aGlzLnNob3VsZFJpc2UgPSBmYWxzZTtcbiAgfVxuICBwcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbih4LCB5KXtcbiAgICB0aGlzLmNlbnRlclggPSB4O1xuICAgIHJldHVybiB0aGlzLmNlbnRlclkgPSB5ICsgdGhpcy5vZmZzZXRZO1xuICB9O1xuICBwcm90b3R5cGUuc2V0RGFtYWdlID0gZnVuY3Rpb24oZGFtYWdlKXtcbiAgICB0aGlzLnNob3VsZFJpc2UgPSB0aGlzLmRhbWFnZSA9PT0gMDtcbiAgICBpZiAodGhpcy5zaG91bGRSaXNlKSB7XG4gICAgICB0aGlzLm9mZnNldFkgPSAwO1xuICAgIH1cbiAgICB0aGlzLmRhbWFnZSArPSBkYW1hZ2U7XG4gICAgcmV0dXJuIHRoaXMudGltZXIucmVzZXQoKTtcbiAgfTtcbiAgcHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGVsYXBzZWRUaW1lKXtcbiAgICBpZiAodGhpcy50aW1lci5pc0V4cGlyZWQpIHtcbiAgICAgIHRoaXMuZGFtYWdlID0gMDtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2hvdWxkUmlzZSkge1xuICAgICAgdGhpcy5vZmZzZXRZID0gc3RkLm1heCh1bml0cy50aWxlVG9HYW1lKC0xKSwgdGhpcy5vZmZzZXRZICsga1ZlbG9jaXR5ICogZWxhcHNlZFRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5leHBpcmVkO1xuICB9O1xuICBwcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGdyYXBoaWNzKXtcbiAgICBpZiAodGhpcy50aW1lci5pc0FjdGl2ZSAmJiB0aGlzLmRhbWFnZSA+IDApIHtcbiAgICAgIHJldHVybiBuZXcgTnVtYmVyU3ByaXRlLkRhbWFnZU51bWJlcihncmFwaGljcywgdGhpcy5kYW1hZ2UpLmRyYXdDZW50ZXJlZChncmFwaGljcywgdGhpcy5jZW50ZXJYLCB0aGlzLmNlbnRlclkpO1xuICAgIH1cbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgJ2V4cGlyZWQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMudGltZXIuaXNFeHBpcmVkO1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBEYW1hZ2VUZXh0O1xufSgpKTsiLCJ2YXIgc3RkLCBhbGxUZXh0cywgb3duZXJzLCByZWplY3QsIERhbWFnZVRleHRzLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG5hbGxUZXh0cyA9IFtdO1xub3duZXJzID0gbmV3IFdlYWtNYXA7XG5yZWplY3QgPSBzdGQuZmxpcChzdGQucmVqZWN0KShhbGxUZXh0cyk7XG5vdXQkLkRhbWFnZVRleHRzID0gRGFtYWdlVGV4dHMgPSB7XG4gIGFkZERhbWFnZWFibGU6IGZ1bmN0aW9uKGRhbWFnZWFibGUpe1xuICAgIHZhciB0ZXh0O1xuICAgIHRleHQgPSBkYW1hZ2VhYmxlLmdldERhbWFnZVRleHQoKTtcbiAgICBhbGxUZXh0cy5wdXNoKHRleHQpO1xuICAgIHJldHVybiBvd25lcnMuc2V0KHRleHQsIGRhbWFnZWFibGUpO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uKGVsYXBzZWRUaW1lKXtcbiAgICByZXR1cm4gYWxsVGV4dHMgPSByZWplY3QoZnVuY3Rpb24odGV4dCl7XG4gICAgICB2YXIgb3duZXI7XG4gICAgICBpZiAoIXRleHQuZXhwaXJlZCkge1xuICAgICAgICBvd25lciA9IG93bmVycy5nZXQodGV4dCk7XG4gICAgICAgIHRleHQuc2V0UG9zaXRpb24ob3duZXIuY2VudGVyWCwgb3duZXIuY2VudGVyWSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGV4dC51cGRhdGUoZWxhcHNlZFRpbWUpO1xuICAgIH0pO1xuICB9LFxuICBkcmF3OiBmdW5jdGlvbihncmFwaGljcyl7XG4gICAgdmFyIGkkLCByZWYkLCBsZW4kLCB0ZXh0LCByZXN1bHRzJCA9IFtdO1xuICAgIGZvciAoaSQgPSAwLCBsZW4kID0gKHJlZiQgPSBhbGxUZXh0cykubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICAgIHRleHQgPSByZWYkW2kkXTtcbiAgICAgIHJlc3VsdHMkLnB1c2godGV4dC5kcmF3KGdyYXBoaWNzKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzJDtcbiAgfVxufTsiLCJ2YXIgc3RkLCBJbnRlcmZhY2VFcnJvciwgRGFtYWdlYWJsZSwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcbnN0ZCA9IHJlcXVpcmUoJ3N0ZCcpO1xuSW50ZXJmYWNlRXJyb3IgPSAoZnVuY3Rpb24oc3VwZXJjbGFzcyl7XG4gIHZhciBwcm90b3R5cGUgPSBleHRlbmQkKChpbXBvcnQkKEludGVyZmFjZUVycm9yLCBzdXBlcmNsYXNzKS5kaXNwbGF5TmFtZSA9ICdJbnRlcmZhY2VFcnJvcicsIEludGVyZmFjZUVycm9yKSwgc3VwZXJjbGFzcykucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IEludGVyZmFjZUVycm9yO1xuICBmdW5jdGlvbiBJbnRlcmZhY2VFcnJvcihtZXNzYWdlKXtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMubmFtZSA9ICdJbnRlcmZhY2VFcnJvcic7XG4gIH1cbiAgcmV0dXJuIEludGVyZmFjZUVycm9yO1xufShFcnJvcikpO1xub3V0JC5EYW1hZ2VhYmxlID0gRGFtYWdlYWJsZSA9IChmdW5jdGlvbigpe1xuICBEYW1hZ2VhYmxlLmRpc3BsYXlOYW1lID0gJ0RhbWFnZWFibGUnO1xuICB2YXIgcHJvdG90eXBlID0gRGFtYWdlYWJsZS5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gRGFtYWdlYWJsZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgJ2NlbnRlclgnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgdGhyb3cgbmV3IEludGVyZmFjZUVycm9yKFwiRGFtYWdlYWJsZSAtIGBjZW50ZXIteGAgZ2V0dGVyIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCAnY2VudGVyWScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICB0aHJvdyBuZXcgSW50ZXJmYWNlRXJyb3IoXCJEYW1hZ2VhYmxlIC0gYGNlbnRlci15YCBnZXR0ZXIgbm90IGltcGxlbWVudGVkXCIpO1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG4gIHByb3RvdHlwZS5nZXREYW1hZ2VUZXh0ID0gZnVuY3Rpb24oKXtcbiAgICB0aHJvdyBuZXcgSW50ZXJmYWNlRXJyb3IoXCJEYW1hZ2VhYmxlIC0gYGdldC1kYW1hZ2UtdGV4dGAgbWV0aG9kIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfTtcbiAgZnVuY3Rpb24gRGFtYWdlYWJsZSgpe31cbiAgcmV0dXJuIERhbWFnZWFibGU7XG59KCkpO1xuZnVuY3Rpb24gZXh0ZW5kJChzdWIsIHN1cCl7XG4gIGZ1bmN0aW9uIGZ1bigpe30gZnVuLnByb3RvdHlwZSA9IChzdWIuc3VwZXJjbGFzcyA9IHN1cCkucHJvdG90eXBlO1xuICAoc3ViLnByb3RvdHlwZSA9IG5ldyBmdW4pLmNvbnN0cnVjdG9yID0gc3ViO1xuICBpZiAodHlwZW9mIHN1cC5leHRlbmRlZCA9PSAnZnVuY3Rpb24nKSBzdXAuZXh0ZW5kZWQoc3ViKTtcbiAgcmV0dXJuIHN1Yjtcbn1cbmZ1bmN0aW9uIGltcG9ydCQob2JqLCBzcmMpe1xuICB2YXIgb3duID0ge30uaGFzT3duUHJvcGVydHk7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIGlmIChvd24uY2FsbChzcmMsIGtleSkpIG9ialtrZXldID0gc3JjW2tleV07XG4gIHJldHVybiBvYmo7XG59IiwidmFyIHN0ZCwgdW5pdHMsIGtIYWxmVGlsZSwgUG9sYXJWZWN0b3IsIEFuaW1hdGVkU3ByaXRlLCBTcHJpdGVTb3VyY2UsIGtTcmMsIGtCYXNlVmVsb2NpdHksIERlYXRoQ2xvdWRQYXJ0aWNsZSwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcbnN0ZCA9IHJlcXVpcmUoJ3N0ZCcpO1xudW5pdHMgPSByZXF1aXJlKCcuL3VuaXRzJyk7XG5rSGFsZlRpbGUgPSB1bml0cy5rSGFsZlRpbGU7XG5Qb2xhclZlY3RvciA9IHJlcXVpcmUoJy4vcG9sYXInKS5Qb2xhclZlY3RvcjtcbkFuaW1hdGVkU3ByaXRlID0gcmVxdWlyZSgnLi9zcHJpdGUnKS5BbmltYXRlZFNwcml0ZTtcblNwcml0ZVNvdXJjZSA9IHJlcXVpcmUoJy4vcmVjdGFuZ2xlJykuU3ByaXRlU291cmNlO1xua1NyYyA9IG5ldyBTcHJpdGVTb3VyY2UoMSwgMCwgMSwgMSk7XG5rQmFzZVZlbG9jaXR5ID0gMC4xMjtcbm91dCQuRGVhdGhDbG91ZFBhcnRpY2xlID0gRGVhdGhDbG91ZFBhcnRpY2xlID0gKGZ1bmN0aW9uKCl7XG4gIERlYXRoQ2xvdWRQYXJ0aWNsZS5kaXNwbGF5TmFtZSA9ICdEZWF0aENsb3VkUGFydGljbGUnO1xuICB2YXIgcHJvdG90eXBlID0gRGVhdGhDbG91ZFBhcnRpY2xlLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBEZWF0aENsb3VkUGFydGljbGU7XG4gIGZ1bmN0aW9uIERlYXRoQ2xvdWRQYXJ0aWNsZShncmFwaGljcywgY2VudGVyWCwgY2VudGVyWSwgc3BlZWQsIGFuZ2xlKXtcbiAgICB0aGlzLmNlbnRlclggPSBjZW50ZXJYO1xuICAgIHRoaXMuY2VudGVyWSA9IGNlbnRlclk7XG4gICAgdGhpcy5zcGVlZCA9IHNwZWVkO1xuICAgIHRoaXMub2Zmc2V0ID0gbmV3IFBvbGFyVmVjdG9yKDAsIGFuZ2xlKTtcbiAgICB0aGlzLnNwcml0ZSA9IG5ldyBBbmltYXRlZFNwcml0ZShncmFwaGljcywgJ05wYy9OcGNTeW0nLCBrU3JjLCAxOCwgWzAsIDEsIDIsIDMsIDQsIDUsIDZdKTtcbiAgfVxuICBwcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oZWxhcHNlZFRpbWUpe1xuICAgIHRoaXMuc3ByaXRlLnVwZGF0ZShlbGFwc2VkVGltZSk7XG4gICAgdGhpcy5vZmZzZXQubWFnICs9IGVsYXBzZWRUaW1lICogdGhpcy5zcGVlZDtcbiAgICByZXR1cm4gdGhpcy5zcHJpdGUubnVtQ29tcGxldGVkTG9vcHMgPT09IDA7XG4gIH07XG4gIHByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZ3JhcGhpY3Mpe1xuICAgIHJldHVybiB0aGlzLnNwcml0ZS5kcmF3KGdyYXBoaWNzLCB0aGlzLmNlbnRlclggKyB0aGlzLm9mZnNldC54IC0ga0hhbGZUaWxlLCB0aGlzLmNlbnRlclkgKyB0aGlzLm9mZnNldC55IC0ga0hhbGZUaWxlKTtcbiAgfTtcbiAgRGVhdGhDbG91ZFBhcnRpY2xlLmNyZWF0ZVJhbmRvbURlYXRoQ2xvdWRzID0gZnVuY3Rpb24ocHRvb2xzLCBjZW50ZXJYLCBjZW50ZXJZLCBudW0pe1xuICAgIHZhciBpJCwgaXgsIHJhbmRvbUFuZ2xlLCByYW5kb21TcGVlZCwgcmVzdWx0cyQgPSBbXTtcbiAgICBmb3IgKGkkID0gMDsgaSQgPD0gbnVtOyArK2kkKSB7XG4gICAgICBpeCA9IGkkO1xuICAgICAgcmFuZG9tQW5nbGUgPSBzdGQucmFuZCgwLCBzdGQudGF1KTtcbiAgICAgIHJhbmRvbVNwZWVkID0ga0Jhc2VWZWxvY2l0eSAqIHN0ZC5yYW5kKDAsIDIpO1xuICAgICAgcmVzdWx0cyQucHVzaChwdG9vbHMuZW50aXR5U3lzdGVtLmFkZE5ld1BhcnRpY2xlKG5ldyBEZWF0aENsb3VkUGFydGljbGUocHRvb2xzLmdyYXBoaWNzLCBjZW50ZXJYLCBjZW50ZXJZLCByYW5kb21TcGVlZCwgcmFuZG9tQW5nbGUpKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzJDtcbiAgfTtcbiAgcmV0dXJuIERlYXRoQ2xvdWRQYXJ0aWNsZTtcbn0oKSk7IiwidmFyIHN0ZCwgdW5pdHMsIGNvbmZpZywgdGlsZVRvUHgsIHRpbGVUb0dhbWUsIGtIYWxmVGlsZSwga1RpbGVQeCwgRGFtYWdlYWJsZSwgRGFtYWdlVGV4dCwgRGFtYWdlVGV4dHMsIHJlZiQsIFNwcml0ZSwgQW5pbWF0ZWRTcHJpdGUsIFJlY3QsIFNwcml0ZVNvdXJjZSwgUklHSFQsIExFRlQsIGtBbmd1bGFyVmVsb2NpdHksIGtGbHlGcHMsIGtOdW1GbHlGcmFtZXMsIGtDb250YWN0RGFtYWdlLCBTcHJpdGVTdGF0ZSwgRmlyc3RDYXZlQmF0LCBzbGljZSQgPSBbXS5zbGljZSwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcbnN0ZCA9IHJlcXVpcmUoJ3N0ZCcpO1xudW5pdHMgPSByZXF1aXJlKCcuL3VuaXRzJyk7XG5jb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xudGlsZVRvUHggPSB1bml0cy50aWxlVG9QeCwgdGlsZVRvR2FtZSA9IHVuaXRzLnRpbGVUb0dhbWUsIGtIYWxmVGlsZSA9IHVuaXRzLmtIYWxmVGlsZSwga1RpbGVQeCA9IHVuaXRzLmtUaWxlUHg7XG5EYW1hZ2VhYmxlID0gcmVxdWlyZSgnLi9kYW1hZ2VhYmxlJykuRGFtYWdlYWJsZTtcbkRhbWFnZVRleHQgPSByZXF1aXJlKCcuL2RhbWFnZS10ZXh0JykuRGFtYWdlVGV4dDtcbkRhbWFnZVRleHRzID0gcmVxdWlyZSgnLi9kYW1hZ2UtdGV4dHMnKS5EYW1hZ2VUZXh0cztcbnJlZiQgPSByZXF1aXJlKCcuL3Nwcml0ZScpLCBTcHJpdGUgPSByZWYkLlNwcml0ZSwgQW5pbWF0ZWRTcHJpdGUgPSByZWYkLkFuaW1hdGVkU3ByaXRlO1xucmVmJCA9IHJlcXVpcmUoJy4vcmVjdGFuZ2xlJyksIFJlY3QgPSByZWYkLlJlY3RhbmdsZSwgU3ByaXRlU291cmNlID0gcmVmJC5TcHJpdGVTb3VyY2U7XG5SSUdIVCA9IFwiUlwiO1xuTEVGVCA9IFwiTFwiO1xua0FuZ3VsYXJWZWxvY2l0eSA9IDEyMCAvIDEwMDA7XG5rRmx5RnBzID0gMTU7XG5rTnVtRmx5RnJhbWVzID0gMztcbmtDb250YWN0RGFtYWdlID0gMTtcblNwcml0ZVN0YXRlID0gZnVuY3Rpb24oKXtcbiAgdmFyIGFyZ3M7XG4gIGFyZ3MgPSBzbGljZSQuY2FsbChhcmd1bWVudHMpO1xuICByZXR1cm4gU3RyaW5nKGFyZ3Muam9pbignLScpKTtcbn07XG5vdXQkLkZpcnN0Q2F2ZUJhdCA9IEZpcnN0Q2F2ZUJhdCA9IChmdW5jdGlvbihzdXBlcmNsYXNzKXtcbiAgdmFyIHByb3RvdHlwZSA9IGV4dGVuZCQoKGltcG9ydCQoRmlyc3RDYXZlQmF0LCBzdXBlcmNsYXNzKS5kaXNwbGF5TmFtZSA9ICdGaXJzdENhdmVCYXQnLCBGaXJzdENhdmVCYXQpLCBzdXBlcmNsYXNzKS5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gRmlyc3RDYXZlQmF0O1xuICBmdW5jdGlvbiBGaXJzdENhdmVCYXQoZ3JhcGhpY3MsIHgsIGZsaWdodENlbnRlclkpe1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy5mbGlnaHRDZW50ZXJZID0gZmxpZ2h0Q2VudGVyWTtcbiAgICB0aGlzLnkgPSB0aGlzLmZsaWdodENlbnRlclk7XG4gICAgdGhpcy5mbGlnaHRBbmdsZSA9IDA7XG4gICAgdGhpcy5hbGl2ZSA9IHRydWU7XG4gICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgPSBrQW5ndWxhclZlbG9jaXR5O1xuICAgIHRoaXMuc3ByaXRlcyA9IHRoaXMuaW5pdGlhbGlzZVNwcml0ZXMoZ3JhcGhpY3MpO1xuICAgIHRoaXMuZGFtYWdlVGV4dCA9IG5ldyBEYW1hZ2VUZXh0KGdyYXBoaWNzKTtcbiAgICB0aGlzLmNvbnRhY3REYW1hZ2UgPSBrQ29udGFjdERhbWFnZTtcbiAgICBEYW1hZ2VUZXh0cy5hZGREYW1hZ2VhYmxlKHRoaXMpO1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsICdzcHJpdGVzdGF0ZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gU3ByaXRlU3RhdGUodGhpcy5ob3Jpem9udGFsRmFjaW5nKTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xuICBwcm90b3R5cGUuaW5pdGlhbGlzZVNwcml0ZSA9IGZ1bmN0aW9uKGdyYXBoaWNzLCBmYWNpbmcpe1xuICAgIHZhciBmYWNpbmdPZmZzZXQ7XG4gICAgZmFjaW5nT2Zmc2V0ID0gZmFjaW5nID09PSBSSUdIVCA/IDEgOiAwO1xuICAgIHJldHVybiBuZXcgQW5pbWF0ZWRTcHJpdGUoZ3JhcGhpY3MsICdOcGMvTnBjQ2VtZXQnLCBuZXcgU3ByaXRlU291cmNlKDIsIDIgKyBmYWNpbmdPZmZzZXQsIDEsIDEpLCBrRmx5RnBzLCAoZnVuY3Rpb24oKXtcbiAgICAgIHZhciBpJCwgdG8kLCByZXN1bHRzJCA9IFtdO1xuICAgICAgZm9yIChpJCA9IDAsIHRvJCA9IGtOdW1GbHlGcmFtZXM7IGkkIDwgdG8kOyArK2kkKSB7XG4gICAgICAgIHJlc3VsdHMkLnB1c2goaSQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdHMkO1xuICAgIH0oKSkpO1xuICB9O1xuICBwcm90b3R5cGUuaW5pdGlhbGlzZVNwcml0ZXMgPSBmdW5jdGlvbihncmFwaGljcywgc3ByaXRlTWFwKXtcbiAgICB2YXIgaSQsIHJlZiQsIGxlbiQsIGZhY2luZztcbiAgICBzcHJpdGVNYXAgPT0gbnVsbCAmJiAoc3ByaXRlTWFwID0ge30pO1xuICAgIGZvciAoaSQgPSAwLCBsZW4kID0gKHJlZiQgPSBbTEVGVCwgUklHSFRdKS5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgICAgZmFjaW5nID0gcmVmJFtpJF07XG4gICAgICBzcHJpdGVNYXBbU3ByaXRlU3RhdGUoZmFjaW5nKV0gPSB0aGlzLmluaXRpYWxpc2VTcHJpdGUoZ3JhcGhpY3MsIGZhY2luZyk7XG4gICAgfVxuICAgIHJldHVybiBzcHJpdGVNYXA7XG4gIH07XG4gIHByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihlbGFwc2VkVGltZSwgcGxheWVyWCl7XG4gICAgdGhpcy5ob3Jpem9udGFsRmFjaW5nID0gcGxheWVyWCA8IHRoaXMueCA/IExFRlQgOiBSSUdIVDtcbiAgICB0aGlzLmZsaWdodEFuZ2xlICs9IHRoaXMuYW5ndWxhclZlbG9jaXR5ICogZWxhcHNlZFRpbWU7XG4gICAgdGhpcy55ID0gdGhpcy5mbGlnaHRDZW50ZXJZICsgdW5pdHMudGlsZVRvR2FtZSg1KSAvIDIgKiBzdGQuc2luKHVuaXRzLmRlZ1RvUmFkKHRoaXMuZmxpZ2h0QW5nbGUpKTtcbiAgICB0aGlzLnNwcml0ZXNbdGhpcy5zcHJpdGVzdGF0ZV0udXBkYXRlKGVsYXBzZWRUaW1lKTtcbiAgICByZXR1cm4gdGhpcy5hbGl2ZTtcbiAgfTtcbiAgcHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihncmFwaGljcyl7XG4gICAgaWYgKGNvbmZpZy5zaG93Q29sbGlzaW9ucykge1xuICAgICAgZ3JhcGhpY3MudmlzdWFsaXNlUmVjdCh0aGlzLmNvbGxpc2lvblJlY3RhbmdsZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3ByaXRlc1t0aGlzLnNwcml0ZXN0YXRlXS5kcmF3KGdyYXBoaWNzLCB0aGlzLngsIHRoaXMueSk7XG4gIH07XG4gIHByb3RvdHlwZS5kYW1hZ2VDb2xsaXNpb24gPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBuZXcgUmVjdCh0aGlzLmNlbnRlclgsIHRoaXMuY2VudGVyWSwgMSwgMSk7XG4gIH07XG4gIHByb3RvdHlwZS5jb2xsaXNpb25SZWN0YW5nbGUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBuZXcgUmVjdCh0aGlzLngsIHRoaXMueSwgdGlsZVRvR2FtZSgxKSwgdGlsZVRvR2FtZSgxKSk7XG4gIH07XG4gIHByb3RvdHlwZS50YWtlRGFtYWdlID0gZnVuY3Rpb24oZGFtYWdlKXtcbiAgICB0aGlzLmRhbWFnZVRleHQuc2V0RGFtYWdlKGRhbWFnZSk7XG4gICAgcmV0dXJuIHRoaXMuYWxpdmUgPSBmYWxzZTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgJ2NlbnRlclgnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMueCArIGtIYWxmVGlsZTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCAnY2VudGVyWScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy55ICsga0hhbGZUaWxlO1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG4gIHByb3RvdHlwZS5nZXREYW1hZ2VUZXh0ID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5kYW1hZ2VUZXh0O1xuICB9O1xuICByZXR1cm4gRmlyc3RDYXZlQmF0O1xufShEYW1hZ2VhYmxlKSk7XG5mdW5jdGlvbiBleHRlbmQkKHN1Yiwgc3VwKXtcbiAgZnVuY3Rpb24gZnVuKCl7fSBmdW4ucHJvdG90eXBlID0gKHN1Yi5zdXBlcmNsYXNzID0gc3VwKS5wcm90b3R5cGU7XG4gIChzdWIucHJvdG90eXBlID0gbmV3IGZ1bikuY29uc3RydWN0b3IgPSBzdWI7XG4gIGlmICh0eXBlb2Ygc3VwLmV4dGVuZGVkID09ICdmdW5jdGlvbicpIHN1cC5leHRlbmRlZChzdWIpO1xuICByZXR1cm4gc3ViO1xufVxuZnVuY3Rpb24gaW1wb3J0JChvYmosIHNyYyl7XG4gIHZhciBvd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbiAgZm9yICh2YXIga2V5IGluIHNyYykgaWYgKG93bi5jYWxsKHNyYywga2V5KSkgb2JqW2tleV0gPSBzcmNba2V5XTtcbiAgcmV0dXJuIG9iajtcbn0iLCJ2YXIgc3RkLCBTREwsIGlucHV0LCB1bml0cywgY29uZmlnLCByZWFkb3V0LCBncmFwaGljcywgTWFwLCB0aWxlVG9HYW1lLCBUaW1lciwgUGxheWVyLCBSZWN0YW5nbGUsIEZpcnN0Q2F2ZUJhdCwgRml4ZWRCYWNrZHJvcCwgRGFtYWdlVGV4dHMsIHJlZiQsIFBhcnRpY2xlVG9vbHMsIFBhcnRpY2xlU3lzdGVtLCBTdGFyUGFydGljbGUsIERlYXRoQ2xvdWRQYXJ0aWNsZSwgR3VuRXhwZXJpZW5jZUhVRCwga1NjcmVlbldpZHRoLCBrU2NyZWVuSGVpZ2h0LCBrRnBzLCBrTWF4RnJhbWVUaW1lLCBrRGVidWdNb2RlLCBydW5uaW5nLCBwbGF5ZXIsIGJhdCwgbWFwLCBwdG9vbHMsIHhwSHVkLCB0aW1lRmFjdG9yLCBsYXN0RnJhbWVUaW1lLCBhbnlLZXlzUHJlc3NlZCwgZXZlbnRMb29wLCB1cGRhdGUsIGRyYXcsIGNyZWF0ZVRlc3RXb3JsZCwgc3RhcnQsIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5zdGQgPSByZXF1aXJlKCdzdGQnKTtcblNETCA9IHJlcXVpcmUoJ1NETCcpO1xuaW5wdXQgPSByZXF1aXJlKCcuL2lucHV0Jyk7XG51bml0cyA9IHJlcXVpcmUoJy4vdW5pdHMnKTtcbmNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5yZWFkb3V0ID0gcmVxdWlyZSgnLi9yZWFkb3V0Jyk7XG5ncmFwaGljcyA9IHJlcXVpcmUoJy4vZ3JhcGhpY3MnKTtcbk1hcCA9IHJlcXVpcmUoJy4vbWFwJyk7XG50aWxlVG9HYW1lID0gdW5pdHMudGlsZVRvR2FtZTtcblRpbWVyID0gcmVxdWlyZSgnLi90aW1lcicpLlRpbWVyO1xuUGxheWVyID0gcmVxdWlyZSgnLi9wbGF5ZXInKS5QbGF5ZXI7XG5SZWN0YW5nbGUgPSByZXF1aXJlKCcuL3JlY3RhbmdsZScpLlJlY3RhbmdsZTtcbkZpcnN0Q2F2ZUJhdCA9IHJlcXVpcmUoJy4vZmlyc3QtY2F2ZS1iYXQnKS5GaXJzdENhdmVCYXQ7XG5GaXhlZEJhY2tkcm9wID0gcmVxdWlyZSgnLi9iYWNrZHJvcCcpLkZpeGVkQmFja2Ryb3A7XG5EYW1hZ2VUZXh0cyA9IHJlcXVpcmUoJy4vZGFtYWdlLXRleHRzJykuRGFtYWdlVGV4dHM7XG5yZWYkID0gcmVxdWlyZSgnLi9wYXJ0aWNsZS1zeXN0ZW0nKSwgUGFydGljbGVUb29scyA9IHJlZiQuUGFydGljbGVUb29scywgUGFydGljbGVTeXN0ZW0gPSByZWYkLlBhcnRpY2xlU3lzdGVtO1xuU3RhclBhcnRpY2xlID0gcmVxdWlyZSgnLi9zdGFyLXBhcnRpY2xlJykuU3RhclBhcnRpY2xlO1xuRGVhdGhDbG91ZFBhcnRpY2xlID0gcmVxdWlyZSgnLi9kZWF0aC1jbG91ZC1wYXJ0aWNsZScpLkRlYXRoQ2xvdWRQYXJ0aWNsZTtcbkd1bkV4cGVyaWVuY2VIVUQgPSByZXF1aXJlKCcuL2d1bi14cC1odWQnKS5HdW5FeHBlcmllbmNlSFVEO1xua1NjcmVlbldpZHRoID0gY29uZmlnLmtTY3JlZW5XaWR0aCwga1NjcmVlbkhlaWdodCA9IGNvbmZpZy5rU2NyZWVuSGVpZ2h0LCBrRnBzID0gY29uZmlnLmtGcHMsIGtNYXhGcmFtZVRpbWUgPSBjb25maWcua01heEZyYW1lVGltZSwga0RlYnVnTW9kZSA9IGNvbmZpZy5rRGVidWdNb2RlO1xucnVubmluZyA9IHRydWU7XG5wbGF5ZXIgPSBudWxsO1xuYmF0ID0gbnVsbDtcbm1hcCA9IG51bGw7XG5wdG9vbHMgPSBudWxsO1xueHBIdWQgPSBudWxsO1xudGltZUZhY3RvciA9IDE7XG5sYXN0RnJhbWVUaW1lID0gMDtcbmFueUtleXNQcmVzc2VkID0gZmFsc2U7XG5ldmVudExvb3AgPSBmdW5jdGlvbigpe1xuICB2YXIgc3RhcnRUaW1lLCBldmVudCwgzpR0LCBlbGFwc2VkVGltZTtcbiAgc3RhcnRUaW1lID0gU0RMLmdldFRpY2tzKCk7XG4gIGlucHV0LmJlZ2luTmV3RnJhbWUoKTtcbiAgd2hpbGUgKGV2ZW50ID0gU0RMLnBvbGxFdmVudCgpKSB7XG4gICAgYW55S2V5c1ByZXNzZWQgPSB0cnVlO1xuICAgIHJlYWRvdXQudXBkYXRlKCd3aWxsc3RvcCcsIGZhbHNlKTtcbiAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICBjYXNlIFNETC5LRVlET1dOOlxuICAgICAgaW5wdXQua2V5RG93bkV2ZW50KGV2ZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU0RMLktFWVVQOlxuICAgICAgaW5wdXQua2V5VXBFdmVudChldmVudCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogXCJVbmtub3duIGV2ZW50IHR5cGU6IFwiICsgZXZlbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoaW5wdXQud2FzS2V5UHJlc3NlZChTREwuS0VZLkVTQ0FQRSkpIHtcbiAgICBydW5uaW5nID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlucHV0LmlzS2V5SGVsZChTREwuS0VZLkxFRlQpICYmIGlucHV0LmlzS2V5SGVsZChTREwuS0VZLlJJR0hUKSkge1xuICAgIHBsYXllci5zdG9wTW92aW5nKCk7XG4gIH0gZWxzZSBpZiAoaW5wdXQuaXNLZXlIZWxkKFNETC5LRVkuTEVGVCkpIHtcbiAgICBwbGF5ZXIuc3RhcnRNb3ZpbmdMZWZ0KCk7XG4gIH0gZWxzZSBpZiAoaW5wdXQuaXNLZXlIZWxkKFNETC5LRVkuUklHSFQpKSB7XG4gICAgcGxheWVyLnN0YXJ0TW92aW5nUmlnaHQoKTtcbiAgfSBlbHNlIHtcbiAgICBwbGF5ZXIuc3RvcE1vdmluZygpO1xuICB9XG4gIGlmIChpbnB1dC53YXNLZXlQcmVzc2VkKFNETC5LRVkuWikpIHtcbiAgICBwbGF5ZXIuc3RhcnRKdW1wKCk7XG4gIH0gZWxzZSBpZiAoaW5wdXQud2FzS2V5UmVsZWFzZWQoU0RMLktFWS5aKSkge1xuICAgIHBsYXllci5zdG9wSnVtcCgpO1xuICB9XG4gIGlmIChpbnB1dC53YXNLZXlQcmVzc2VkKFNETC5LRVkuWCkpIHtcbiAgICBwbGF5ZXIuc3RhcnRGaXJlKCk7XG4gIH0gZWxzZSBpZiAoaW5wdXQud2FzS2V5UmVsZWFzZWQoU0RMLktFWS5YKSkge1xuICAgIHBsYXllci5zdG9wRmlyZSgpO1xuICB9XG4gIGlmIChpbnB1dC5pc0tleUhlbGQoU0RMLktFWS5VUCkgJiYgaW5wdXQuaXNLZXlIZWxkKFNETC5LRVkuRE9XTikpIHtcbiAgICBwbGF5ZXIubG9va0hvcml6b250YWwoKTtcbiAgfSBlbHNlIGlmIChpbnB1dC5pc0tleUhlbGQoU0RMLktFWS5VUCkpIHtcbiAgICBwbGF5ZXIubG9va1VwKCk7XG4gIH0gZWxzZSBpZiAoaW5wdXQuaXNLZXlIZWxkKFNETC5LRVkuRE9XTikpIHtcbiAgICBwbGF5ZXIubG9va0Rvd24oKTtcbiAgfSBlbHNlIHtcbiAgICBwbGF5ZXIubG9va0hvcml6b250YWwoKTtcbiAgfVxuICBpZiAoaW5wdXQud2FzS2V5UHJlc3NlZChTREwuS0VZLk9ORSkpIHtcbiAgICB0aW1lRmFjdG9yID0gMTtcbiAgfVxuICBpZiAoaW5wdXQud2FzS2V5UHJlc3NlZChTREwuS0VZLlRXTykpIHtcbiAgICB0aW1lRmFjdG9yID0gMjtcbiAgfVxuICBpZiAoaW5wdXQud2FzS2V5UHJlc3NlZChTREwuS0VZLlRIUkVFKSkge1xuICAgIHRpbWVGYWN0b3IgPSAzO1xuICB9XG4gIGlmIChpbnB1dC53YXNLZXlQcmVzc2VkKFNETC5LRVkuRk9VUikpIHtcbiAgICB0aW1lRmFjdG9yID0gNDtcbiAgfVxuICDOlHQgPSBzdGQubWluKFNETC5nZXRUaWNrcygpIC0gbGFzdEZyYW1lVGltZSwga01heEZyYW1lVGltZSk7XG4gIHVwZGF0ZSjOlHQgLyB0aW1lRmFjdG9yKTtcbiAgZHJhdygpO1xuICBpZiAocnVubmluZykge1xuICAgIGxhc3RGcmFtZVRpbWUgPSBTREwuZ2V0VGlja3MoKTtcbiAgICBlbGFwc2VkVGltZSA9IGxhc3RGcmFtZVRpbWUgLSBzdGFydFRpbWU7XG4gICAgcmVhZG91dC51cGRhdGUoJ2ZyYW1ldGltZScsIHN0ZC5mbG9vcigxMDAwIC8gzpR0KSk7XG4gICAgcmVhZG91dC51cGRhdGUoJ2RyYXd0aW1lJywgZWxhcHNlZFRpbWUpO1xuICAgIHJldHVybiBTREwuZGVsYXkoMTAwMCAvIGtGcHMgLSBlbGFwc2VkVGltZSwgZXZlbnRMb29wKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RkLmxvZygnR2FtZSBzdG9wcGVkLicpO1xuICB9XG59O1xudXBkYXRlID0gZnVuY3Rpb24oZWxhcHNlZFRpbWUpe1xuICB2YXIgaSQsIHJlZiQsIGxlbiQsIHByb2plY3RpbGU7XG4gIFRpbWVyLnVwZGF0ZUFsbChlbGFwc2VkVGltZSk7XG4gIHBsYXllci51cGRhdGUoZWxhcHNlZFRpbWUsIG1hcCwgcHRvb2xzKTtcbiAgaWYgKGJhdCAmJiAhKGJhdCAhPSBudWxsICYmIGJhdC51cGRhdGUoZWxhcHNlZFRpbWUsIHBsYXllci54KSkpIHtcbiAgICBEZWF0aENsb3VkUGFydGljbGUuY3JlYXRlUmFuZG9tRGVhdGhDbG91ZHMocHRvb2xzLCBiYXQuY2VudGVyWCwgYmF0LmNlbnRlclksIDMpO1xuICAgIGJhdCA9IG51bGw7XG4gIH1cbiAgZm9yIChpJCA9IDAsIGxlbiQgPSAocmVmJCA9IHBsYXllci5nZXRQcm9qZWN0aWxlcygpKS5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHByb2plY3RpbGUgPSByZWYkW2kkXTtcbiAgICBpZiAoYmF0ICE9IG51bGwgJiYgYmF0LmNvbGxpc2lvblJlY3RhbmdsZSgpLmNvbGxpZGVzV2l0aChwcm9qZWN0aWxlLmNvbGxpc2lvblJlY3RhbmdsZSgpKSkge1xuICAgICAgcHJvamVjdGlsZS5jb2xsaWRlV2l0aEVuZW15KCk7XG4gICAgICBiYXQudGFrZURhbWFnZShwcm9qZWN0aWxlLmNvbnRhY3REYW1hZ2UpO1xuICAgIH1cbiAgfVxuICBpZiAoYmF0ICE9IG51bGwgJiYgYmF0LmRhbWFnZUNvbGxpc2lvbigpLmNvbGxpZGVzV2l0aChwbGF5ZXIuZGFtYWdlQ29sbGlzaW9uKCkpKSB7XG4gICAgcGxheWVyLnRha2VEYW1hZ2UoYmF0LmNvbnRhY3REYW1hZ2UpO1xuICB9XG4gIERhbWFnZVRleHRzLnVwZGF0ZShlbGFwc2VkVGltZSk7XG4gIHJldHVybiBwdG9vbHMudXBkYXRlKGVsYXBzZWRUaW1lKTtcbn07XG5kcmF3ID0gZnVuY3Rpb24oKXtcbiAgZ3JhcGhpY3MuY2xlYXIoKTtcbiAgbWFwLmRyYXdCYWNrZ3JvdW5kKGdyYXBoaWNzKTtcbiAgaWYgKGJhdCAhPSBudWxsKSB7XG4gICAgYmF0LmRyYXcoZ3JhcGhpY3MpO1xuICB9XG4gIHBsYXllci5kcmF3KGdyYXBoaWNzKTtcbiAgcHRvb2xzLmVudGl0eVN5c3RlbS5kcmF3KGdyYXBoaWNzKTtcbiAgbWFwLmRyYXcoZ3JhcGhpY3MpO1xuICBwbGF5ZXIuZHJhd0h1ZChncmFwaGljcyk7XG4gIHB0b29scy5mcm9udFN5c3RlbS5kcmF3KGdyYXBoaWNzKTtcbiAgRGFtYWdlVGV4dHMuZHJhdyhncmFwaGljcyk7XG4gIHJldHVybiB4cEh1ZC5kcmF3KGdyYXBoaWNzLCAyKTtcbn07XG5jcmVhdGVUZXN0V29ybGQgPSBmdW5jdGlvbigpe1xuICBtYXAgPSBNYXAuY3JlYXRlVGVzdE1hcChncmFwaGljcyk7XG4gIHBsYXllciA9IG5ldyBQbGF5ZXIoZ3JhcGhpY3MsIHVuaXRzLnRpbGVUb0dhbWUoa1NjcmVlbldpZHRoIC8gMiksIHVuaXRzLnRpbGVUb0dhbWUoMTApKTtcbiAgYmF0ID0gbmV3IEZpcnN0Q2F2ZUJhdChncmFwaGljcywgdW5pdHMudGlsZVRvR2FtZSg3KSwgdW5pdHMudGlsZVRvR2FtZSg4KSk7XG4gIHB0b29scyA9IG5ldyBQYXJ0aWNsZVRvb2xzKGdyYXBoaWNzKTtcbiAgcmV0dXJuIHhwSHVkID0gbmV3IEd1bkV4cGVyaWVuY2VIVUQoZ3JhcGhpY3MpO1xufTtcbm91dCQuc3RhcnQgPSBzdGFydCA9IGZ1bmN0aW9uKCl7XG4gIFNETC5pbml0KFNETC5JTklUX0VWRVJZVEhJTkcpO1xuICByZWFkb3V0LmFkZFJlYWRlcignZnJhbWV0aW1lJywgJ0ZyYW1lIHRpbWUnKTtcbiAgcmVhZG91dC5hZGRSZWFkZXIoJ2RyYXd0aW1lJywgJ0RyYXcgdGltZScpO1xuICByZWFkb3V0LmFkZFJlYWRlcignd2lsbHN0b3AnLCAnV2lsbCBzdG9wJywgdHJ1ZSk7XG4gIGNyZWF0ZVRlc3RXb3JsZCgpO1xuICBldmVudExvb3AoKTtcbiAgcmV0dXJuIHN0ZC5kZWxheSg1MDAwLCBmdW5jdGlvbigpe1xuICAgIGlmICghYW55S2V5c1ByZXNzZWQpIHtcbiAgICAgIHJldHVybiBydW5uaW5nID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdGQubG9nKFwiR2FtZSBiZWluZyBpbnRlcmFjdGVkIHdpdGguIERvbid0IHNodXQgZG93blwiKTtcbiAgICB9XG4gIH0pO1xufTsiLCJ2YXIgc3RkLCBTREwsIGNvbmZpZywgdW5pdHMsIGtTY3JlZW5XaWR0aCwga1NjcmVlbkhlaWdodCwga1RyYW5zcGFyZW50Q29sb3IsIGtTY3JlZW5TY2FsZUZhY3Rvciwgc3ByaXRlc2hlZXRzLCBzY3JlZW4sIGxvYWRJbWFnZSwgYmxpdFN1cmZhY2UsIGNsZWFyLCB2aXN1YWxpc2VSZWN0LCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG5TREwgPSByZXF1aXJlKCdTREwnKTtcbmNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG51bml0cyA9IHJlcXVpcmUoJy4vdW5pdHMnKTtcbmtTY3JlZW5XaWR0aCA9IGNvbmZpZy5rU2NyZWVuV2lkdGgsIGtTY3JlZW5IZWlnaHQgPSBjb25maWcua1NjcmVlbkhlaWdodDtcbmtUcmFuc3BhcmVudENvbG9yID0gWzAsIDAsIDBdO1xua1NjcmVlblNjYWxlRmFjdG9yID0gY29uZmlnLmtHcmFwaGljc1F1YWxpdHkgPT09IDE2ID8gMiA6IDE7XG5zcHJpdGVzaGVldHMgPSB7fTtcbnNjcmVlbiA9IFNETC5zZXRWaWRlb01vZGUodW5pdHMudGlsZVRvUHgoa1NjcmVlbldpZHRoKSwgdW5pdHMudGlsZVRvUHgoa1NjcmVlbkhlaWdodCksIGtTY3JlZW5TY2FsZUZhY3Rvcik7XG5vdXQkLmxvYWRJbWFnZSA9IGxvYWRJbWFnZSA9IGZ1bmN0aW9uKGZpbGVuYW1lLCB1c2VUcmFuc3BhcmVuY3kpe1xuICB1c2VUcmFuc3BhcmVuY3kgPT0gbnVsbCAmJiAodXNlVHJhbnNwYXJlbmN5ID0gZmFsc2UpO1xuICBpZiAoc3ByaXRlc2hlZXRzW2ZpbGVuYW1lXSA9PSBudWxsKSB7XG4gICAgc3ByaXRlc2hlZXRzW2ZpbGVuYW1lXSA9IFNETC5sb2FkSW1hZ2UoY29uZmlnLmZpbmRBc3NldChmaWxlbmFtZSkpO1xuICAgIGlmICh1c2VUcmFuc3BhcmVuY3kpIHtcbiAgICAgIFNETC5zZXRDb2xvcktleShzcHJpdGVzaGVldHNbZmlsZW5hbWVdLCBrVHJhbnNwYXJlbnRDb2xvcik7XG4gICAgfVxuICAgIGlmIChjb25maWcuc2hvd1Nwcml0ZXNoZWV0cykge1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzcHJpdGVzaGVldHNbZmlsZW5hbWVdLmNhbnZhcyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzcHJpdGVzaGVldHNbZmlsZW5hbWVdO1xufTtcbm91dCQuYmxpdFN1cmZhY2UgPSBibGl0U3VyZmFjZSA9IGZ1bmN0aW9uKHNvdXJjZSwgc3JjUmVjdCwgZGVzdFJlY3Qpe1xuICByZXR1cm4gU0RMLmJsaXRTdXJmYWNlKHNvdXJjZSwgc3JjUmVjdCwgc2NyZWVuLCBkZXN0UmVjdCk7XG59O1xub3V0JC5jbGVhciA9IGNsZWFyID0gYmluZCQoc2NyZWVuLCAnY2xlYXInKTtcbm91dCQudmlzdWFsaXNlUmVjdCA9IHZpc3VhbGlzZVJlY3QgPSBmdW5jdGlvbihyZWN0LCBmaWxsKXtcbiAgdmFyIHBhaW50UmVjdDtcbiAgcGFpbnRSZWN0ID0gbmV3IFNETC5SZWN0KHVuaXRzLmdhbWVUb1B4KHJlY3QubGVmdCksIHVuaXRzLmdhbWVUb1B4KHJlY3QudG9wKSwgdW5pdHMuZ2FtZVRvUHgocmVjdC53KSwgdW5pdHMuZ2FtZVRvUHgocmVjdC5oKSk7XG4gIGlmIChmaWxsKSB7XG4gICAgcmV0dXJuIHNjcmVlbi5kcmF3UmVjdChwYWludFJlY3QsICdyZWQnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2NyZWVuLmRyYXdCb3gocGFpbnRSZWN0LCAncmVkJyk7XG4gIH1cbn07XG5mdW5jdGlvbiBiaW5kJChvYmosIGtleSwgdGFyZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiAodGFyZ2V0IHx8IG9iailba2V5XS5hcHBseShvYmosIGFyZ3VtZW50cykgfTtcbn0iLCJ2YXIgc3RkLCB1bml0cywgdGlsZVRvR2FtZSwgdGlsZVRvUHgsIGdhbWVUb1B4LCBrSGFsZlRpbGUsIFNwcml0ZVNvdXJjZSwgcmVmJCwgU3ByaXRlLCBOdW1iZXJTcHJpdGUsIFZhcnlpbmdXaWR0aFNwcml0ZSwga0RyYXdZLCBrTHZEcmF3WCwga0JhckRyYXdYLCBrTHZsTnVtRHJhd1gsIGtTcHJpdGVOYW1lLCBrQmFyU3JjLCBrTHZTcmMsIEd1bkV4cGVyaWVuY2VIVUQsIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5zdGQgPSByZXF1aXJlKCdzdGQnKTtcbnVuaXRzID0gcmVxdWlyZSgnLi91bml0cycpO1xudGlsZVRvR2FtZSA9IHVuaXRzLnRpbGVUb0dhbWUsIHRpbGVUb1B4ID0gdW5pdHMudGlsZVRvUHgsIGdhbWVUb1B4ID0gdW5pdHMuZ2FtZVRvUHgsIGtIYWxmVGlsZSA9IHVuaXRzLmtIYWxmVGlsZTtcblNwcml0ZVNvdXJjZSA9IHJlcXVpcmUoJy4vcmVjdGFuZ2xlJykuU3ByaXRlU291cmNlO1xucmVmJCA9IHJlcXVpcmUoJy4vc3ByaXRlJyksIFNwcml0ZSA9IHJlZiQuU3ByaXRlLCBOdW1iZXJTcHJpdGUgPSByZWYkLk51bWJlclNwcml0ZSwgVmFyeWluZ1dpZHRoU3ByaXRlID0gcmVmJC5WYXJ5aW5nV2lkdGhTcHJpdGU7XG5rRHJhd1kgPSB0aWxlVG9HYW1lKDEuNSk7XG5rTHZEcmF3WCA9IHRpbGVUb0dhbWUoMS4wKTtcbmtCYXJEcmF3WCA9IHRpbGVUb0dhbWUoMi41KTtcbmtMdmxOdW1EcmF3WCA9IHRpbGVUb0dhbWUoMi4wKTtcbmtTcHJpdGVOYW1lID0gJ1RleHRCb3gnO1xua0JhclNyYyA9IG5ldyBTcHJpdGVTb3VyY2UoMCwgNC41LCAyLjUsIDAuNSk7XG5rTHZTcmMgPSB7XG4gIHg6IHRpbGVUb1B4KDUpLFxuICB5OiBnYW1lVG9QeCgxNjApLFxuICB3OiB0aWxlVG9QeCgxKSxcbiAgaDogdGlsZVRvUHgoMC41KVxufTtcbm91dCQuR3VuRXhwZXJpZW5jZUhVRCA9IEd1bkV4cGVyaWVuY2VIVUQgPSAoZnVuY3Rpb24oKXtcbiAgR3VuRXhwZXJpZW5jZUhVRC5kaXNwbGF5TmFtZSA9ICdHdW5FeHBlcmllbmNlSFVEJztcbiAgdmFyIHByb3RvdHlwZSA9IEd1bkV4cGVyaWVuY2VIVUQucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IEd1bkV4cGVyaWVuY2VIVUQ7XG4gIGZ1bmN0aW9uIEd1bkV4cGVyaWVuY2VIVUQoZ3JhcGhpY3Mpe1xuICAgIHRoaXMueHBCYXJTcHJpdGUgPSBuZXcgU3ByaXRlKGdyYXBoaWNzLCBrU3ByaXRlTmFtZSwga0JhclNyYyk7XG4gICAgdGhpcy5sdlNwcml0ZSA9IG5ldyBTcHJpdGUoZ3JhcGhpY3MsIGtTcHJpdGVOYW1lLCBrTHZTcmMpO1xuICB9XG4gIHByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZ3JhcGhpY3MsIGd1bkx2bCl7XG4gICAgdmFyIGx2bE51bVNwcml0ZTtcbiAgICB0aGlzLmx2U3ByaXRlLmRyYXcoZ3JhcGhpY3MsIGtMdkRyYXdYLCBrRHJhd1kpO1xuICAgIHRoaXMueHBCYXJTcHJpdGUuZHJhdyhncmFwaGljcywga0JhckRyYXdYLCBrRHJhd1kpO1xuICAgIGx2bE51bVNwcml0ZSA9IE51bWJlclNwcml0ZS5IVUROdW1iZXIoZ3JhcGhpY3MsIGd1bkx2bCwgMSk7XG4gICAgcmV0dXJuIGx2bE51bVNwcml0ZS5kcmF3KGdyYXBoaWNzLCBrTHZsTnVtRHJhd1gsIGtEcmF3WSk7XG4gIH07XG4gIHJldHVybiBHdW5FeHBlcmllbmNlSFVEO1xufSgpKTsiLCJ2YXIgc3RkLCB1bml0cywgcHgsIFRpbWVyLCBQYXJ0aWNsZSwgU3ByaXRlLCBQb2xhclZlY3RvciwgUmVjdGFuZ2xlLCBrU3ByaXRlU3JjLCBrRmxhc2hQZXJpb2QsIGtMaWZlVGltZSwga1NwZWVkLCBIZWFkQnVtcFBhcnRpY2xlLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG51bml0cyA9IHJlcXVpcmUoJy4vdW5pdHMnKTtcbnB4ID0gdW5pdHMuZ2FtZVRvUHg7XG5UaW1lciA9IHJlcXVpcmUoJy4vdGltZXInKS5UaW1lcjtcblBhcnRpY2xlID0gcmVxdWlyZSgnLi9wYXJ0aWNsZScpLlBhcnRpY2xlO1xuU3ByaXRlID0gcmVxdWlyZSgnLi9zcHJpdGUnKS5TcHJpdGU7XG5Qb2xhclZlY3RvciA9IHJlcXVpcmUoJy4vcG9sYXInKS5Qb2xhclZlY3RvcjtcblJlY3RhbmdsZSA9IHJlcXVpcmUoJy4vcmVjdGFuZ2xlJykuUmVjdGFuZ2xlO1xua1Nwcml0ZVNyYyA9IG5ldyBSZWN0YW5nbGUocHgoMTE2KSwgcHgoNTQpLCBweCg2KSwgcHgoNikpO1xua0ZsYXNoUGVyaW9kID0gMjU7XG5rTGlmZVRpbWUgPSA3MDA7XG5rU3BlZWQgPSAwLjEyO1xub3V0JC5IZWFkQnVtcFBhcnRpY2xlID0gSGVhZEJ1bXBQYXJ0aWNsZSA9IChmdW5jdGlvbihzdXBlcmNsYXNzKXtcbiAgdmFyIHByb3RvdHlwZSA9IGV4dGVuZCQoKGltcG9ydCQoSGVhZEJ1bXBQYXJ0aWNsZSwgc3VwZXJjbGFzcykuZGlzcGxheU5hbWUgPSAnSGVhZEJ1bXBQYXJ0aWNsZScsIEhlYWRCdW1wUGFydGljbGUpLCBzdXBlcmNsYXNzKS5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gSGVhZEJ1bXBQYXJ0aWNsZTtcbiAgZnVuY3Rpb24gSGVhZEJ1bXBQYXJ0aWNsZShncmFwaGljcywgY2VudGVyWCwgY2VudGVyWSl7XG4gICAgdGhpcy5jZW50ZXJYID0gY2VudGVyWDtcbiAgICB0aGlzLmNlbnRlclkgPSBjZW50ZXJZO1xuICAgIHRoaXMubGlmZVRpbWVyID0gbmV3IFRpbWVyKGtMaWZlVGltZSwgdHJ1ZSk7XG4gICAgdGhpcy5wYXJ0aWNsZUEgPSBuZXcgUG9sYXJWZWN0b3IoMCwgc3RkLnJhbmQoMCwgc3RkLnRhdSkpO1xuICAgIHRoaXMucGFydGljbGVCID0gbmV3IFBvbGFyVmVjdG9yKDAsIHN0ZC5yYW5kKDAsIHN0ZC50YXUpKTtcbiAgICB0aGlzLm1heE9mZnNldEEgPSBzdGQuZmxvb3Ioc3RkLnJhbmQoNCwgMjApKTtcbiAgICB0aGlzLm1heE9mZnNldEIgPSBzdGQuZmxvb3Ioc3RkLnJhbmQoNCwgMjApKTtcbiAgICB0aGlzLnNwcml0ZSA9IG5ldyBTcHJpdGUoZ3JhcGhpY3MsICdDYXJldCcsIGtTcHJpdGVTcmMpO1xuICB9XG4gIHByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihlbGFwc2VkVGltZSl7XG4gICAgdGhpcy5wYXJ0aWNsZUEubWFnID0gc3RkLm1pbih0aGlzLm1heE9mZnNldEEsIHRoaXMucGFydGljbGVBLm1hZyArIGVsYXBzZWRUaW1lICoga1NwZWVkKTtcbiAgICB0aGlzLnBhcnRpY2xlQi5tYWcgPSBzdGQubWluKHRoaXMubWF4T2Zmc2V0QiwgdGhpcy5wYXJ0aWNsZUIubWFnICsgZWxhcHNlZFRpbWUgKiBrU3BlZWQpO1xuICAgIHJldHVybiB0aGlzLmxpZmVUaW1lci5hY3RpdmUoKTtcbiAgfTtcbiAgcHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihncmFwaGljcyl7XG4gICAgaWYgKCh0aGlzLmxpZmVUaW1lci5jdXJyZW50VGltZSAvIGtGbGFzaFBlcmlvZCkgJSAyIDwgMSkge1xuICAgICAgdGhpcy5zcHJpdGUuZHJhdyhncmFwaGljcywgdGhpcy5jZW50ZXJYICsgdGhpcy5wYXJ0aWNsZUEueCwgdGhpcy5jZW50ZXJZICsgdGhpcy5wYXJ0aWNsZUEueSk7XG4gICAgICByZXR1cm4gdGhpcy5zcHJpdGUuZHJhdyhncmFwaGljcywgdGhpcy5jZW50ZXJYICsgdGhpcy5wYXJ0aWNsZUIueCwgdGhpcy5jZW50ZXJZICsgdGhpcy5wYXJ0aWNsZUIueSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gSGVhZEJ1bXBQYXJ0aWNsZTtcbn0oUGFydGljbGUpKTtcbmZ1bmN0aW9uIGV4dGVuZCQoc3ViLCBzdXApe1xuICBmdW5jdGlvbiBmdW4oKXt9IGZ1bi5wcm90b3R5cGUgPSAoc3ViLnN1cGVyY2xhc3MgPSBzdXApLnByb3RvdHlwZTtcbiAgKHN1Yi5wcm90b3R5cGUgPSBuZXcgZnVuKS5jb25zdHJ1Y3RvciA9IHN1YjtcbiAgaWYgKHR5cGVvZiBzdXAuZXh0ZW5kZWQgPT0gJ2Z1bmN0aW9uJykgc3VwLmV4dGVuZGVkKHN1Yik7XG4gIHJldHVybiBzdWI7XG59XG5mdW5jdGlvbiBpbXBvcnQkKG9iaiwgc3JjKXtcbiAgdmFyIG93biA9IHt9Lmhhc093blByb3BlcnR5O1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSBpZiAob3duLmNhbGwoc3JjLCBrZXkpKSBvYmpba2V5XSA9IHNyY1trZXldO1xuICByZXR1cm4gb2JqO1xufSIsInZhciBzdGQsIHVuaXRzLCBkaXYsIGtIYWxmVGlsZSwgcHhUb1RpbGUsIHRpbGVUb1B4LCBweFRvR2FtZSwgdGlsZVRvR2FtZSwgVGltZXIsIFNwcml0ZVNvdXJjZSwgcmVmJCwgU3ByaXRlLCBOdW1iZXJTcHJpdGUsIFZhcnlpbmdXaWR0aFNwcml0ZSwga0hlYWx0aEJhclgsIGtIZWFsdGhCYXJZLCBrSGVhbHRoRmlsbFgsIGtIZWFsdGhGaWxsWSwga0hlYWx0aE51bVgsIGtIZWFsdGhOdW1ZLCBrTWF4RmlsbFB4LCBrTWF4RmlsbCwga0RhbWFnZURlbGF5LCBrU3ByaXRlUGF0aCwga0hlYWx0aEJhclNyYywga0hlYWx0aEZpbGxTcmMsIGtEYW1hZ2VGaWxsU3JjLCBIZWFsdGgsIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5zdGQgPSByZXF1aXJlKCdzdGQnKTtcbnVuaXRzID0gcmVxdWlyZSgnLi91bml0cycpO1xuZGl2ID0gc3RkLmRpdjtcbmtIYWxmVGlsZSA9IHVuaXRzLmtIYWxmVGlsZSwgcHhUb1RpbGUgPSB1bml0cy5weFRvVGlsZSwgdGlsZVRvUHggPSB1bml0cy50aWxlVG9QeCwgcHhUb0dhbWUgPSB1bml0cy5weFRvR2FtZSwgdGlsZVRvR2FtZSA9IHVuaXRzLnRpbGVUb0dhbWU7XG5UaW1lciA9IHJlcXVpcmUoJy4vdGltZXInKS5UaW1lcjtcblNwcml0ZVNvdXJjZSA9IHJlcXVpcmUoJy4vcmVjdGFuZ2xlJykuU3ByaXRlU291cmNlO1xucmVmJCA9IHJlcXVpcmUoJy4vc3ByaXRlJyksIFNwcml0ZSA9IHJlZiQuU3ByaXRlLCBOdW1iZXJTcHJpdGUgPSByZWYkLk51bWJlclNwcml0ZSwgVmFyeWluZ1dpZHRoU3ByaXRlID0gcmVmJC5WYXJ5aW5nV2lkdGhTcHJpdGU7XG5rSGVhbHRoQmFyWCA9IHRpbGVUb0dhbWUoMSk7XG5rSGVhbHRoQmFyWSA9IHRpbGVUb0dhbWUoMik7XG5rSGVhbHRoRmlsbFggPSB0aWxlVG9HYW1lKDIuNSk7XG5rSGVhbHRoRmlsbFkgPSB0aWxlVG9HYW1lKDIpO1xua0hlYWx0aE51bVggPSB0aWxlVG9HYW1lKDEuNSk7XG5rSGVhbHRoTnVtWSA9IHRpbGVUb0dhbWUoMik7XG5rTWF4RmlsbFB4ID0gdGlsZVRvUHgoMi41KSAtIDE7XG5rTWF4RmlsbCA9IHB4VG9UaWxlKGtNYXhGaWxsUHgpO1xua0RhbWFnZURlbGF5ID0gMTUwMDtcbmtTcHJpdGVQYXRoID0gJ1RleHRCb3gnO1xua0hlYWx0aEJhclNyYyA9IG5ldyBTcHJpdGVTb3VyY2UoMCwgMi41LCA0LCAwLjUpO1xua0hlYWx0aEZpbGxTcmMgPSBuZXcgU3ByaXRlU291cmNlKDAsIDEuNSwga01heEZpbGwsIDAuNSk7XG5rRGFtYWdlRmlsbFNyYyA9IG5ldyBTcHJpdGVTb3VyY2UoMCwgMi4wLCBrTWF4RmlsbCwgMC41KTtcbm91dCQuSGVhbHRoID0gSGVhbHRoID0gKGZ1bmN0aW9uKCl7XG4gIEhlYWx0aC5kaXNwbGF5TmFtZSA9ICdIZWFsdGgnO1xuICB2YXIgcHJvdG90eXBlID0gSGVhbHRoLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBIZWFsdGg7XG4gIGZ1bmN0aW9uIEhlYWx0aChncmFwaGljcywgbWF4SGVhbHRoKXtcbiAgICB0aGlzLm1heEhlYWx0aCA9IG1heEhlYWx0aCAhPSBudWxsID8gbWF4SGVhbHRoIDogNjtcbiAgICB0aGlzLmN1cnJlbnRIZWFsdGggPSB0aGlzLm1heEhlYWx0aDtcbiAgICB0aGlzLmRhbWFnZSA9IDA7XG4gICAgdGhpcy5kYW1hZ2VUaW1lciA9IG5ldyBUaW1lcihrRGFtYWdlRGVsYXkpO1xuICAgIHRoaXMuaGVhbHRoQmFyU3ByaXRlID0gbmV3IFNwcml0ZShncmFwaGljcywga1Nwcml0ZVBhdGgsIGtIZWFsdGhCYXJTcmMpO1xuICAgIHRoaXMuaGVhbHRoRmlsbFNwcml0ZSA9IG5ldyBWYXJ5aW5nV2lkdGhTcHJpdGUoZ3JhcGhpY3MsIGtTcHJpdGVQYXRoLCBrSGVhbHRoRmlsbFNyYyk7XG4gICAgdGhpcy5kYW1hZ2VGaWxsU3ByaXRlID0gbmV3IFZhcnlpbmdXaWR0aFNwcml0ZShncmFwaGljcywga1Nwcml0ZVBhdGgsIGtEYW1hZ2VGaWxsU3JjKTtcbiAgfVxuICBwcm90b3R5cGUudGFrZURhbWFnZSA9IGZ1bmN0aW9uKGRhbWFnZSl7XG4gICAgaWYgKHRoaXMuY3VycmVudEhlYWx0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRhbWFnZVRpbWVyLnJlc2V0KCk7XG4gICAgdGhpcy5oZWFsdGhGaWxsU3ByaXRlLnNldFdpZHRoKHRoaXMuZmlsbE9mZnNldCh0aGlzLmN1cnJlbnRIZWFsdGggLSBkYW1hZ2UpKTtcbiAgICB0aGlzLmRhbWFnZUZpbGxTcHJpdGUuc2V0V2lkdGgodGhpcy5maWxsT2Zmc2V0KGRhbWFnZSkpO1xuICAgIHRoaXMuZGFtYWdlID0gZGFtYWdlO1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRIZWFsdGggLSBkYW1hZ2UgPD0gMDtcbiAgfTtcbiAgcHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGVsYXBzZWRUaW1lKXtcbiAgICBpZiAodGhpcy5kYW1hZ2UgPiAwICYmIHRoaXMuZGFtYWdlVGltZXIuaXNFeHBpcmVkKSB7XG4gICAgICB0aGlzLmN1cnJlbnRIZWFsdGggPSBzdGQubWF4KDAsIHRoaXMuY3VycmVudEhlYWx0aCAtIHRoaXMuZGFtYWdlKTtcbiAgICAgIHJldHVybiB0aGlzLmRhbWFnZSA9IDA7XG4gICAgfVxuICB9O1xuICBwcm90b3R5cGUuZmlsbE9mZnNldCA9IGZ1bmN0aW9uKGhlYWx0aCl7XG4gICAgcmV0dXJuIGtNYXhGaWxsUHggKiAoaGVhbHRoIC8gdGhpcy5tYXhIZWFsdGgpO1xuICB9O1xuICBwcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGdyYXBoaWNzKXtcbiAgICB2YXIgeDtcbiAgICB0aGlzLmhlYWx0aEJhclNwcml0ZS5kcmF3KGdyYXBoaWNzLCBrSGVhbHRoQmFyWCwga0hlYWx0aEJhclkpO1xuICAgIGlmICh0aGlzLmN1cnJlbnRIZWFsdGggIT09IDApIHtcbiAgICAgIHRoaXMuaGVhbHRoRmlsbFNwcml0ZS5kcmF3KGdyYXBoaWNzLCBrSGVhbHRoRmlsbFgsIGtIZWFsdGhGaWxsWSk7XG4gICAgICBpZiAodGhpcy5kYW1hZ2UpIHtcbiAgICAgICAgeCA9IGtIZWFsdGhGaWxsWCArIHB4VG9HYW1lKHRoaXMuZmlsbE9mZnNldCh0aGlzLmN1cnJlbnRIZWFsdGggLSB0aGlzLmRhbWFnZSkpO1xuICAgICAgICB0aGlzLmRhbWFnZUZpbGxTcHJpdGUuZHJhdyhncmFwaGljcywgeCwga0hlYWx0aEZpbGxZKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBOdW1iZXJTcHJpdGUuSFVETnVtYmVyKGdyYXBoaWNzLCB0aGlzLmN1cnJlbnRIZWFsdGgsIDIpLmRyYXcoZ3JhcGhpY3MsIGtIZWFsdGhOdW1YLCBrSGVhbHRoTnVtWSk7XG4gIH07XG4gIHJldHVybiBIZWFsdGg7XG59KCkpOyIsInZhciBzdGQsIEFuaW1hdGVkU3ByaXRlLCBJbW1vYmlsZVNpbmdsZUxvb3BQYXJ0aWNsZSwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcbnN0ZCA9IHJlcXVpcmUoJ3N0ZCcpO1xuQW5pbWF0ZWRTcHJpdGUgPSByZXF1aXJlKCcuL3Nwcml0ZScpLkFuaW1hdGVkU3ByaXRlO1xub3V0JC5JbW1vYmlsZVNpbmdsZUxvb3BQYXJ0aWNsZSA9IEltbW9iaWxlU2luZ2xlTG9vcFBhcnRpY2xlID0gKGZ1bmN0aW9uKCl7XG4gIEltbW9iaWxlU2luZ2xlTG9vcFBhcnRpY2xlLmRpc3BsYXlOYW1lID0gJ0ltbW9iaWxlU2luZ2xlTG9vcFBhcnRpY2xlJztcbiAgdmFyIHByb3RvdHlwZSA9IEltbW9iaWxlU2luZ2xlTG9vcFBhcnRpY2xlLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBJbW1vYmlsZVNpbmdsZUxvb3BQYXJ0aWNsZTtcbiAgZnVuY3Rpb24gSW1tb2JpbGVTaW5nbGVMb29wUGFydGljbGUoZ3JhcGhpY3MsIHgsIHksIHNwcml0ZVBhdGgsIHNwcml0ZVNvdXJjZSwgZnBzLCBmcmFtZXMpe1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLnNwcml0ZSA9IG5ldyBBbmltYXRlZFNwcml0ZShncmFwaGljcywgc3ByaXRlUGF0aCwgc3ByaXRlU291cmNlLCBmcHMsIChmdW5jdGlvbigpe1xuICAgICAgdmFyIGkkLCB0byQsIHJlc3VsdHMkID0gW107XG4gICAgICBmb3IgKGkkID0gMCwgdG8kID0gZnJhbWVzOyBpJCA8IHRvJDsgKytpJCkge1xuICAgICAgICByZXN1bHRzJC5wdXNoKGkkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzJDtcbiAgICB9KCkpKTtcbiAgfVxuICBwcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oZWxhcHNlZFRpbWUpe1xuICAgIHRoaXMuc3ByaXRlLnVwZGF0ZShlbGFwc2VkVGltZSk7XG4gICAgcmV0dXJuIHRoaXMuc3ByaXRlLm51bUNvbXBsZXRlZExvb3BzID09PSAwO1xuICB9O1xuICBwcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGdyYXBoaWNzKXtcbiAgICByZXR1cm4gdGhpcy5zcHJpdGUuZHJhdyhncmFwaGljcywgdGhpcy54LCB0aGlzLnkpO1xuICB9O1xuICByZXR1cm4gSW1tb2JpbGVTaW5nbGVMb29wUGFydGljbGU7XG59KCkpOyIsInZhciBzdGQsIElucHV0O1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG5JbnB1dCA9IChmdW5jdGlvbigpe1xuICBJbnB1dC5kaXNwbGF5TmFtZSA9ICdJbnB1dCc7XG4gIHZhciBwcm90b3R5cGUgPSBJbnB1dC5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gSW5wdXQ7XG4gIGZ1bmN0aW9uIElucHV0KCl7XG4gICAgdGhpcy5oZWxkS2V5cyA9IHt9O1xuICAgIHRoaXMucHJlc3NlZEtleXMgPSB7fTtcbiAgICB0aGlzLnJlbGVhc2VkS2V5cyA9IHt9O1xuICB9XG4gIHByb3RvdHlwZS5iZWdpbk5ld0ZyYW1lID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLnByZXNzZWRLZXlzID0ge307XG4gICAgcmV0dXJuIHRoaXMucmVsZWFzZWRLZXlzID0ge307XG4gIH07XG4gIHByb3RvdHlwZS5rZXlEb3duRXZlbnQgPSBmdW5jdGlvbihldmVudCl7XG4gICAgdGhpcy5wcmVzc2VkS2V5c1tldmVudC5rZXldID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5oZWxkS2V5c1tldmVudC5rZXldID0gdHJ1ZTtcbiAgfTtcbiAgcHJvdG90eXBlLmtleVVwRXZlbnQgPSBmdW5jdGlvbihldmVudCl7XG4gICAgdGhpcy5yZWxlYXNlZEtleXNbZXZlbnQua2V5XSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMuaGVsZEtleXNbZXZlbnQua2V5XSA9IGZhbHNlO1xuICB9O1xuICBwcm90b3R5cGUud2FzS2V5UHJlc3NlZCA9IGZ1bmN0aW9uKGtleSl7XG4gICAgcmV0dXJuIHRoaXMucHJlc3NlZEtleXNba2V5XTtcbiAgfTtcbiAgcHJvdG90eXBlLndhc0tleVJlbGVhc2VkID0gZnVuY3Rpb24oa2V5KXtcbiAgICByZXR1cm4gdGhpcy5yZWxlYXNlZEtleXNba2V5XTtcbiAgfTtcbiAgcHJvdG90eXBlLmlzS2V5SGVsZCA9IGZ1bmN0aW9uKGtleSl7XG4gICAgcmV0dXJuIHRoaXMuaGVsZEtleXNba2V5XTtcbiAgfTtcbiAgcmV0dXJuIElucHV0O1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gbmV3IElucHV0OyIsInZhciBzdGQsIHVuaXRzLCBkaXYsIHRpbGVUb1B4LCBnYW1lVG9QeCwgdGlsZVRvR2FtZSwgU3ByaXRlLCBGaXhlZEJhY2tkcm9wLCBTcHJpdGVTb3VyY2UsIHJlZiQsIEFJUl9USUxFLCBXQUxMX1RJTEUsIGtNYXBXaWR0aCwgVGlsZSwgQ29sbGlzaW9uVGlsZSwgTWFwO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG51bml0cyA9IHJlcXVpcmUoJy4vdW5pdHMnKTtcbmRpdiA9IHN0ZC5kaXY7XG50aWxlVG9QeCA9IHVuaXRzLnRpbGVUb1B4LCBnYW1lVG9QeCA9IHVuaXRzLmdhbWVUb1B4LCB0aWxlVG9HYW1lID0gdW5pdHMudGlsZVRvR2FtZTtcblNwcml0ZSA9IHJlcXVpcmUoJy4vc3ByaXRlJykuU3ByaXRlO1xuRml4ZWRCYWNrZHJvcCA9IHJlcXVpcmUoJy4vYmFja2Ryb3AnKS5GaXhlZEJhY2tkcm9wO1xuU3ByaXRlU291cmNlID0gcmVxdWlyZSgnLi9yZWN0YW5nbGUnKS5TcHJpdGVTb3VyY2U7XG5yZWYkID0gc3RkWydlbnVtJ10sIEFJUl9USUxFID0gcmVmJFswXSwgV0FMTF9USUxFID0gcmVmJFsxXTtcbmtNYXBXaWR0aCA9IDIwO1xuVGlsZSA9IChmdW5jdGlvbigpe1xuICBUaWxlLmRpc3BsYXlOYW1lID0gJ1RpbGUnO1xuICB2YXIgcHJvdG90eXBlID0gVGlsZS5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gVGlsZTtcbiAgZnVuY3Rpb24gVGlsZSh0eXBlLCBzcHJpdGUpe1xuICAgIHRoaXMudHlwZSA9IHR5cGUgIT0gbnVsbCA/IHR5cGUgOiBBSVJfVElMRTtcbiAgICB0aGlzLnNwcml0ZSA9IHNwcml0ZTtcbiAgfVxuICByZXR1cm4gVGlsZTtcbn0oKSk7XG5Db2xsaXNpb25UaWxlID0gKGZ1bmN0aW9uKCl7XG4gIENvbGxpc2lvblRpbGUuZGlzcGxheU5hbWUgPSAnQ29sbGlzaW9uVGlsZSc7XG4gIHZhciBwcm90b3R5cGUgPSBDb2xsaXNpb25UaWxlLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBDb2xsaXNpb25UaWxlO1xuICBmdW5jdGlvbiBDb2xsaXNpb25UaWxlKHJvdywgY29sLCB0eXBlKXtcbiAgICB0aGlzLnJvdyA9IHJvdztcbiAgICB0aGlzLmNvbCA9IGNvbDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG4gIHJldHVybiBDb2xsaXNpb25UaWxlO1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gTWFwID0gKGZ1bmN0aW9uKCl7XG4gIE1hcC5kaXNwbGF5TmFtZSA9ICdNYXAnO1xuICB2YXIgcHJvdG90eXBlID0gTWFwLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBNYXA7XG4gIGZ1bmN0aW9uIE1hcCgpe1xuICAgIHRoaXMuYmFja2Ryb3AgPSBudWxsO1xuICAgIHRoaXMudGlsZXMgPSBNYXAuY3JlYXRlTWF0cml4KG5ldyBUaWxlLCBrTWFwV2lkdGgsIDE1KTtcbiAgICB0aGlzLmJnVGlsZXMgPSBNYXAuY3JlYXRlTWF0cml4KG51bGwsIGtNYXBXaWR0aCwgMTUpO1xuICB9XG4gIHByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZ3JhcGhpY3Mpe1xuICAgIHZhciBpJCwgcmVmJCwgbGVuJCwgeSwgcm93LCBscmVzdWx0JCwgaiQsIGxlbjEkLCB4LCB0aWxlLCByZWYxJCwgcmVzdWx0cyQgPSBbXTtcbiAgICBmb3IgKGkkID0gMCwgbGVuJCA9IChyZWYkID0gdGhpcy50aWxlcykubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICAgIHkgPSBpJDtcbiAgICAgIHJvdyA9IHJlZiRbaSRdO1xuICAgICAgbHJlc3VsdCQgPSBbXTtcbiAgICAgIGZvciAoaiQgPSAwLCBsZW4xJCA9IHJvdy5sZW5ndGg7IGokIDwgbGVuMSQ7ICsraiQpIHtcbiAgICAgICAgeCA9IGokO1xuICAgICAgICB0aWxlID0gcm93W2okXTtcbiAgICAgICAgbHJlc3VsdCQucHVzaCgocmVmMSQgPSB0aWxlLnNwcml0ZSkgIT0gbnVsbCA/IHJlZjEkLmRyYXcoZ3JhcGhpY3MsIHRpbGVUb0dhbWUoeCksIHRpbGVUb0dhbWUoeSkpIDogdm9pZCA4KTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdHMkLnB1c2gobHJlc3VsdCQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cyQ7XG4gIH07XG4gIHByb3RvdHlwZS5kcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uKGdyYXBoaWNzKXtcbiAgICB2YXIgaSQsIHJlZiQsIGxlbiQsIHksIHJvdywgbHJlc3VsdCQsIGokLCBsZW4xJCwgeCwgc3ByaXRlLCByZXN1bHRzJCA9IFtdO1xuICAgIHRoaXMuYmFja2Ryb3AuZHJhdyhncmFwaGljcyk7XG4gICAgZm9yIChpJCA9IDAsIGxlbiQgPSAocmVmJCA9IHRoaXMuYmdUaWxlcykubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICAgIHkgPSBpJDtcbiAgICAgIHJvdyA9IHJlZiRbaSRdO1xuICAgICAgbHJlc3VsdCQgPSBbXTtcbiAgICAgIGZvciAoaiQgPSAwLCBsZW4xJCA9IHJvdy5sZW5ndGg7IGokIDwgbGVuMSQ7ICsraiQpIHtcbiAgICAgICAgeCA9IGokO1xuICAgICAgICBzcHJpdGUgPSByb3dbaiRdO1xuICAgICAgICBscmVzdWx0JC5wdXNoKHNwcml0ZSAhPSBudWxsID8gc3ByaXRlLmRyYXcoZ3JhcGhpY3MsIHRpbGVUb0dhbWUoeCksIHRpbGVUb0dhbWUoeSkpIDogdm9pZCA4KTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdHMkLnB1c2gobHJlc3VsdCQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cyQ7XG4gIH07XG4gIHByb3RvdHlwZS5nZXRDb2xsaWRpbmdUaWxlcyA9IGZ1bmN0aW9uKHJlY3Qpe1xuICAgIHZhciBmaXJzdFJvdywgbGFzdFJvdywgZmlyc3RDb2wsIGxhc3RDb2wsIGNvbGxpc2lvblRpbGVzLCBpJCwgcm93LCBqJCwgY29sO1xuICAgIGZpcnN0Um93ID0gZGl2KGdhbWVUb1B4KHJlY3QudG9wKSwgdGlsZVRvUHgoMSkpO1xuICAgIGxhc3RSb3cgPSBkaXYoZ2FtZVRvUHgocmVjdC5ib3R0b20pLCB0aWxlVG9QeCgxKSk7XG4gICAgZmlyc3RDb2wgPSBkaXYoZ2FtZVRvUHgocmVjdC5sZWZ0KSwgdGlsZVRvUHgoMSkpO1xuICAgIGxhc3RDb2wgPSBkaXYoZ2FtZVRvUHgocmVjdC5yaWdodCksIHRpbGVUb1B4KDEpKTtcbiAgICBjb2xsaXNpb25UaWxlcyA9IFtdO1xuICAgIGZvciAoaSQgPSBmaXJzdFJvdzsgaSQgPD0gbGFzdFJvdzsgKytpJCkge1xuICAgICAgcm93ID0gaSQ7XG4gICAgICBmb3IgKGokID0gZmlyc3RDb2w7IGokIDw9IGxhc3RDb2w7ICsraiQpIHtcbiAgICAgICAgY29sID0gaiQ7XG4gICAgICAgIGlmIChyb3cgPCAwIHx8IGNvbCA8IDAgfHwgY29sID49IGtNYXBXaWR0aCkge1xuICAgICAgICAgIGNvbGxpc2lvblRpbGVzLnB1c2gobmV3IENvbGxpc2lvblRpbGUocm93LCBjb2wsIFdBTExfVElMRSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbGxpc2lvblRpbGVzLnB1c2gobmV3IENvbGxpc2lvblRpbGUocm93LCBjb2wsIHRoaXMudGlsZXNbcm93XVtjb2xdLnR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29sbGlzaW9uVGlsZXM7XG4gIH07XG4gIE1hcC5jcmVhdGVUZXN0TWFwID0gZnVuY3Rpb24oZ3JhcGhpY3Mpe1xuICAgIHZhciBtYXAsIGJnUGF0aCwgZmdQYXRoLCBudW1Sb3dzLCBudW1Db2xzLCByb3csIHRpbGUsIGkkLCBjb2wsIGNoYWluVG9wLCBjaGFpbk1pZCwgY2hhaW5CdG07XG4gICAgbWFwID0gbmV3IE1hcDtcbiAgICBiZ1BhdGggPSAnYmtCbHVlJztcbiAgICBmZ1BhdGggPSAnU3RhZ2UvUHJ0Q2F2ZSc7XG4gICAgbWFwLmJhY2tkcm9wID0gbmV3IEZpeGVkQmFja2Ryb3AoYmdQYXRoLCBncmFwaGljcyk7XG4gICAgbnVtUm93cyA9IDE1O1xuICAgIG51bUNvbHMgPSAyMDtcbiAgICByb3cgPSAxMTtcbiAgICB0aWxlID0gbmV3IFRpbGUoV0FMTF9USUxFLCBuZXcgU3ByaXRlKGdyYXBoaWNzLCBmZ1BhdGgsIG5ldyBTcHJpdGVTb3VyY2UoMSwgMCwgMSwgMSkpKTtcbiAgICBmb3IgKGkkID0gMDsgaSQgPD0gbnVtQ29sczsgKytpJCkge1xuICAgICAgY29sID0gaSQ7XG4gICAgICBtYXAudGlsZXNbcm93XVtjb2xdID0gdGlsZTtcbiAgICB9XG4gICAgbWFwLnRpbGVzWzEwXVs1XSA9IHRpbGU7XG4gICAgbWFwLnRpbGVzWzldWzRdID0gdGlsZTtcbiAgICBtYXAudGlsZXNbOF1bM10gPSB0aWxlO1xuICAgIG1hcC50aWxlc1s3XVsyXSA9IHRpbGU7XG4gICAgbWFwLnRpbGVzWzEwXVszXSA9IHRpbGU7XG4gICAgbWFwLnRpbGVzWzEwXVswXSA9IHRpbGU7XG4gICAgbWFwLnRpbGVzWzhdWzEwXSA9IHRpbGU7XG4gICAgY2hhaW5Ub3AgPSBuZXcgU3ByaXRlKGdyYXBoaWNzLCBmZ1BhdGgsIG5ldyBTcHJpdGVTb3VyY2UoMTEsIDIpKTtcbiAgICBjaGFpbk1pZCA9IG5ldyBTcHJpdGUoZ3JhcGhpY3MsIGZnUGF0aCwgbmV3IFNwcml0ZVNvdXJjZSgxMiwgMikpO1xuICAgIGNoYWluQnRtID0gbmV3IFNwcml0ZShncmFwaGljcywgZmdQYXRoLCBuZXcgU3ByaXRlU291cmNlKDEzLCAyKSk7XG4gICAgbWFwLmJnVGlsZXNbOF1bMl0gPSBjaGFpblRvcDtcbiAgICBtYXAuYmdUaWxlc1s5XVsyXSA9IGNoYWluTWlkO1xuICAgIG1hcC5iZ1RpbGVzWzEwXVsyXSA9IGNoYWluQnRtO1xuICAgIHJldHVybiBtYXA7XG4gIH07XG4gIE1hcC5jcmVhdGVNYXRyaXggPSBmdW5jdGlvbih2YWx1ZSwgY29scywgcm93cyl7XG4gICAgdmFyIGkkLCB5LCBscmVzdWx0JCwgaiQsIHosIHJlc3VsdHMkID0gW107XG4gICAgZm9yIChpJCA9IDA7IGkkIDw9IHJvd3M7ICsraSQpIHtcbiAgICAgIHkgPSBpJDtcbiAgICAgIGxyZXN1bHQkID0gW107XG4gICAgICBmb3IgKGokID0gMDsgaiQgPD0gY29sczsgKytqJCkge1xuICAgICAgICB6ID0gaiQ7XG4gICAgICAgIGxyZXN1bHQkLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgICAgcmVzdWx0cyQucHVzaChscmVzdWx0JCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzJDtcbiAgfTtcbiAgTWFwLldBTExfVElMRSA9IFdBTExfVElMRTtcbiAgTWFwLkFJUl9USUxFID0gQUlSX1RJTEU7XG4gIHJldHVybiBNYXA7XG59KCkpOyIsInZhciBzdGQsIHVuaXRzLCByZWFkb3V0LCBQYXJ0aWNsZVRvb2xzLCBQYXJ0aWNsZVN5c3RlbSwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcbnN0ZCA9IHJlcXVpcmUoJ3N0ZCcpO1xudW5pdHMgPSByZXF1aXJlKCcuL3VuaXRzJyk7XG5yZWFkb3V0ID0gcmVxdWlyZSgnLi9yZWFkb3V0Jyk7XG5vdXQkLlBhcnRpY2xlVG9vbHMgPSBQYXJ0aWNsZVRvb2xzID0gKGZ1bmN0aW9uKCl7XG4gIFBhcnRpY2xlVG9vbHMuZGlzcGxheU5hbWUgPSAnUGFydGljbGVUb29scyc7XG4gIHZhciBwcm90b3R5cGUgPSBQYXJ0aWNsZVRvb2xzLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBQYXJ0aWNsZVRvb2xzO1xuICBmdW5jdGlvbiBQYXJ0aWNsZVRvb2xzKGdyYXBoaWNzKXtcbiAgICB0aGlzLmdyYXBoaWNzID0gZ3JhcGhpY3M7XG4gICAgdGhpcy5lbnRpdHlTeXN0ZW0gPSBuZXcgUGFydGljbGVTeXN0ZW07XG4gICAgdGhpcy5mcm9udFN5c3RlbSA9IG5ldyBQYXJ0aWNsZVN5c3RlbTtcbiAgfVxuICBwcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oZWxhcHNlZFRpbWUpe1xuICAgIHRoaXMuZW50aXR5U3lzdGVtLnVwZGF0ZShlbGFwc2VkVGltZSk7XG4gICAgcmV0dXJuIHRoaXMuZnJvbnRTeXN0ZW0udXBkYXRlKGVsYXBzZWRUaW1lKTtcbiAgfTtcbiAgcmV0dXJuIFBhcnRpY2xlVG9vbHM7XG59KCkpO1xub3V0JC5QYXJ0aWNsZVN5c3RlbSA9IFBhcnRpY2xlU3lzdGVtID0gKGZ1bmN0aW9uKCl7XG4gIFBhcnRpY2xlU3lzdGVtLmRpc3BsYXlOYW1lID0gJ1BhcnRpY2xlU3lzdGVtJztcbiAgdmFyIHByb3RvdHlwZSA9IFBhcnRpY2xlU3lzdGVtLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBQYXJ0aWNsZVN5c3RlbTtcbiAgZnVuY3Rpb24gUGFydGljbGVTeXN0ZW0oKXtcbiAgICByZWFkb3V0LmFkZFJlYWRlcigncGFydGljbGVzJywgJ1BhcnRpY2xlcycsIDApO1xuICAgIHRoaXMucGFydGljbGVzID0gW107XG4gIH1cbiAgcHJvdG90eXBlLmFkZE5ld1BhcnRpY2xlID0gZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiB0aGlzLnBhcnRpY2xlcy5wdXNoKGl0KTtcbiAgfTtcbiAgcHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGVsYXBzZWRUaW1lKXtcbiAgICByZWFkb3V0LnVwZGF0ZSgncGFydGljbGVzJywgdGhpcy5wYXJ0aWNsZXMubGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcy5wYXJ0aWNsZXMgPSBzdGQuZmlsdGVyKGZ1bmN0aW9uKGl0KXtcbiAgICAgIHJldHVybiBpdC51cGRhdGUoZWxhcHNlZFRpbWUpO1xuICAgIH0sIHRoaXMucGFydGljbGVzKTtcbiAgfTtcbiAgcHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihncmFwaGljcyl7XG4gICAgcmV0dXJuIHRoaXMucGFydGljbGVzLmZvckVhY2goZnVuY3Rpb24oaXQpe1xuICAgICAgcmV0dXJuIGl0LmRyYXcoZ3JhcGhpY3MpO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gUGFydGljbGVTeXN0ZW07XG59KCkpOyIsInZhciBJbnRlcmZhY2VFcnJvciwgUGFydGljbGUsIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5JbnRlcmZhY2VFcnJvciA9IChmdW5jdGlvbihzdXBlcmNsYXNzKXtcbiAgdmFyIHByb3RvdHlwZSA9IGV4dGVuZCQoKGltcG9ydCQoSW50ZXJmYWNlRXJyb3IsIHN1cGVyY2xhc3MpLmRpc3BsYXlOYW1lID0gJ0ludGVyZmFjZUVycm9yJywgSW50ZXJmYWNlRXJyb3IpLCBzdXBlcmNsYXNzKS5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gSW50ZXJmYWNlRXJyb3I7XG4gIGZ1bmN0aW9uIEludGVyZmFjZUVycm9yKG1lc3NhZ2Upe1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5uYW1lID0gJ0ludGVyZmFjZUVycm9yJztcbiAgfVxuICByZXR1cm4gSW50ZXJmYWNlRXJyb3I7XG59KEVycm9yKSk7XG5vdXQkLlBhcnRpY2xlID0gUGFydGljbGUgPSAoZnVuY3Rpb24oKXtcbiAgUGFydGljbGUuZGlzcGxheU5hbWUgPSAnUGFydGljbGUnO1xuICB2YXIgcHJvdG90eXBlID0gUGFydGljbGUucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IFBhcnRpY2xlO1xuICBwcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oZWxhcHNlZFRpbWUpe1xuICAgIHRocm93IG5ldyBJbnRlcmZhY2VFcnJvcihcIlBhcnRpY2xlIC0gYHVwZGF0ZWAgbm90IGltcGxlbWVudGVkXCIpO1xuICB9O1xuICBwcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGdyYXBoaWNzKXtcbiAgICB0aHJvdyBuZXcgSW50ZXJmYWNlRXJyb3IoXCJQYXJ0aWNsZSAtIGBkcmF3YCBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH07XG4gIGZ1bmN0aW9uIFBhcnRpY2xlKCl7fVxuICByZXR1cm4gUGFydGljbGU7XG59KCkpO1xuZnVuY3Rpb24gZXh0ZW5kJChzdWIsIHN1cCl7XG4gIGZ1bmN0aW9uIGZ1bigpe30gZnVuLnByb3RvdHlwZSA9IChzdWIuc3VwZXJjbGFzcyA9IHN1cCkucHJvdG90eXBlO1xuICAoc3ViLnByb3RvdHlwZSA9IG5ldyBmdW4pLmNvbnN0cnVjdG9yID0gc3ViO1xuICBpZiAodHlwZW9mIHN1cC5leHRlbmRlZCA9PSAnZnVuY3Rpb24nKSBzdXAuZXh0ZW5kZWQoc3ViKTtcbiAgcmV0dXJuIHN1Yjtcbn1cbmZ1bmN0aW9uIGltcG9ydCQob2JqLCBzcmMpe1xuICB2YXIgb3duID0ge30uaGFzT3duUHJvcGVydHk7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIGlmIChvd24uY2FsbChzcmMsIGtleSkpIG9ialtrZXldID0gc3JjW2tleV07XG4gIHJldHVybiBvYmo7XG59IiwidmFyIHN0ZCwgdW5pdHMsIGNvbmZpZywgcmVhZG91dCwga0hhbGZUaWxlLCB0aWxlVG9HYW1lLCB0aWxlVG9QeCwgV0FMTF9USUxFLCBUaW1lciwgSGVhbHRoLCBEYW1hZ2VhYmxlLCBEYW1hZ2VUZXh0LCBEYW1hZ2VUZXh0cywgUG9sYXJTdGFyLCByZWYkLCBTcHJpdGVTdGF0ZSwgU3RhdGUsIFJlY3QsIFNwcml0ZVNvdXJjZSwgU3ByaXRlLCBBbmltYXRlZFNwcml0ZSwgTnVtYmVyU3ByaXRlLCBIZWFkQnVtcFBhcnRpY2xlLCBrQ2hhcmFjdGVyRnJhbWUsIGtXYWxrRnJhbWUsIGtTdGFuZEZyYW1lLCBrSnVtcEZyYW1lLCBrRmFsbEZyYW1lLCBrVXBGcmFtZU9mZnNldCwga0Rvd25GcmFtZSwga0JhY2tGcmFtZSwga051bVdhbGtGcmFtZXMsIGtXYWxrRnBzLCBrU3RyaWRlTWlkZGxlRnJhbWVPZmZzZXQsIGtTdHJpZGVMZWZ0RnJhbWVPZmZzZXQsIGtTdHJpZGVSaWdodEZyYW1lT2Zmc2V0LCBrRnJpY3Rpb24sIGtHcmF2aXR5LCBrV2Fsa2luZ0FjY2VsZXJhdGlvbiwga0FpckFjY2VsZXJhdGlvbiwga01heFNwZWVkWCwga01heFNwZWVkWSwga0p1bXBTcGVlZCwga1Nob3J0SnVtcFNwZWVkLCBrSnVtcEdyYXZpdHksIGtJbnZpbmNpYmxlVGltZSwga0ludmluY2libGVGbGFzaFRpbWUsIGtDb2xsaXNpb25YLCBrQ29sbGlzaW9uWVRvcCwga0NvbGxpc2lvbllIZWlnaHQsIGtDb2xsaXNpb25ZVG9wV2lkdGgsIGtDb2xsaXNpb25ZQm90dG9tV2lkdGgsIGtDb2xsaXNpb25ZVG9wTGVmdCwga0NvbGxpc2lvbllCb3R0b21MZWZ0LCBrQ29sbGlzaW9uWUJvdHRvbSwgV2Fsa2luZ0FuaW1hdGlvbiwgUGxheWVyLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG51bml0cyA9IHJlcXVpcmUoJy4vdW5pdHMnKTtcbmNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5yZWFkb3V0ID0gcmVxdWlyZSgnLi9yZWFkb3V0Jyk7XG5rSGFsZlRpbGUgPSB1bml0cy5rSGFsZlRpbGUsIHRpbGVUb0dhbWUgPSB1bml0cy50aWxlVG9HYW1lLCB0aWxlVG9QeCA9IHVuaXRzLnRpbGVUb1B4O1xuV0FMTF9USUxFID0gcmVxdWlyZSgnLi9tYXAnKS5XQUxMX1RJTEU7XG5UaW1lciA9IHJlcXVpcmUoJy4vdGltZXInKS5UaW1lcjtcbkhlYWx0aCA9IHJlcXVpcmUoJy4vaGVhbHRoJykuSGVhbHRoO1xuRGFtYWdlYWJsZSA9IHJlcXVpcmUoJy4vZGFtYWdlYWJsZScpLkRhbWFnZWFibGU7XG5EYW1hZ2VUZXh0ID0gcmVxdWlyZSgnLi9kYW1hZ2UtdGV4dCcpLkRhbWFnZVRleHQ7XG5EYW1hZ2VUZXh0cyA9IHJlcXVpcmUoJy4vZGFtYWdlLXRleHRzJykuRGFtYWdlVGV4dHM7XG5Qb2xhclN0YXIgPSByZXF1aXJlKCcuL2FybXMnKS5Qb2xhclN0YXI7XG5yZWYkID0gcmVxdWlyZSgnLi9zcHJpdGVzdGF0ZScpLCBTcHJpdGVTdGF0ZSA9IHJlZiQuU3ByaXRlU3RhdGUsIFN0YXRlID0gcmVmJC5TdGF0ZTtcbnJlZiQgPSByZXF1aXJlKCcuL3JlY3RhbmdsZScpLCBSZWN0ID0gcmVmJC5SZWN0YW5nbGUsIFNwcml0ZVNvdXJjZSA9IHJlZiQuU3ByaXRlU291cmNlO1xucmVmJCA9IHJlcXVpcmUoJy4vc3ByaXRlJyksIFNwcml0ZSA9IHJlZiQuU3ByaXRlLCBBbmltYXRlZFNwcml0ZSA9IHJlZiQuQW5pbWF0ZWRTcHJpdGUsIE51bWJlclNwcml0ZSA9IHJlZiQuTnVtYmVyU3ByaXRlO1xuSGVhZEJ1bXBQYXJ0aWNsZSA9IHJlcXVpcmUoJy4vaGVhZC1idW1wLXBhcnRpY2xlJykuSGVhZEJ1bXBQYXJ0aWNsZTtcbmtDaGFyYWN0ZXJGcmFtZSA9IDA7XG5rV2Fsa0ZyYW1lID0gMDtcbmtTdGFuZEZyYW1lID0gMDtcbmtKdW1wRnJhbWUgPSAxO1xua0ZhbGxGcmFtZSA9IDI7XG5rVXBGcmFtZU9mZnNldCA9IDM7XG5rRG93bkZyYW1lID0gNjtcbmtCYWNrRnJhbWUgPSA3O1xua051bVdhbGtGcmFtZXMgPSAzO1xua1dhbGtGcHMgPSAxNTtcbmtTdHJpZGVNaWRkbGVGcmFtZU9mZnNldCA9IDA7XG5rU3RyaWRlTGVmdEZyYW1lT2Zmc2V0ID0gMTtcbmtTdHJpZGVSaWdodEZyYW1lT2Zmc2V0ID0gMjtcbmtGcmljdGlvbiA9IDAuMDAwNDk4MDQ2ODc7XG5rR3Jhdml0eSA9IDAuMDAwNzgxMjU7XG5rV2Fsa2luZ0FjY2VsZXJhdGlvbiA9IDAuMDAwODMwMDc4MTI7XG5rQWlyQWNjZWxlcmF0aW9uID0gMC4wMDAzMTI1O1xua01heFNwZWVkWCA9IDAuMTU4NTkzNzU7XG5rTWF4U3BlZWRZID0gMC4yOTk4MDQ2ODc1O1xua0p1bXBTcGVlZCA9IDAuMjU7XG5rU2hvcnRKdW1wU3BlZWQgPSAwLjI1IC8gMS41O1xua0p1bXBHcmF2aXR5ID0gMC4wMDAzMTI1O1xua0ludmluY2libGVUaW1lID0gMzAwMDtcbmtJbnZpbmNpYmxlRmxhc2hUaW1lID0gNTA7XG5rQ29sbGlzaW9uWCA9IG5ldyBSZWN0KDYsIDEwLCAyMCwgMTIpO1xua0NvbGxpc2lvbllUb3AgPSAyO1xua0NvbGxpc2lvbllIZWlnaHQgPSAzMDtcbmtDb2xsaXNpb25ZVG9wV2lkdGggPSAxODtcbmtDb2xsaXNpb25ZQm90dG9tV2lkdGggPSAxMDtcbmtDb2xsaXNpb25ZVG9wTGVmdCA9ICh0aWxlVG9HYW1lKDEpIC0ga0NvbGxpc2lvbllUb3BXaWR0aCkgLyAyO1xua0NvbGxpc2lvbllCb3R0b21MZWZ0ID0gKHRpbGVUb0dhbWUoMSkgLSBrQ29sbGlzaW9uWUJvdHRvbVdpZHRoKSAvIDI7XG5rQ29sbGlzaW9uWUJvdHRvbSA9IGtDb2xsaXNpb25ZVG9wICsga0NvbGxpc2lvbllIZWlnaHQ7XG5XYWxraW5nQW5pbWF0aW9uID0gKGZ1bmN0aW9uKCl7XG4gIFdhbGtpbmdBbmltYXRpb24uZGlzcGxheU5hbWUgPSAnV2Fsa2luZ0FuaW1hdGlvbic7XG4gIHZhciBwcm90b3R5cGUgPSBXYWxraW5nQW5pbWF0aW9uLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBXYWxraW5nQW5pbWF0aW9uO1xuICBmdW5jdGlvbiBXYWxraW5nQW5pbWF0aW9uKG51bUZyYW1lcywgZnBzKXtcbiAgICB0aGlzLm51bUZyYW1lcyA9IG51bUZyYW1lcztcbiAgICB0aGlzLmZwcyA9IGZwcztcbiAgICB0aGlzLmZyYW1lVGltZXIgPSBuZXcgVGltZXIoMTAwMCAvIHRoaXMuZnBzKTtcbiAgICB0aGlzLmZvcndhcmQgPSB0cnVlO1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICB9XG4gIHByb3RvdHlwZS5zdHJpZGUgPSBmdW5jdGlvbigpe1xuICAgIHN3aXRjaCAodGhpcy5pbmRleCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiBTdGF0ZS5TVFJJREVfTEVGVDtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gU3RhdGUuU1RSSURFX01JRERMRTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gU3RhdGUuU1RSSURFX1JJR0hUO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gU3RhdGUuU1RSSURFX0xFRlQ7XG4gICAgfVxuICB9O1xuICBwcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICBpZiAodGhpcy5mcmFtZVRpbWVyLmlzRXhwaXJlZCkge1xuICAgICAgdGhpcy5mcmFtZVRpbWVyLnJlc2V0KCk7XG4gICAgICBpZiAodGhpcy5mb3J3YXJkKSB7XG4gICAgICAgIHRoaXMuaW5kZXggKz0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9yd2FyZCA9IHRoaXMuaW5kZXggIT09IHRoaXMubnVtRnJhbWVzIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5kZXggLT0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9yd2FyZCA9IHRoaXMuaW5kZXggPT09IDA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBwcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuZnJhbWVUaW1lci5yZXNldCgpO1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIHJldHVybiB0aGlzLmZvcndhcmQgPSB0cnVlO1xuICB9O1xuICByZXR1cm4gV2Fsa2luZ0FuaW1hdGlvbjtcbn0oKSk7XG5vdXQkLlBsYXllciA9IFBsYXllciA9IChmdW5jdGlvbihzdXBlcmNsYXNzKXtcbiAgdmFyIHByb3RvdHlwZSA9IGV4dGVuZCQoKGltcG9ydCQoUGxheWVyLCBzdXBlcmNsYXNzKS5kaXNwbGF5TmFtZSA9ICdQbGF5ZXInLCBQbGF5ZXIpLCBzdXBlcmNsYXNzKS5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gUGxheWVyO1xuICBmdW5jdGlvbiBQbGF5ZXIoZ3JhcGhpY3MsIHgsIHkpe1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLnZlbG9jaXR5WSA9IDA7XG4gICAgdGhpcy52ZWxvY2l0eVggPSAwO1xuICAgIHRoaXMuYWNjZWxlcmF0aW9uWCA9IDA7XG4gICAgdGhpcy5ob3Jpem9udGFsRmFjaW5nID0gU3RhdGUuTEVGVDtcbiAgICB0aGlzLmludGVuZGVkVmVydGljYWxGYWNpbmcgPSBTdGF0ZS5IT1JJWk9OVEFMO1xuICAgIHRoaXMub25Hcm91bmQgPSBmYWxzZTtcbiAgICB0aGlzLmp1bXBBY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmludGVyYWN0aW5nID0gZmFsc2U7XG4gICAgdGhpcy53YWxrQW5pbWF0aW9uID0gbmV3IFdhbGtpbmdBbmltYXRpb24oa051bVdhbGtGcmFtZXMsIGtXYWxrRnBzKTtcbiAgICB0aGlzLmludmluY2libGVUaW1lciA9IG5ldyBUaW1lcihrSW52aW5jaWJsZVRpbWUpO1xuICAgIHRoaXMuaGVhbHRoID0gbmV3IEhlYWx0aChncmFwaGljcyk7XG4gICAgdGhpcy5zcHJpdGVzID0gdGhpcy5pbml0aWFsaXNlU3ByaXRlcyhncmFwaGljcyk7XG4gICAgdGhpcy5kYW1hZ2VUZXh0ID0gbmV3IERhbWFnZVRleHQoZ3JhcGhpY3MpO1xuICAgIERhbWFnZVRleHRzLmFkZERhbWFnZWFibGUodGhpcyk7XG4gICAgdGhpcy5ndW4gPSBuZXcgUG9sYXJTdGFyKGdyYXBoaWNzKTtcbiAgfVxuICBwcm90b3R5cGUuaW5pdGlhbGlzZVNwcml0ZXMgPSBmdW5jdGlvbihncmFwaGljcywgc3ByaXRlTWFwKXtcbiAgICBzcHJpdGVNYXAgPT0gbnVsbCAmJiAoc3ByaXRlTWFwID0ge30pO1xuICAgIHJldHVybiBTcHJpdGVTdGF0ZS5nZW5lcmF0ZVdpdGgoZnVuY3Rpb24oc3RhdGUpe1xuICAgICAgdmFyIHRpbGVYLCB0aWxlWTtcbiAgICAgIHRpbGVYID0gKGZ1bmN0aW9uKCl7XG4gICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICBjYXNlIHN0YXRlLldBTEtJTkc6XG4gICAgICAgICAgcmV0dXJuIGtXYWxrRnJhbWU7XG4gICAgICAgIGNhc2Ugc3RhdGUuU1RBTkRJTkc6XG4gICAgICAgICAgcmV0dXJuIGtTdGFuZEZyYW1lO1xuICAgICAgICBjYXNlIHN0YXRlLkpVTVBJTkc6XG4gICAgICAgICAgcmV0dXJuIGtKdW1wRnJhbWU7XG4gICAgICAgIGNhc2Ugc3RhdGUuRkFMTElORzpcbiAgICAgICAgICByZXR1cm4ga0ZhbGxGcmFtZTtcbiAgICAgICAgY2FzZSBzdGF0ZS5JTlRFUkFDVElORzpcbiAgICAgICAgICByZXR1cm4ga0JhY2tGcmFtZTtcbiAgICAgICAgfVxuICAgICAgfSgpKTtcbiAgICAgIGlmIChzdGF0ZS5VUCkge1xuICAgICAgICB0aWxlWCArPSBrVXBGcmFtZU9mZnNldDtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5ET1dOKSB7XG4gICAgICAgIHRpbGVYID0ga0Rvd25GcmFtZTtcbiAgICAgIH1cbiAgICAgIHRpbGVZID0ga0NoYXJhY3RlckZyYW1lICsgKHN0YXRlLkxFRlQgPyAwIDogMSk7XG4gICAgICBpZiAoc3RhdGUuV0FMS0lORykge1xuICAgICAgICB0aWxlWCArPSAoZnVuY3Rpb24oKXtcbiAgICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICBjYXNlIHN0YXRlLlNUUklERV9MRUZUOlxuICAgICAgICAgICAgcmV0dXJuIGtTdHJpZGVMZWZ0RnJhbWVPZmZzZXQ7XG4gICAgICAgICAgY2FzZSBzdGF0ZS5TVFJJREVfUklHSFQ6XG4gICAgICAgICAgICByZXR1cm4ga1N0cmlkZVJpZ2h0RnJhbWVPZmZzZXQ7XG4gICAgICAgICAgY2FzZSBzdGF0ZS5TVFJJREVfTUlERExFOlxuICAgICAgICAgICAgcmV0dXJuIGtTdHJpZGVNaWRkbGVGcmFtZU9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH0oKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFNwcml0ZShncmFwaGljcywgJ015Q2hhcicsIG5ldyBTcHJpdGVTb3VyY2UodGlsZVgsIHRpbGVZLCAxLCAxKSk7XG4gICAgfSk7XG4gIH07XG4gIHByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihlbGFwc2VkVGltZSwgbWFwLCBwdG9vbHMpe1xuICAgIHRoaXMuc3ByaXRlc1t0aGlzLmdldFNwcml0ZVN0YXRlKCkua2V5XS51cGRhdGUoZWxhcHNlZFRpbWUpO1xuICAgIHRoaXMuaGVhbHRoLnVwZGF0ZShlbGFwc2VkVGltZSk7XG4gICAgdGhpcy5ndW4udXBkYXRlUHJvamVjdGlsZXMoZWxhcHNlZFRpbWUsIG1hcCwgcHRvb2xzKTtcbiAgICB0aGlzLnVwZGF0ZVgoZWxhcHNlZFRpbWUsIG1hcCk7XG4gICAgdGhpcy51cGRhdGVZKGVsYXBzZWRUaW1lLCBtYXAsIHB0b29scyk7XG4gICAgcmV0dXJuIHRoaXMud2Fsa0FuaW1hdGlvbi51cGRhdGUoZWxhcHNlZFRpbWUpO1xuICB9O1xuICBwcm90b3R5cGUudXBkYXRlWCA9IGZ1bmN0aW9uKGVsYXBzZWRUaW1lLCBtYXApe1xuICAgIHZhciBhY2NYLCDOlHg7XG4gICAgYWNjWCA9IHRoaXMub25Hcm91bmQgPyBrV2Fsa2luZ0FjY2VsZXJhdGlvbiA6IGtBaXJBY2NlbGVyYXRpb247XG4gICAgdGhpcy52ZWxvY2l0eVggKz0gdGhpcy5hY2NlbGVyYXRpb25YICogYWNjWCAqIGVsYXBzZWRUaW1lO1xuICAgIGlmICh0aGlzLmFjY2VsZXJhdGlvblggPCAwKSB7XG4gICAgICB0aGlzLnZlbG9jaXR5WCA9IHN0ZC5tYXgodGhpcy52ZWxvY2l0eVgsIC1rTWF4U3BlZWRYKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYWNjZWxlcmF0aW9uWCA+IDApIHtcbiAgICAgIHRoaXMudmVsb2NpdHlYID0gc3RkLm1pbih0aGlzLnZlbG9jaXR5WCwga01heFNwZWVkWCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9uR3JvdW5kKSB7XG4gICAgICB0aGlzLnZlbG9jaXR5WCA9IHRoaXMudmVsb2NpdHlYID4gMFxuICAgICAgICA/IHN0ZC5tYXgoMCwgdGhpcy52ZWxvY2l0eVggLSBrRnJpY3Rpb24gKiBlbGFwc2VkVGltZSlcbiAgICAgICAgOiBzdGQubWluKDAsIHRoaXMudmVsb2NpdHlYICsga0ZyaWN0aW9uICogZWxhcHNlZFRpbWUpO1xuICAgIH1cbiAgICDOlHggPSB0aGlzLnZlbG9jaXR5WCAqIGVsYXBzZWRUaW1lO1xuICAgIGlmICjOlHggPiAwKSB7XG4gICAgICB0aGlzLm9uV2FsbENvbGxpc2lvbihtYXAsIHRoaXMucmlnaHRDb2xsaXNpb24ozpR4KSwgZnVuY3Rpb24odGlsZSl7XG4gICAgICAgIGlmICh0aWxlKSB7XG4gICAgICAgICAgdGhpcy54ID0gdW5pdHMudGlsZVRvR2FtZSh0aWxlLmNvbCkgLSBrQ29sbGlzaW9uWC5yaWdodDtcbiAgICAgICAgICByZXR1cm4gdGhpcy52ZWxvY2l0eVggPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLnggKz0gzpR4O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLm9uV2FsbENvbGxpc2lvbihtYXAsIHRoaXMubGVmdENvbGxpc2lvbigwKSwgZnVuY3Rpb24odGlsZSl7XG4gICAgICAgIGlmICh0aWxlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMueCA9IHVuaXRzLnRpbGVUb0dhbWUodGlsZS5jb2wpICsga0NvbGxpc2lvblgucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uV2FsbENvbGxpc2lvbihtYXAsIHRoaXMubGVmdENvbGxpc2lvbijOlHgpLCBmdW5jdGlvbih0aWxlKXtcbiAgICAgICAgaWYgKHRpbGUpIHtcbiAgICAgICAgICB0aGlzLnggPSB1bml0cy50aWxlVG9HYW1lKHRpbGUuY29sKSArIGtDb2xsaXNpb25YLnJpZ2h0O1xuICAgICAgICAgIHJldHVybiB0aGlzLnZlbG9jaXR5WCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMueCArPSDOlHg7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMub25XYWxsQ29sbGlzaW9uKG1hcCwgdGhpcy5yaWdodENvbGxpc2lvbigwKSwgZnVuY3Rpb24odGlsZSl7XG4gICAgICAgIGlmICh0aWxlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMueCA9IHVuaXRzLnRpbGVUb0dhbWUodGlsZS5jb2wpIC0ga0NvbGxpc2lvblgucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgcHJvdG90eXBlLnVwZGF0ZVkgPSBmdW5jdGlvbihlbGFwc2VkVGltZSwgbWFwLCBwdG9vbHMpe1xuICAgIHZhciBncmF2aXR5LCDOlHk7XG4gICAgZ3Jhdml0eSA9IHRoaXMuanVtcEFjdGl2ZSAmJiB0aGlzLnZlbG9jaXR5WSA8IDAgPyBrSnVtcEdyYXZpdHkgOiBrR3Jhdml0eTtcbiAgICB0aGlzLnZlbG9jaXR5WSA9IHN0ZC5taW4odGhpcy52ZWxvY2l0eVkgKyBncmF2aXR5ICogZWxhcHNlZFRpbWUsIGtNYXhTcGVlZFkpO1xuICAgIM6UeSA9IHRoaXMudmVsb2NpdHlZICogZWxhcHNlZFRpbWU7XG4gICAgaWYgKM6UeSA+IDApIHtcbiAgICAgIHRoaXMub25XYWxsQ29sbGlzaW9uKG1hcCwgdGhpcy5ib3R0b21Db2xsaXNpb24ozpR5KSwgZnVuY3Rpb24odGlsZSl7XG4gICAgICAgIGlmICh0aWxlKSB7XG4gICAgICAgICAgdGhpcy55ID0gdW5pdHMudGlsZVRvR2FtZSh0aWxlLnJvdykgLSBrQ29sbGlzaW9uWUJvdHRvbTtcbiAgICAgICAgICB0aGlzLnZlbG9jaXR5WSA9IDA7XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25Hcm91bmQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMueSArPSDOlHk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25Hcm91bmQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5vbldhbGxDb2xsaXNpb24obWFwLCB0aGlzLnRvcENvbGxpc2lvbigwKSwgZnVuY3Rpb24odGlsZSl7XG4gICAgICAgIGlmICh0aWxlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMueSA9IHVuaXRzLnRpbGVUb0dhbWUodGlsZS5yb3cpICsga0NvbGxpc2lvbllIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uV2FsbENvbGxpc2lvbihtYXAsIHRoaXMudG9wQ29sbGlzaW9uKM6UeSksIGZ1bmN0aW9uKHRpbGUpe1xuICAgICAgICBpZiAodGlsZSkge1xuICAgICAgICAgIHRoaXMueSA9IHVuaXRzLnRpbGVUb0dhbWUodGlsZS5yb3cpICsga0NvbGxpc2lvbllIZWlnaHQ7XG4gICAgICAgICAgdGhpcy52ZWxvY2l0eVkgPSAwO1xuICAgICAgICAgIHJldHVybiBwdG9vbHMuZnJvbnRTeXN0ZW0uYWRkTmV3UGFydGljbGUobmV3IEhlYWRCdW1wUGFydGljbGUocHRvb2xzLmdyYXBoaWNzLCB0aGlzLmNlbnRlclgsIHRoaXMueSArIGtDb2xsaXNpb25ZVG9wKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy55ICs9IM6UeTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vbkdyb3VuZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLm9uV2FsbENvbGxpc2lvbihtYXAsIHRoaXMuYm90dG9tQ29sbGlzaW9uKDApLCBmdW5jdGlvbih0aWxlKXtcbiAgICAgICAgaWYgKHRpbGUpIHtcbiAgICAgICAgICB0aGlzLnkgPSB1bml0cy50aWxlVG9HYW1lKHRpbGUucm93KSAtIGtDb2xsaXNpb25ZQm90dG9tO1xuICAgICAgICAgIHJldHVybiB0aGlzLm9uR3JvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBwcm90b3R5cGUudGFrZURhbWFnZSA9IGZ1bmN0aW9uKGRhbWFnZSl7XG4gICAgZGFtYWdlID09IG51bGwgJiYgKGRhbWFnZSA9IDEpO1xuICAgIGlmICghdGhpcy5pbnZpbmNpYmxlVGltZXIuaXNBY3RpdmUpIHtcbiAgICAgIHRoaXMuaGVhbHRoLnRha2VEYW1hZ2UoZGFtYWdlKTtcbiAgICAgIHRoaXMudmVsb2NpdHlZID0gc3RkLm1pbigta1Nob3J0SnVtcFNwZWVkLCB0aGlzLnZlbG9jaXR5WSk7XG4gICAgICB0aGlzLmludmluY2libGUgPSB0cnVlO1xuICAgICAgdGhpcy5pbnZpbmNpYmxlVGltZXIucmVzZXQoKTtcbiAgICAgIHJldHVybiB0aGlzLmRhbWFnZVRleHQuc2V0RGFtYWdlKGRhbWFnZSk7XG4gICAgfVxuICB9O1xuICBwcm90b3R5cGUuc3ByaXRlSXNWaXNpYmxlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZHV0eTtcbiAgICBkdXR5ID0gc3RkLmRpdih0aGlzLmludmluY2libGVUaW1lci5jdXJyZW50VGltZSwga0ludmluY2libGVGbGFzaFRpbWUpICUgMiA9PT0gMDtcbiAgICByZXR1cm4gISh0aGlzLmludmluY2libGVUaW1lci5pc0FjdGl2ZSAmJiBkdXR5KTtcbiAgfTtcbiAgcHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihncmFwaGljcyl7XG4gICAgdmFyIHN0YXRlO1xuICAgIGlmIChjb25maWcuc2hvd0NvbGxpc2lvbnMpIHtcbiAgICAgIGdyYXBoaWNzLnZpc3VhbGlzZVJlY3QodGhpcy5kYW1hZ2VDb2xsaXNpb24oKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNwcml0ZUlzVmlzaWJsZSgpKSB7XG4gICAgICBzdGF0ZSA9IHRoaXMuZ2V0U3ByaXRlU3RhdGUoKTtcbiAgICAgIHRoaXMuZ3VuLmRyYXcoZ3JhcGhpY3MsIHRoaXMueCwgdGhpcy55LCBzdGF0ZSk7XG4gICAgICByZXR1cm4gdGhpcy5zcHJpdGVzW3N0YXRlLmtleV0uZHJhdyhncmFwaGljcywgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgfTtcbiAgcHJvdG90eXBlLmRyYXdIdWQgPSBmdW5jdGlvbihncmFwaGljcyl7XG4gICAgaWYgKCF0aGlzLnNwcml0ZUlzVmlzaWJsZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmhlYWx0aC5kcmF3KGdyYXBoaWNzKTtcbiAgfTtcbiAgcHJvdG90eXBlLmdldFNwcml0ZVN0YXRlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgbW90aW9uVHlwZTtcbiAgICBtb3Rpb25UeXBlID0gdGhpcy5pbnRlcmFjdGluZ1xuICAgICAgPyBTdGF0ZS5JTlRFUkFDVElOR1xuICAgICAgOiB0aGlzLm9uR3JvdW5kXG4gICAgICAgID8gdGhpcy5hY2NlbGVyYXRpb25YID09PSAwXG4gICAgICAgICAgPyBTdGF0ZS5TVEFORElOR1xuICAgICAgICAgIDogU3RhdGUuV0FMS0lOR1xuICAgICAgICA6IHRoaXMudmVsb2NpdHlZIDwgMFxuICAgICAgICAgID8gU3RhdGUuSlVNUElOR1xuICAgICAgICAgIDogU3RhdGUuRkFMTElORztcbiAgICByZXR1cm4gU3ByaXRlU3RhdGUubWFrZSh0aGlzLmhvcml6b250YWxGYWNpbmcsIHRoaXMudmVydGljYWxGYWNpbmcoKSwgbW90aW9uVHlwZSwgdGhpcy53YWxrQW5pbWF0aW9uLnN0cmlkZSgpKTtcbiAgfTtcbiAgcHJvdG90eXBlLmxlZnRDb2xsaXNpb24gPSBmdW5jdGlvbijOlCl7XG4gICAgcmV0dXJuIG5ldyBSZWN0KHRoaXMueCArIGtDb2xsaXNpb25YLmxlZnQgKyDOlCwgdGhpcy55ICsga0NvbGxpc2lvblgudG9wLCBrQ29sbGlzaW9uWC53IC8gMiAtIM6ULCBrQ29sbGlzaW9uWC5oKTtcbiAgfTtcbiAgcHJvdG90eXBlLnJpZ2h0Q29sbGlzaW9uID0gZnVuY3Rpb24ozpQpe1xuICAgIHJldHVybiBuZXcgUmVjdCh0aGlzLnggKyBrQ29sbGlzaW9uWC5sZWZ0ICsga0NvbGxpc2lvblgudyAvIDIsIHRoaXMueSArIGtDb2xsaXNpb25YLnRvcCwga0NvbGxpc2lvblgudyAvIDIgKyDOlCwga0NvbGxpc2lvblguaCk7XG4gIH07XG4gIHByb3RvdHlwZS50b3BDb2xsaXNpb24gPSBmdW5jdGlvbijOlCl7XG4gICAgcmV0dXJuIG5ldyBSZWN0KHRoaXMueCArIGtDb2xsaXNpb25ZVG9wTGVmdCwgdGhpcy55ICsga0NvbGxpc2lvbllUb3AgKyDOlCwga0NvbGxpc2lvbllUb3BXaWR0aCwga0NvbGxpc2lvbllIZWlnaHQgLyAyIC0gzpQpO1xuICB9O1xuICBwcm90b3R5cGUuYm90dG9tQ29sbGlzaW9uID0gZnVuY3Rpb24ozpQpe1xuICAgIHJldHVybiBuZXcgUmVjdCh0aGlzLnggKyBrQ29sbGlzaW9uWUJvdHRvbUxlZnQsIHRoaXMueSArIGtDb2xsaXNpb25ZVG9wICsga0NvbGxpc2lvbllIZWlnaHQgLyAyICsgzpQsIGtDb2xsaXNpb25ZQm90dG9tV2lkdGgsIGtDb2xsaXNpb25ZSGVpZ2h0IC8gMiArIM6UKTtcbiAgfTtcbiAgcHJvdG90eXBlLmRhbWFnZUNvbGxpc2lvbiA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIG5ldyBSZWN0KHRoaXMueCArIGtDb2xsaXNpb25YLmxlZnQsIHRoaXMueSArIGtDb2xsaXNpb25ZVG9wLCBrQ29sbGlzaW9uWC53LCBrQ29sbGlzaW9uWUhlaWdodCk7XG4gIH07XG4gIHByb3RvdHlwZS5vbldhbGxDb2xsaXNpb24gPSBmdW5jdGlvbihtYXAsIHJlY3QsIM67KXtcbiAgICB2YXIgaSQsIHJlZiQsIGxlbiQsIHRpbGU7XG4gICAgZm9yIChpJCA9IDAsIGxlbiQgPSAocmVmJCA9IG1hcC5nZXRDb2xsaWRpbmdUaWxlcyhyZWN0KSkubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICAgIHRpbGUgPSByZWYkW2kkXTtcbiAgICAgIGlmICh0aWxlLnR5cGUgPT09IFdBTExfVElMRSkge1xuICAgICAgICByZXR1cm4gzrsuY2FsbCh0aGlzLCB0aWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIM67LmNhbGwodGhpcyk7XG4gIH07XG4gIHByb3RvdHlwZS5zdGFydE1vdmluZ0xlZnQgPSBmdW5jdGlvbigpe1xuICAgIGlmICh0aGlzLm9uR3JvdW5kICYmIHRoaXMuYWNjZWxlcmF0aW9uWCA9PT0gMCkge1xuICAgICAgdGhpcy53YWxrQW5pbWF0aW9uLnJlc2V0KCk7XG4gICAgfVxuICAgIHRoaXMuaG9yaXpvbnRhbEZhY2luZyA9IFN0YXRlLkxFRlQ7XG4gICAgdGhpcy5hY2NlbGVyYXRpb25YID0gLTE7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJhY3RpbmcgPSBmYWxzZTtcbiAgfTtcbiAgcHJvdG90eXBlLnN0YXJ0TW92aW5nUmlnaHQgPSBmdW5jdGlvbigpe1xuICAgIGlmICh0aGlzLm9uR3JvdW5kICYmIHRoaXMuYWNjZWxlcmF0aW9uWCA9PT0gMCkge1xuICAgICAgdGhpcy53YWxrQW5pbWF0aW9uLnJlc2V0KCk7XG4gICAgfVxuICAgIHRoaXMuaG9yaXpvbnRhbEZhY2luZyA9IFN0YXRlLlJJR0hUO1xuICAgIHRoaXMuYWNjZWxlcmF0aW9uWCA9IDE7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJhY3RpbmcgPSBmYWxzZTtcbiAgfTtcbiAgcHJvdG90eXBlLnN0b3BNb3ZpbmcgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmFjY2VsZXJhdGlvblggPSAwO1xuICB9O1xuICBwcm90b3R5cGUuc3RhcnRKdW1wID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmp1bXBBY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuaW50ZXJhY3RpbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5vbkdyb3VuZCkge1xuICAgICAgcmV0dXJuIHRoaXMudmVsb2NpdHlZID0gLWtKdW1wU3BlZWQ7XG4gICAgfVxuICB9O1xuICBwcm90b3R5cGUuc3RvcEp1bXAgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmp1bXBBY3RpdmUgPSBmYWxzZTtcbiAgfTtcbiAgcHJvdG90eXBlLnN0YXJ0RmlyZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuZ3VuLnN0YXJ0RmlyZSh0aGlzLmdldFNwcml0ZVN0YXRlKCksIHRoaXMueCwgdGhpcy55KTtcbiAgfTtcbiAgcHJvdG90eXBlLnN0b3BGaXJlID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5ndW4uc3RvcEZpcmUoKTtcbiAgfTtcbiAgcHJvdG90eXBlLmxvb2tVcCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5pbnRlbmRlZFZlcnRpY2FsRmFjaW5nID0gU3RhdGUuVVA7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJhY3RpbmcgPSBmYWxzZTtcbiAgfTtcbiAgcHJvdG90eXBlLmxvb2tEb3duID0gZnVuY3Rpb24oKXtcbiAgICBpZiAodGhpcy5pbnRlbmRlZFZlcnRpY2FsRmFjaW5nID09PSBTdGF0ZS5ET1dOKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaW50ZW5kZWRWZXJ0aWNhbEZhY2luZyA9IFN0YXRlLkRPV047XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJhY3RpbmcgPSB0aGlzLm9uR3JvdW5kO1xuICB9O1xuICBwcm90b3R5cGUubG9va0hvcml6b250YWwgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmludGVuZGVkVmVydGljYWxGYWNpbmcgPSBTdGF0ZS5IT1JJWk9OVEFMO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCAnY2VudGVyWCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy54ICsga0hhbGZUaWxlO1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsICdjZW50ZXJZJywge1xuICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLnkgKyBrSGFsZlRpbGU7XG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KTtcbiAgcHJvdG90eXBlLmdldERhbWFnZVRleHQgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmRhbWFnZVRleHQ7XG4gIH07XG4gIHByb3RvdHlwZS5nZXRQcm9qZWN0aWxlcyA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuZ3VuLmdldFByb2plY3RpbGVzKCk7XG4gIH07XG4gIHByb3RvdHlwZS52ZXJ0aWNhbEZhY2luZyA9IGZ1bmN0aW9uKCl7XG4gICAgaWYgKHRoaXMub25Hcm91bmQgJiYgdGhpcy5pbnRlbmRlZFZlcnRpY2FsRmFjaW5nID09PSBTdGF0ZS5ET1dOKSB7XG4gICAgICByZXR1cm4gU3RhdGUuSE9SSVpPTlRBTDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaW50ZW5kZWRWZXJ0aWNhbEZhY2luZztcbiAgICB9XG4gIH07XG4gIHJldHVybiBQbGF5ZXI7XG59KERhbWFnZWFibGUpKTtcbmZ1bmN0aW9uIGV4dGVuZCQoc3ViLCBzdXApe1xuICBmdW5jdGlvbiBmdW4oKXt9IGZ1bi5wcm90b3R5cGUgPSAoc3ViLnN1cGVyY2xhc3MgPSBzdXApLnByb3RvdHlwZTtcbiAgKHN1Yi5wcm90b3R5cGUgPSBuZXcgZnVuKS5jb25zdHJ1Y3RvciA9IHN1YjtcbiAgaWYgKHR5cGVvZiBzdXAuZXh0ZW5kZWQgPT0gJ2Z1bmN0aW9uJykgc3VwLmV4dGVuZGVkKHN1Yik7XG4gIHJldHVybiBzdWI7XG59XG5mdW5jdGlvbiBpbXBvcnQkKG9iaiwgc3JjKXtcbiAgdmFyIG93biA9IHt9Lmhhc093blByb3BlcnR5O1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSBpZiAob3duLmNhbGwoc3JjLCBrZXkpKSBvYmpba2V5XSA9IHNyY1trZXldO1xuICByZXR1cm4gb2JqO1xufSIsInZhciBzdGQsIFBvbGFyVmVjdG9yLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG5vdXQkLlBvbGFyVmVjdG9yID0gUG9sYXJWZWN0b3IgPSAoZnVuY3Rpb24oKXtcbiAgUG9sYXJWZWN0b3IuZGlzcGxheU5hbWUgPSAnUG9sYXJWZWN0b3InO1xuICB2YXIgcHJvdG90eXBlID0gUG9sYXJWZWN0b3IucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IFBvbGFyVmVjdG9yO1xuICBmdW5jdGlvbiBQb2xhclZlY3RvcihtYWcsIGFuZ2xlKXtcbiAgICB0aGlzLm1hZyA9IG1hZztcbiAgICB0aGlzLmFuZ2xlID0gYW5nbGU7XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgJ3gnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMubWFnICogc3RkLmNvcyh0aGlzLmFuZ2xlKTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCAneScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5tYWcgKiBzdGQuc2luKHRoaXMuYW5nbGUpO1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBQb2xhclZlY3Rvcjtcbn0oKSk7IiwidmFyIFByb2plY3RpbGUsIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5vdXQkLlByb2plY3RpbGUgPSBQcm9qZWN0aWxlID0gKGZ1bmN0aW9uKCl7XG4gIFByb2plY3RpbGUuZGlzcGxheU5hbWUgPSAnUHJvamVjdGlsZSc7XG4gIHZhciBwcm90b3R5cGUgPSBQcm9qZWN0aWxlLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBQcm9qZWN0aWxlO1xuICBmdW5jdGlvbiBQcm9qZWN0aWxlKGRhbWFnZSl7XG4gICAgdGhpcy5jb250YWN0RGFtYWdlID0gZGFtYWdlO1xuICB9XG4gIHByb3RvdHlwZS5jb2xsaXNpb25SZWN0YW5nbGUgPSBmdW5jdGlvbigpe307XG4gIHByb3RvdHlwZS5jb2xsaWRlV2l0aEVuZW15ID0gZnVuY3Rpb24oKXt9O1xuICByZXR1cm4gUHJvamVjdGlsZTtcbn0oKSk7IiwidmFyIGNvbmZpZywgZWxtLCBhcHBseVN0eWxlcywgUmVhZGVyLCBob3N0LCByZWFkZXJzLCBpbnN0YWxsLCBhZGRSZWFkZXIsIHVwZGF0ZSwgcmVtb3ZlUmVhZGVyLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcbmVsbSA9IGJpbmQkKGRvY3VtZW50LCAnY3JlYXRlRWxlbWVudCcpO1xuYXBwbHlTdHlsZXMgPSBmdW5jdGlvbihlbCwgc3R5bGVzKXtcbiAgdmFyIGssIHYsIHJlc3VsdHMkID0gW107XG4gIGZvciAoayBpbiBzdHlsZXMpIHtcbiAgICB2ID0gc3R5bGVzW2tdO1xuICAgIHJlc3VsdHMkLnB1c2goZWwuc3R5bGVba10gPSB2KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cyQ7XG59O1xuUmVhZGVyID0gKGZ1bmN0aW9uKCl7XG4gIFJlYWRlci5kaXNwbGF5TmFtZSA9ICdSZWFkZXInO1xuICB2YXIgcHJvdG90eXBlID0gUmVhZGVyLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBSZWFkZXI7XG4gIGZ1bmN0aW9uIFJlYWRlcihuYW1lLCBsYWJlbFRleHQsIHZhbHVlKXtcbiAgICB2YXIgdGhhdDtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMubGFiZWxUZXh0ID0gbGFiZWxUZXh0O1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmRvbSA9IGVsbSgndHInKTtcbiAgICB0aGlzLmxhYmVsID0gZWxtKCd0ZCcpO1xuICAgIHRoaXMub3V0cHV0ID0gZWxtKCd0ZCcpO1xuICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMubGFiZWwpO1xuICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMub3V0cHV0KTtcbiAgICB0aGlzLmxhYmVsLmlubmVySFRNTCA9IHRoaXMubGFiZWxUZXh0O1xuICAgIGlmICh0aGF0ID0gdGhpcy52YWx1ZSkge1xuICAgICAgdGhpcy5vdXRwdXQuaW5uZXJIVE1MID0gdGhhdDtcbiAgICB9XG4gIH1cbiAgcHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0LmlubmVySFRNTCA9IHRoaXMudmFsdWU7XG4gIH07XG4gIHByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5kb20uc3R5bGVzLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH07XG4gIHByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5kb20uc3R5bGVzLmRpc3BsYXkgPSAnYmxvY2snO1xuICB9O1xuICBwcm90b3R5cGUuaW5zdGFsbCA9IGZ1bmN0aW9uKGhvc3Qpe1xuICAgIHJldHVybiBob3N0LmFwcGVuZENoaWxkKHRoaXMuZG9tKTtcbiAgfTtcbiAgcHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20pO1xuICB9O1xuICByZXR1cm4gUmVhZGVyO1xufSgpKTtcbmhvc3QgPSBlbG0oJ3RhYmxlJyk7XG5yZWFkZXJzID0ge307XG5hcHBseVN0eWxlcyhob3N0LCB7XG4gIGZvbnRGYW1pbHk6ICdtb25vc3BhY2UnLFxuICB3aWR0aDogJzEwMCUnLFxuICBwYWRkaW5nTGVmdDogJzEwcHgnLFxuICBjb2xvcjogJ2xpZ2h0Z3JleScsXG4gIGJvcmRlcldpZHRoOiBcIjNweCAxcHhcIlxufSk7XG5vdXQkLmluc3RhbGwgPSBpbnN0YWxsID0gZnVuY3Rpb24oKXtcbiAgaWYgKGNvbmZpZy5zaG93UmVhZG91dCkge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGhvc3QpO1xuICB9XG59O1xub3V0JC5hZGRSZWFkZXIgPSBhZGRSZWFkZXIgPSBmdW5jdGlvbihuYW1lLCBsYWJlbCwgdmFsdWUpe1xuICByZWFkZXJzW25hbWVdID0gbmV3IFJlYWRlcihuYW1lLCBsYWJlbCwgdmFsdWUpO1xuICByZXR1cm4gcmVhZGVyc1tuYW1lXS5pbnN0YWxsKGhvc3QpO1xufTtcbm91dCQudXBkYXRlID0gdXBkYXRlID0gZnVuY3Rpb24ocmVhZGVyTmFtZSwgdmFsdWUpe1xuICB2YXIgcmVmJDtcbiAgcmV0dXJuIChyZWYkID0gcmVhZGVyc1tyZWFkZXJOYW1lXSkgIT0gbnVsbCA/IHJlZiQudXBkYXRlKHZhbHVlKSA6IHZvaWQgODtcbn07XG5vdXQkLnJlbW92ZVJlYWRlciA9IHJlbW92ZVJlYWRlciA9IGZ1bmN0aW9uKG5hbWUpe1xuICB2YXIgcmVmJDtcbiAgcmVhZGVyc1tuYW1lXVsnZGVsZXRlJ10oKTtcbiAgcmV0dXJuIHJlZiQgPSByZWFkZXJzW25hbWVdLCBkZWxldGUgcmVhZGVyc1tuYW1lXSwgcmVmJDtcbn07XG5mdW5jdGlvbiBiaW5kJChvYmosIGtleSwgdGFyZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiAodGFyZ2V0IHx8IG9iailba2V5XS5hcHBseShvYmosIGFyZ3VtZW50cykgfTtcbn0iLCJ2YXIgdW5pdHMsIFJlY3RhbmdsZSwgU3ByaXRlU291cmNlLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xudW5pdHMgPSByZXF1aXJlKCcuL3VuaXRzJyk7XG5vdXQkLlJlY3RhbmdsZSA9IFJlY3RhbmdsZSA9IChmdW5jdGlvbigpe1xuICBSZWN0YW5nbGUuZGlzcGxheU5hbWUgPSAnUmVjdGFuZ2xlJztcbiAgdmFyIHByb3RvdHlwZSA9IFJlY3RhbmdsZS5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gUmVjdGFuZ2xlO1xuICBmdW5jdGlvbiBSZWN0YW5nbGUoeCwgeSwgdywgaCwgbSl7XG4gICAgbSA9PSBudWxsICYmIChtID0gMSk7XG4gICAgdGhpcy54ID0geCAqIG07XG4gICAgdGhpcy55ID0geSAqIG07XG4gICAgdGhpcy53ID0gdyAqIG07XG4gICAgdGhpcy5oID0gaCAqIG07XG4gICAgdGhpcy50b3AgPSB0aGlzLnk7XG4gICAgdGhpcy5sZWZ0ID0gdGhpcy54O1xuICAgIHRoaXMucmlnaHQgPSB0aGlzLnggKyB0aGlzLnc7XG4gICAgdGhpcy5ib3R0b20gPSB0aGlzLnkgKyB0aGlzLmg7XG4gIH1cbiAgcHJvdG90eXBlLmNvbGxpZGVzV2l0aCA9IGZ1bmN0aW9uKG90aGVyKXtcbiAgICByZXR1cm4gdGhpcy5yaWdodCA+PSBvdGhlci5sZWZ0ICYmIHRoaXMubGVmdCA8PSBvdGhlci5yaWdodCAmJiB0aGlzLnRvcCA8PSBvdGhlci5ib3R0b20gJiYgdGhpcy5ib3R0b20gPj0gb3RoZXIudG9wO1xuICB9O1xuICByZXR1cm4gUmVjdGFuZ2xlO1xufSgpKTtcbm91dCQuU3ByaXRlU291cmNlID0gU3ByaXRlU291cmNlID0gKGZ1bmN0aW9uKCl7XG4gIFNwcml0ZVNvdXJjZS5kaXNwbGF5TmFtZSA9ICdTcHJpdGVTb3VyY2UnO1xuICB2YXIgcHJvdG90eXBlID0gU3ByaXRlU291cmNlLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBTcHJpdGVTb3VyY2U7XG4gIGZ1bmN0aW9uIFNwcml0ZVNvdXJjZSh0aWxlWCwgdGlsZVksIHRpbGVXLCB0aWxlSCl7XG4gICAgdGlsZVcgPT0gbnVsbCAmJiAodGlsZVcgPSAxKTtcbiAgICB0aWxlSCA9PSBudWxsICYmICh0aWxlSCA9IDEpO1xuICAgIHRoaXMueCA9IHVuaXRzLnRpbGVUb1B4KHRpbGVYKTtcbiAgICB0aGlzLnkgPSB1bml0cy50aWxlVG9QeCh0aWxlWSk7XG4gICAgdGhpcy53ID0gdW5pdHMudGlsZVRvUHgodGlsZVcpO1xuICAgIHRoaXMuaCA9IHVuaXRzLnRpbGVUb1B4KHRpbGVIKTtcbiAgfVxuICByZXR1cm4gU3ByaXRlU291cmNlO1xufSgpKTsiLCJ2YXIgcmFmLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xucmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuaW1wb3J0JChvdXQkLCB7XG4gIGRlbGF5OiBmdW5jdGlvbih0aW1lLCDOuyl7XG4gICAgcmV0dXJuIHJhZijOuyk7XG4gIH1cbn0pO1xuZnVuY3Rpb24gaW1wb3J0JChvYmosIHNyYyl7XG4gIHZhciBvd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbiAgZm9yICh2YXIga2V5IGluIHNyYykgaWYgKG93bi5jYWxsKHNyYywga2V5KSkgb2JqW2tleV0gPSBzcmNba2V5XTtcbiAgcmV0dXJuIG9iajtcbn0iLCJ2YXIgc3RkLCBxdWV1ZSwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcbnN0ZCA9IHJlcXVpcmUoJ3N0ZCcpO1xucXVldWUgPSBbXTtcbmltcG9ydCQob3V0JCwge1xuICBwdXNoRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50KXtcbiAgICByZXR1cm4gcXVldWUucHVzaChldmVudCk7XG4gIH0sXG4gIHBvbGxFdmVudDogZnVuY3Rpb24oKXtcbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcXVldWUuc2hpZnQoKTtcbiAgICB9XG4gIH1cbn0pO1xuZnVuY3Rpb24gaW1wb3J0JChvYmosIHNyYyl7XG4gIHZhciBvd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbiAgZm9yICh2YXIga2V5IGluIHNyYykgaWYgKG93bi5jYWxsKHNyYywga2V5KSkgb2JqW2tleV0gPSBzcmNba2V5XTtcbiAgcmV0dXJuIG9iajtcbn0iLCJ2YXIgc3RkLCBkZWxheSwgdGltZXIsIHNjcmVlbiwga2V5Ym9hcmQsIGV2ZW50UXVldWUsIFJlY3QsIFN1cmZhY2UsIHJlZiQsIElOSVRfRVZFUllUSElORywgRlVMTFNDUkVFTiwgaW5pdCwgS0VZLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG5kZWxheSA9IHJlcXVpcmUoJy4vZGVsYXknKTtcbnRpbWVyID0gcmVxdWlyZSgnLi90aW1lcicpO1xuc2NyZWVuID0gcmVxdWlyZSgnLi9zY3JlZW4nKTtcbmtleWJvYXJkID0gcmVxdWlyZSgnLi9rZXlib2FyZCcpO1xuZXZlbnRRdWV1ZSA9IHJlcXVpcmUoJy4vZXZlbnQtcXVldWUnKTtcbm91dCQuUmVjdCA9IFJlY3QgPSByZXF1aXJlKCcuL3JlY3QnKTtcbm91dCQuU3VyZmFjZSA9IFN1cmZhY2UgPSByZXF1aXJlKCcuL3N1cmZhY2UnKTtcbnJlZiQgPSBzdGRbJ2VudW0nXSwgSU5JVF9FVkVSWVRISU5HID0gcmVmJFswXSwgRlVMTFNDUkVFTiA9IHJlZiRbMV07XG5vdXQkLmluaXQgPSBpbml0ID0gZnVuY3Rpb24obW9kZSl7XG4gIHN0ZC5sb2coXCJTREw6OkluaXQgLSB3aXRoIG1vZGU6XCIsIG1vZGUpO1xuICB0aW1lci5pbml0KCk7XG4gIHJldHVybiBrZXlib2FyZC5pbml0KCk7XG59O1xub3V0JC5JTklUX0VWRVJZVEhJTkcgPSBJTklUX0VWRVJZVEhJTkc7XG5vdXQkLkZVTExTQ1JFRU4gPSBGVUxMU0NSRUVOO1xub3V0JC5LRVlET1dOID0ga2V5Ym9hcmQuS0VZRE9XTjtcbm91dCQuS0VZVVAgPSBrZXlib2FyZC5LRVlVUDtcbm91dCQuS0VZID0gS0VZID0ga2V5Ym9hcmQuS0VZQ09ERVM7XG5vdXQkLmRlbGF5ID0gZGVsYXkuZGVsYXk7XG5vdXQkLmdldFRpY2tzID0gdGltZXIuZ2V0VGlja3M7XG5vdXQkLnBvbGxFdmVudCA9IGV2ZW50UXVldWUucG9sbEV2ZW50O1xub3V0JC5zZXRWaWRlb01vZGUgPSBzY3JlZW4uc2V0VmlkZW9Nb2RlO1xub3V0JC5ibGl0U3VyZmFjZSA9IFN1cmZhY2UuYmxpdFN1cmZhY2U7XG5vdXQkLnNldENvbG9yS2V5ID0gU3VyZmFjZS5zZXRDb2xvcktleTtcbm91dCQubG9hZEltYWdlID0gU3VyZmFjZS5sb2FkSW1hZ2U7IiwidmFyIHN0ZCwgcXVldWUsIHJlZiQsIEtFWURPV04sIEtFWVVQLCBLRVlDT0RFUywgbW9uaXRvcktleXMsIGluaXQsIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5zdGQgPSByZXF1aXJlKCdzdGQnKTtcbnF1ZXVlID0gcmVxdWlyZSgnLi9ldmVudC1xdWV1ZScpO1xucmVmJCA9IHN0ZFsnZW51bSddLCBLRVlET1dOID0gcmVmJFswXSwgS0VZVVAgPSByZWYkWzFdO1xub3V0JC5LRVlDT0RFUyA9IEtFWUNPREVTID0ge1xuICBFU0NBUEU6IDI3LFxuICBMRUZUOiAzNyxcbiAgVVA6IDM4LFxuICBSSUdIVDogMzksXG4gIERPV046IDQwLFxuICBPTkU6IDQ5LFxuICBUV086IDUwLFxuICBUSFJFRTogNTEsXG4gIEZPVVI6IDUyLFxuICBGSVZFOiA1MyxcbiAgU0lYOiA1NCxcbiAgU0VWRU46IDU1LFxuICBFSUdIVDogNTYsXG4gIE5JTkU6IDU3LFxuICBBOiA2NSxcbiAgUTogODEsXG4gIFM6IDgzLFxuICBXOiA4NyxcbiAgWDogODgsXG4gIFo6IDkwXG59O1xubW9uaXRvcktleXMgPSBmdW5jdGlvbigpe1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24oZXZlbnQpe1xuICAgIHZhciB3aGljaDtcbiAgICB3aGljaCA9IGV2ZW50LndoaWNoO1xuICAgIHF1ZXVlLnB1c2hFdmVudCh7XG4gICAgICB0eXBlOiBLRVlET1dOLFxuICAgICAga2V5OiB3aGljaFxuICAgIH0pO1xuICAgIGlmICh3aGljaCA9PT0gS0VZQ09ERVMuVVAgfHwgd2hpY2ggPT09IEtFWUNPREVTLkRPV04gfHwgd2hpY2ggPT09IEtFWUNPREVTLkxFRlQgfHwgd2hpY2ggPT09IEtFWUNPREVTLlJJR0hUKSB7XG4gICAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBmdW5jdGlvbihldmVudCl7XG4gICAgdmFyIHdoaWNoO1xuICAgIHdoaWNoID0gZXZlbnQud2hpY2g7XG4gICAgcXVldWUucHVzaEV2ZW50KHtcbiAgICAgIHR5cGU6IEtFWVVQLFxuICAgICAga2V5OiB3aGljaFxuICAgIH0pO1xuICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcbn07XG5vdXQkLmluaXQgPSBpbml0ID0gZnVuY3Rpb24oKXtcbiAgc3RkLmxvZyhcIlNETDo6S2V5Ym9hcmQgLSBNb25pdG9yaW5nIGtleSBpbnB1dFwiKTtcbiAgcmV0dXJuIG1vbml0b3JLZXlzKCk7XG59O1xub3V0JC5LRVlET1dOID0gS0VZRE9XTjtcbm91dCQuS0VZVVAgPSBLRVlVUDsiLCJ2YXIgUmVjdDtcbm1vZHVsZS5leHBvcnRzID0gUmVjdCA9IChmdW5jdGlvbigpe1xuICBSZWN0LmRpc3BsYXlOYW1lID0gJ1JlY3QnO1xuICB2YXIgcHJvdG90eXBlID0gUmVjdC5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gUmVjdDtcbiAgZnVuY3Rpb24gUmVjdCh4LCB5LCB3LCBoKXtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy53ID0gdztcbiAgICB0aGlzLmggPSBoO1xuICB9XG4gIFJlY3QuY2xvbmUgPSBmdW5jdGlvbihhcmckKXtcbiAgICB2YXIgeCwgeSwgdywgaDtcbiAgICB4ID0gYXJnJC54LCB5ID0gYXJnJC55LCB3ID0gYXJnJC53LCBoID0gYXJnJC5oO1xuICAgIHJldHVybiBuZXcgUmVjdCh4LCB5LCB3LCBoKTtcbiAgfTtcbiAgcmV0dXJuIFJlY3Q7XG59KCkpOyIsInZhciBzdGQsIFN1cmZhY2UsIGFwcGx5U2NhbGVTdHlsZXMsIGNyZWF0ZU5ld1NjcmVlbiwgc2V0VmlkZW9Nb2RlLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG5TdXJmYWNlID0gcmVxdWlyZSgnLi9zdXJmYWNlJyk7XG5hcHBseVNjYWxlU3R5bGVzID0gZnVuY3Rpb24oY2FudmFzLCBzY2FsZUZhY3Rvcil7XG4gIGlmIChzY2FsZUZhY3RvciAhPT0gMCkge1xuICAgIHJldHVybiBjYW52YXMuc3R5bGUud2lkdGggPSBjYW52YXMud2lkdGggKiBzY2FsZUZhY3RvciArICdweCc7XG4gIH1cbn07XG5jcmVhdGVOZXdTY3JlZW4gPSBmdW5jdGlvbih3LCBoLCBzY2FsZUZhY3Rvcil7XG4gIHZhciBzY3JlZW47XG4gIHNjcmVlbiA9IG5ldyBTdXJmYWNlKG51bGwsIHcsIGgpO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmVlbi5jYW52YXMpO1xuICBhcHBseVNjYWxlU3R5bGVzKHNjcmVlbi5jYW52YXMsIHNjYWxlRmFjdG9yKTtcbiAgcmV0dXJuIHNjcmVlbjtcbn07XG5vdXQkLnNldFZpZGVvTW9kZSA9IHNldFZpZGVvTW9kZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIHNjYWxlRmFjdG9yKXtcbiAgc2NhbGVGYWN0b3IgPT0gbnVsbCAmJiAoc2NhbGVGYWN0b3IgPSAxKTtcbiAgcmV0dXJuIGNyZWF0ZU5ld1NjcmVlbih3aWR0aCwgaGVpZ2h0LCBzY2FsZUZhY3Rvcik7XG59OyIsInZhciBzdGQsIFJlY3QsIG1ha2VUcmFuc3BhcmVudCwgU3VyZmFjZTtcbnN0ZCA9IHJlcXVpcmUoJ3N0ZCcpO1xuUmVjdCA9IHJlcXVpcmUoJy4vcmVjdCcpO1xubWFrZVRyYW5zcGFyZW50ID0gZnVuY3Rpb24oZGF0YSwgY29sb3Ipe1xuICB2YXIgY2FudmFzLCBjb250ZXh0LCBwaXhlbHMsIGkkLCB0byQsIGk7XG4gIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICBjYW52YXMud2lkdGggPSBkYXRhLndpZHRoO1xuICBjYW52YXMuaGVpZ2h0ID0gZGF0YS5oZWlnaHQ7XG4gIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgY29udGV4dC5kcmF3SW1hZ2UoZGF0YSwgMCwgMCk7XG4gIHBpeGVscyA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIGZvciAoaSQgPSAwLCB0byQgPSBwaXhlbHMuZGF0YS5sZW5ndGg7IGkkIDw9IHRvJDsgaSQgKz0gNCkge1xuICAgIGkgPSBpJDtcbiAgICBpZiAocGl4ZWxzLmRhdGFbaSArIDBdID09PSBjb2xvclswXSAmJiBwaXhlbHMuZGF0YVtpICsgMV0gPT09IGNvbG9yWzFdICYmIHBpeGVscy5kYXRhW2kgKyAyXSA9PT0gY29sb3JbMl0pIHtcbiAgICAgIHBpeGVscy5kYXRhW2kgKyAzXSA9IDA7XG4gICAgfVxuICB9XG4gIGNvbnRleHQucHV0SW1hZ2VEYXRhKHBpeGVscywgMCwgMCk7XG4gIHJldHVybiBjYW52YXM7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBTdXJmYWNlID0gKGZ1bmN0aW9uKCl7XG4gIFN1cmZhY2UuZGlzcGxheU5hbWUgPSAnU3VyZmFjZSc7XG4gIHZhciBwcm90b3R5cGUgPSBTdXJmYWNlLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBTdXJmYWNlO1xuICBmdW5jdGlvbiBTdXJmYWNlKHNyYywgd2lkdGgsIGhlaWdodCl7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgICB0aGlzLmNvbG9yS2V5ID0gbnVsbDtcbiAgICB0aGlzLnJlc2V0Q2FudmFzU2l6ZSgpO1xuICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9ICdyZWQnO1xuICAgIHRoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMubG9hZEltYWdlRGF0YShzcmMpO1xuICAgIH0gZWxzZSBpZiAoc3JjICE9IG51bGwpIHtcbiAgICAgIHRoaXMuc2F2ZUltYWdlRGF0YShzcmMpO1xuICAgIH0gZWxzZSB7fVxuICB9XG4gIHByb3RvdHlwZS5yZXNldENhbnZhc1NpemUgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICByZXR1cm4gdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gIH07XG4gIHByb3RvdHlwZS5pbmhlcml0U2l6ZUZyb21JbWFnZSA9IGZ1bmN0aW9uKGRhdGEpe1xuICAgIGlmICh0aGlzLndpZHRoID09IG51bGwgJiYgdGhpcy5oZWlnaHQgPT0gbnVsbCkge1xuICAgICAgdGhpcy53aWR0aCA9IGRhdGEubmF0dXJhbFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSBkYXRhLm5hdHVyYWxIZWlnaHQ7XG4gICAgICByZXR1cm4gdGhpcy5yZXNldENhbnZhc1NpemUoKTtcbiAgICB9XG4gIH07XG4gIHByb3RvdHlwZS5sb2FkSW1hZ2VEYXRhID0gZnVuY3Rpb24ocGF0aCl7XG4gICAgdmFyIGRhdGEsIHRoaXMkID0gdGhpcztcbiAgICBkYXRhID0gbmV3IEltYWdlO1xuICAgIGRhdGEub25sb2FkID0gZnVuY3Rpb24oKXtcbiAgICAgIHRoaXMkLmluaGVyaXRTaXplRnJvbUltYWdlKGRhdGEpO1xuICAgICAgcmV0dXJuIHRoaXMkLnNhdmVJbWFnZURhdGEoZGF0YSk7XG4gICAgfTtcbiAgICBkYXRhLm9uZXJyb3IgPSBmdW5jdGlvbigpe1xuICAgICAgc3RkLmxvZyhcIkNhbnQgbG9hZDpcIiwgcGF0aCk7XG4gICAgICByZXR1cm4gdGhpcyQuY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMkLndpZHRoLCB0aGlzJC5oZWlnaHQpO1xuICAgIH07XG4gICAgcmV0dXJuIGRhdGEuc3JjID0gcGF0aDtcbiAgfTtcbiAgcHJvdG90eXBlLnNhdmVJbWFnZURhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgICB0aGlzLmRhdGEgPSB0aGlzLmNvbG9yS2V5ID8gbWFrZVRyYW5zcGFyZW50KGRhdGEsIHRoaXMuY29sb3JLZXkpIDogZGF0YTtcbiAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIHJldHVybiB0aGlzLmN0eC5kcmF3SW1hZ2UodGhpcy5kYXRhLCAwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gIH07XG4gIHByb3RvdHlwZS5zZXRDb2xvcktleSA9IGZ1bmN0aW9uKGNvbG9yKXtcbiAgICB0aGlzLmNvbG9yS2V5ID0gY29sb3I7XG4gICAgaWYgKHRoaXMucmVhZHkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNhdmVJbWFnZURhdGEodGhpcy5kYXRhKTtcbiAgICB9XG4gIH07XG4gIHByb3RvdHlwZS5kcmF3UmVjdCA9IGZ1bmN0aW9uKHJlY3QsIGNvbG9yKXtcbiAgICBjb2xvciA9PSBudWxsICYmIChjb2xvciA9ICdibGFjaycpO1xuICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgIHJldHVybiB0aGlzLmN0eC5maWxsUmVjdChyZWN0LngsIHJlY3QueSwgcmVjdC53LCByZWN0LmgpO1xuICB9O1xuICBwcm90b3R5cGUuZHJhd0JveCA9IGZ1bmN0aW9uKHJlY3QsIGNvbG9yKXtcbiAgICBjb2xvciA9PSBudWxsICYmIChjb2xvciA9ICdibGFjaycpO1xuICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgdGhpcy5jdHgubW92ZVRvKDAuNSArIHJlY3QueCwgMC41ICsgcmVjdC55KTtcbiAgICB0aGlzLmN0eC5saW5lVG8oMC41ICsgcmVjdC54LCAtMC41ICsgcmVjdC55ICsgcmVjdC5oKTtcbiAgICB0aGlzLmN0eC5saW5lVG8oLTAuNSArIHJlY3QueCArIHJlY3QudywgLTAuNSArIHJlY3QueSArIHJlY3QuaCk7XG4gICAgdGhpcy5jdHgubGluZVRvKC0wLjUgKyByZWN0LnggKyByZWN0LncsIDAuNSArIHJlY3QueSk7XG4gICAgdGhpcy5jdHgubGluZVRvKDAuNSArIHJlY3QueCwgMC41ICsgcmVjdC55KTtcbiAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICByZXR1cm4gdGhpcy5jdHguY2xvc2VQYXRoKCk7XG4gIH07XG4gIHByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gIH07XG4gIFN1cmZhY2Uuc2V0Q29sb3JLZXkgPSBmdW5jdGlvbihzdXJmYWNlLCBjb2xvcil7XG4gICAgcmV0dXJuIHN1cmZhY2Uuc2V0Q29sb3JLZXkoY29sb3IpO1xuICB9O1xuICBTdXJmYWNlLmJsaXRTdXJmYWNlID0gZnVuY3Rpb24oc291cmNlLCBzcmNSZWN0LCBkZXN0LCBkZXN0UmVjdCl7XG4gICAgaWYgKHNyY1JlY3QpIHtcbiAgICAgIHJldHVybiBkZXN0LmN0eC5kcmF3SW1hZ2Uoc291cmNlLmNhbnZhcywgc3JjUmVjdC54LCBzcmNSZWN0LnksIHNyY1JlY3Qudywgc3JjUmVjdC5oLCBkZXN0UmVjdC54LCBkZXN0UmVjdC55LCBkZXN0UmVjdC53LCBkZXN0UmVjdC5oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRlc3QuY3R4LmRyYXdJbWFnZShzb3VyY2UuY2FudmFzLCBkZXN0UmVjdC54LCBkZXN0UmVjdC55LCBkZXN0UmVjdC53LCBkZXN0UmVjdC5oKTtcbiAgICB9XG4gIH07XG4gIFN1cmZhY2UubG9hZEltYWdlID0gZnVuY3Rpb24ocGF0aCl7XG4gICAgcmV0dXJuIG5ldyBTdXJmYWNlKHBhdGgpO1xuICB9O1xuICByZXR1cm4gU3VyZmFjZTtcbn0oKSk7IiwidmFyIHN0YXJ0VGltZSwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcbnN0YXJ0VGltZSA9IDA7XG5pbXBvcnQkKG91dCQsIHtcbiAgaW5pdDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgfSxcbiAgZ2V0VGlja3M6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gIH1cbn0pO1xuZnVuY3Rpb24gaW1wb3J0JChvYmosIHNyYyl7XG4gIHZhciBvd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbiAgZm9yICh2YXIga2V5IGluIHNyYykgaWYgKG93bi5jYWxsKHNyYywga2V5KSkgb2JqW2tleV0gPSBzcmNba2V5XTtcbiAgcmV0dXJuIG9iajtcbn0iLCJ2YXIgU0RMLCBzdGQsIHVuaXRzLCBkaXYsIGtIYWxmVGlsZSwgdGlsZVRvUHgsIGdhbWVUb1B4LCBUaW1lciwgcmVmJCwgUmVjdCwgU3ByaXRlU291cmNlLCBTcHJpdGUsIEFuaW1hdGVkU3ByaXRlLCBOdW1iZXJTcHJpdGUsIFZhcnlpbmdXaWR0aFNwcml0ZSwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcblNETCA9IHJlcXVpcmUoJ1NETCcpO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG51bml0cyA9IHJlcXVpcmUoJy4vdW5pdHMnKTtcbmRpdiA9IHN0ZC5kaXY7XG5rSGFsZlRpbGUgPSB1bml0cy5rSGFsZlRpbGUsIHRpbGVUb1B4ID0gdW5pdHMudGlsZVRvUHgsIGdhbWVUb1B4ID0gdW5pdHMuZ2FtZVRvUHg7XG5UaW1lciA9IHJlcXVpcmUoJy4vdGltZXInKS5UaW1lcjtcbnJlZiQgPSByZXF1aXJlKCcuL3JlY3RhbmdsZScpLCBSZWN0ID0gcmVmJC5SZWN0YW5nbGUsIFNwcml0ZVNvdXJjZSA9IHJlZiQuU3ByaXRlU291cmNlO1xub3V0JC5TcHJpdGUgPSBTcHJpdGUgPSAoZnVuY3Rpb24oKXtcbiAgU3ByaXRlLmRpc3BsYXlOYW1lID0gJ1Nwcml0ZSc7XG4gIHZhciBwcm90b3R5cGUgPSBTcHJpdGUucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IFNwcml0ZTtcbiAgZnVuY3Rpb24gU3ByaXRlKGdyYXBoaWNzLCBwYXRoLCBzcmMpe1xuICAgIHRoaXMuc3JjID0gc3JjO1xuICAgIHRoaXMuc291cmNlUmVjdCA9IG5ldyBTREwuUmVjdC5jbG9uZSh0aGlzLnNyYyk7XG4gICAgdGhpcy5zcHJpdGVTaGVldCA9IGdyYXBoaWNzLmxvYWRJbWFnZShwYXRoLCB0cnVlKTtcbiAgfVxuICBwcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXt9O1xuICBwcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGdyYXBoaWNzLCB4LCB5KXtcbiAgICB2YXIgZGVzdFJlY3Q7XG4gICAgZGVzdFJlY3QgPSBuZXcgU0RMLlJlY3QoZ2FtZVRvUHgoeCksIGdhbWVUb1B4KHkpLCB0aGlzLnNyYy53LCB0aGlzLnNyYy5oKTtcbiAgICByZXR1cm4gZ3JhcGhpY3MuYmxpdFN1cmZhY2UodGhpcy5zcHJpdGVTaGVldCwgdGhpcy5zb3VyY2VSZWN0LCBkZXN0UmVjdCk7XG4gIH07XG4gIHJldHVybiBTcHJpdGU7XG59KCkpO1xub3V0JC5BbmltYXRlZFNwcml0ZSA9IEFuaW1hdGVkU3ByaXRlID0gKGZ1bmN0aW9uKHN1cGVyY2xhc3Mpe1xuICB2YXIgcHJvdG90eXBlID0gZXh0ZW5kJCgoaW1wb3J0JChBbmltYXRlZFNwcml0ZSwgc3VwZXJjbGFzcykuZGlzcGxheU5hbWUgPSAnQW5pbWF0ZWRTcHJpdGUnLCBBbmltYXRlZFNwcml0ZSksIHN1cGVyY2xhc3MpLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBBbmltYXRlZFNwcml0ZTtcbiAgZnVuY3Rpb24gQW5pbWF0ZWRTcHJpdGUoZ3JhcGhpY3MsIHBhdGgsIHNyYywgZnBzLCBrZXlmcmFtZXMpe1xuICAgIHRoaXMuc3JjID0gc3JjO1xuICAgIHRoaXMuZnBzID0gZnBzO1xuICAgIHRoaXMua2V5ZnJhbWVzID0ga2V5ZnJhbWVzO1xuICAgIEFuaW1hdGVkU3ByaXRlLnN1cGVyY2xhc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLmZyYW1lVGltZXIgPSBuZXcgVGltZXIoMTAwMCAvIHRoaXMuZnBzKTtcbiAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XG4gICAgdGhpcy5jdXJyZW50S2V5ZnJhbWUgPSB0aGlzLmtleWZyYW1lc1swXTtcbiAgICB0aGlzLm9yaWdpblggPSB0aGlzLnNyYy54O1xuICAgIHRoaXMubnVtQ29tcGxldGVkTG9vcHMgPSAwO1xuICB9XG4gIHByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZ3JhcGhpY3MsIHgsIHksIGZyYW1lT2Zmc2V0KXtcbiAgICB2YXIgZGVzdFJlY3Q7XG4gICAgZnJhbWVPZmZzZXQgPT0gbnVsbCAmJiAoZnJhbWVPZmZzZXQgPSB0aGlzLmN1cnJlbnRLZXlmcmFtZSk7XG4gICAgdGhpcy5zb3VyY2VSZWN0LnggPSB0aGlzLm9yaWdpblggKyBmcmFtZU9mZnNldCAqIHRoaXMuc291cmNlUmVjdC53O1xuICAgIGRlc3RSZWN0ID0gbmV3IFNETC5SZWN0KGdhbWVUb1B4KHgpLCBnYW1lVG9QeCh5KSwgdGhpcy5zcmMudywgdGhpcy5zcmMuaCk7XG4gICAgcmV0dXJuIGdyYXBoaWNzLmJsaXRTdXJmYWNlKHRoaXMuc3ByaXRlU2hlZXQsIHRoaXMuc291cmNlUmVjdCwgZGVzdFJlY3QpO1xuICB9O1xuICBwcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICBpZiAodGhpcy5mcmFtZVRpbWVyLmlzRXhwaXJlZCkge1xuICAgICAgdGhpcy5mcmFtZVRpbWVyLnJlc2V0KCk7XG4gICAgICB0aGlzLmN1cnJlbnRGcmFtZSArPSAxO1xuICAgICAgaWYgKHRoaXMuY3VycmVudEZyYW1lID49IHRoaXMua2V5ZnJhbWVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLm51bUNvbXBsZXRlZExvb3BzICs9IDE7XG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRLZXlmcmFtZSA9IHRoaXMua2V5ZnJhbWVzW3RoaXMuY3VycmVudEZyYW1lXTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBBbmltYXRlZFNwcml0ZTtcbn0oU3ByaXRlKSk7XG5vdXQkLk51bWJlclNwcml0ZSA9IE51bWJlclNwcml0ZSA9IChmdW5jdGlvbigpe1xuICBOdW1iZXJTcHJpdGUuZGlzcGxheU5hbWUgPSAnTnVtYmVyU3ByaXRlJztcbiAgdmFyIGtEaWdpdFNyY1ksIGtPcFBsdXNTcmNYLCBrT3BNaW51c1NyY1gsIGtPcFNyY1ksIGtEaWdpdFNpemUsIGtSYWRpeCwgcmVmJCwgV0hJVEUsIFJFRCwgUExVUywgTUlOVVMsIE5PTkUsIHByb3RvdHlwZSA9IE51bWJlclNwcml0ZS5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gTnVtYmVyU3ByaXRlO1xuICBrRGlnaXRTcmNZID0gMy41O1xuICBrT3BQbHVzU3JjWCA9IDI7XG4gIGtPcE1pbnVzU3JjWCA9IDIuNTtcbiAga09wU3JjWSA9IDM7XG4gIGtEaWdpdFNpemUgPSB1bml0cy5rSGFsZlRpbGU7XG4gIGtSYWRpeCA9IDEwO1xuICByZWYkID0gc3RkWydlbnVtJ10sIFdISVRFID0gcmVmJFswXSwgUkVEID0gcmVmJFsxXTtcbiAgcmVmJCA9IHN0ZFsnZW51bSddLCBQTFVTID0gcmVmJFswXSwgTUlOVVMgPSByZWYkWzFdLCBOT05FID0gcmVmJFsyXTtcbiAgZnVuY3Rpb24gTnVtYmVyU3ByaXRlKGdyYXBoaWNzLCBudW0sIGxlbiwgY29sb3IsIG9wKXtcbiAgICB2YXIgc3JjWTtcbiAgICB0aGlzLm51bSA9IG51bTtcbiAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gICAgdGhpcy5vcCA9IG9wO1xuICAgIHRoaXMuZGlnaXRzID0gTnVtYmVyU3ByaXRlLnNlcGVyYXRlRGlnaXRzKHRoaXMubnVtKTtcbiAgICB0aGlzLm51bURpZ2l0cyA9IHRoaXMuZGlnaXRzLmxlbmd0aDtcbiAgICB0aGlzLnBhZGRpbmcgPSB0aGlzLmxlbiA9PT0gMFxuICAgICAgPyAwXG4gICAgICA6IGtEaWdpdFNpemUgKiAodGhpcy5sZW4gLSB0aGlzLm51bURpZ2l0cyk7XG4gICAgc3JjWSA9IHRoaXMuY29sb3IgPT09IFdISVRFXG4gICAgICA/IGtEaWdpdFNyY1lcbiAgICAgIDoga0RpZ2l0U3JjWSArIDAuNTtcbiAgICB0aGlzLmdseXBocyA9IHRoaXMuZGlnaXRzLm1hcChmdW5jdGlvbihpdCl7XG4gICAgICByZXR1cm4gbmV3IFNwcml0ZShncmFwaGljcywgJ1RleHRCb3gnLCBuZXcgU3ByaXRlU291cmNlKDAuNSAqIGl0LCBzcmNZLCAwLjUsIDAuNSkpO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLm9wID09PSBQTFVTKSB7XG4gICAgICB0aGlzLmdseXBocy5wdXNoKG5ldyBTcHJpdGUoZ3JhcGhpY3MsICdUZXh0Qm94JywgbmV3IFNwcml0ZVNvdXJjZShrT3BQbHVzU3JjWCwga09wU3JjWSwgMC41LCAwLjUpKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wID09PSBNSU5VUykge1xuICAgICAgdGhpcy5nbHlwaHMucHVzaChuZXcgU3ByaXRlKGdyYXBoaWNzLCAnVGV4dEJveCcsIG5ldyBTcHJpdGVTb3VyY2Uoa09wTWludXNTcmNYLCBrT3BTcmNZLCAwLjUsIDAuNSkpKTtcbiAgICB9XG4gICAgdGhpcy53aWR0aCA9IGtIYWxmVGlsZSAqIHRoaXMuZ2x5cGhzLmxlbmd0aDtcbiAgICB0aGlzLmhlaWdodCA9IGtIYWxmVGlsZTtcbiAgfVxuICBwcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGdyYXBoaWNzLCB4LCB5KXtcbiAgICB2YXIgaSQsIHJlZiQsIGxlbiQsIGksIGdseXBoLCBvZmZzZXQsIHJlc3VsdHMkID0gW107XG4gICAgZm9yIChpJCA9IDAsIGxlbiQgPSAocmVmJCA9IHRoaXMuZ2x5cGhzKS5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgICAgaSA9IGkkO1xuICAgICAgZ2x5cGggPSByZWYkW2kkXTtcbiAgICAgIG9mZnNldCA9IGtEaWdpdFNpemUgKiAodGhpcy5nbHlwaHMubGVuZ3RoIC0gMSAtIGkpO1xuICAgICAgcmVzdWx0cyQucHVzaChnbHlwaC5kcmF3KGdyYXBoaWNzLCB4ICsgdGhpcy5wYWRkaW5nICsgb2Zmc2V0LCB5KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzJDtcbiAgfTtcbiAgcHJvdG90eXBlLmRyYXdDZW50ZXJlZCA9IGZ1bmN0aW9uKGdyYXBoaWNzLCB4LCB5KXtcbiAgICByZXR1cm4gdGhpcy5kcmF3KGdyYXBoaWNzLCB4IC0gdGhpcy53aWR0aCAvIDIsIHkgLSB0aGlzLmhlaWdodCAvIDIpO1xuICB9O1xuICBOdW1iZXJTcHJpdGUuc2VwZXJhdGVEaWdpdHMgPSBmdW5jdGlvbihudW0pe1xuICAgIHZhciBkaWdpdCwgcmVzdWx0cyQgPSBbXTtcbiAgICBpZiAobnVtID09PSAwKSB7XG4gICAgICByZXR1cm4gWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAobnVtICE9PSAwKSB7XG4gICAgICAgIGRpZ2l0ID0gbnVtICUga1JhZGl4O1xuICAgICAgICBudW0gPSBkaXYobnVtLCBrUmFkaXgpO1xuICAgICAgICByZXN1bHRzJC5wdXNoKGRpZ2l0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzJDtcbiAgICB9XG4gIH07XG4gIE51bWJlclNwcml0ZS5IVUROdW1iZXIgPSBmdW5jdGlvbihncmFwaGljcywgbnVtLCBsZW4pe1xuICAgIHRoaXMubnVtID0gbnVtO1xuICAgIHRoaXMubGVuID0gbGVuO1xuICAgIHJldHVybiBuZXcgTnVtYmVyU3ByaXRlKGdyYXBoaWNzLCB0aGlzLm51bSwgdGhpcy5sZW4sIFdISVRFLCBOT05FKTtcbiAgfTtcbiAgTnVtYmVyU3ByaXRlLkRhbWFnZU51bWJlciA9IGZ1bmN0aW9uKGdyYXBoaWNzLCBudW0pe1xuICAgIHRoaXMubnVtID0gbnVtO1xuICAgIHJldHVybiBuZXcgTnVtYmVyU3ByaXRlKGdyYXBoaWNzLCB0aGlzLm51bSwgMCwgUkVELCBNSU5VUyk7XG4gIH07XG4gIE51bWJlclNwcml0ZS5FeHBlcmllbmNlTnVtYmVyID0gZnVuY3Rpb24oZ3JhcGhpY3MsIG51bSl7XG4gICAgdGhpcy5udW0gPSBudW07XG4gICAgcmV0dXJuIG5ldyBOdW1iZXJTcHJpdGUoZ3JhcGhpY3MsIHRoaXMubnVtLCAwLCBXSElURSwgUExVUyk7XG4gIH07XG4gIHJldHVybiBOdW1iZXJTcHJpdGU7XG59KCkpO1xub3V0JC5WYXJ5aW5nV2lkdGhTcHJpdGUgPSBWYXJ5aW5nV2lkdGhTcHJpdGUgPSAoZnVuY3Rpb24oc3VwZXJjbGFzcyl7XG4gIHZhciBwcm90b3R5cGUgPSBleHRlbmQkKChpbXBvcnQkKFZhcnlpbmdXaWR0aFNwcml0ZSwgc3VwZXJjbGFzcykuZGlzcGxheU5hbWUgPSAnVmFyeWluZ1dpZHRoU3ByaXRlJywgVmFyeWluZ1dpZHRoU3ByaXRlKSwgc3VwZXJjbGFzcykucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IFZhcnlpbmdXaWR0aFNwcml0ZTtcbiAgZnVuY3Rpb24gVmFyeWluZ1dpZHRoU3ByaXRlKGdyYXBoaWNzLCBwYXRoLCBzcmMpe1xuICAgIHRoaXMuc3JjID0gc3JjO1xuICAgIFZhcnlpbmdXaWR0aFNwcml0ZS5zdXBlcmNsYXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbiAgcHJvdG90eXBlLnNldFdpZHRoID0gZnVuY3Rpb24od2lkdGgpe1xuICAgIHJldHVybiB0aGlzLnNyYy53ID0gd2lkdGg7XG4gIH07XG4gIHJldHVybiBWYXJ5aW5nV2lkdGhTcHJpdGU7XG59KFNwcml0ZSkpO1xuZnVuY3Rpb24gZXh0ZW5kJChzdWIsIHN1cCl7XG4gIGZ1bmN0aW9uIGZ1bigpe30gZnVuLnByb3RvdHlwZSA9IChzdWIuc3VwZXJjbGFzcyA9IHN1cCkucHJvdG90eXBlO1xuICAoc3ViLnByb3RvdHlwZSA9IG5ldyBmdW4pLmNvbnN0cnVjdG9yID0gc3ViO1xuICBpZiAodHlwZW9mIHN1cC5leHRlbmRlZCA9PSAnZnVuY3Rpb24nKSBzdXAuZXh0ZW5kZWQoc3ViKTtcbiAgcmV0dXJuIHN1Yjtcbn1cbmZ1bmN0aW9uIGltcG9ydCQob2JqLCBzcmMpe1xuICB2YXIgb3duID0ge30uaGFzT3duUHJvcGVydHk7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIGlmIChvd24uY2FsbChzcmMsIGtleSkpIG9ialtrZXldID0gc3JjW2tleV07XG4gIHJldHVybiBvYmo7XG59IiwidmFyIHN0ZCwgdW5pdHMsIE5PTkUsIFNUQU5ESU5HLCBXQUxLSU5HLCBKVU1QSU5HLCBGQUxMSU5HLCBJTlRFUkFDVElORywgTEVGVCwgUklHSFQsIFVQLCBET1dOLCBIT1JJWk9OVEFMLCBTVFJJREVfTEVGVCwgU1RSSURFX1JJR0hULCBTVFJJREVfTUlERExFLCBTdGF0ZSwgbW90aW9ucywgaGZhY2luZ3MsIHZmYWNpbmdzLCBzdHJpZGVzLCBTcHJpdGVTdGF0ZSwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcbnN0ZCA9IHJlcXVpcmUoJ3N0ZCcpO1xudW5pdHMgPSByZXF1aXJlKCcuL3VuaXRzJyk7XG5OT05FID0gTWF0aC5wb3coMiwgMCk7XG5TVEFORElORyA9IE1hdGgucG93KDIsIDEpO1xuV0FMS0lORyA9IE1hdGgucG93KDIsIDIpO1xuSlVNUElORyA9IE1hdGgucG93KDIsIDMpO1xuRkFMTElORyA9IE1hdGgucG93KDIsIDQpO1xuSU5URVJBQ1RJTkcgPSBNYXRoLnBvdygyLCA1KTtcbkxFRlQgPSBNYXRoLnBvdygyLCA2KTtcblJJR0hUID0gTWF0aC5wb3coMiwgNyk7XG5VUCA9IE1hdGgucG93KDIsIDgpO1xuRE9XTiA9IE1hdGgucG93KDIsIDkpO1xuSE9SSVpPTlRBTCA9IE1hdGgucG93KDIsIDEwKTtcblNUUklERV9MRUZUID0gTWF0aC5wb3coMiwgMTEpO1xuU1RSSURFX1JJR0hUID0gTWF0aC5wb3coMiwgMTIpO1xuU1RSSURFX01JRERMRSA9IE1hdGgucG93KDIsIDEzKTtcbm91dCQuU3RhdGUgPSBTdGF0ZSA9IHtcbiAgTk9ORTogTk9ORSxcbiAgU1RBTkRJTkc6IFNUQU5ESU5HLFxuICBXQUxLSU5HOiBXQUxLSU5HLFxuICBKVU1QSU5HOiBKVU1QSU5HLFxuICBGQUxMSU5HOiBGQUxMSU5HLFxuICBJTlRFUkFDVElORzogSU5URVJBQ1RJTkcsXG4gIExFRlQ6IExFRlQsXG4gIFJJR0hUOiBSSUdIVCxcbiAgVVA6IFVQLFxuICBET1dOOiBET1dOLFxuICBIT1JJWk9OVEFMOiBIT1JJWk9OVEFMLFxuICBTVFJJREVfTEVGVDogU1RSSURFX0xFRlQsXG4gIFNUUklERV9SSUdIVDogU1RSSURFX1JJR0hULFxuICBTVFJJREVfTUlERExFOiBTVFJJREVfTUlERExFXG59O1xub3V0JC5tb3Rpb25zID0gbW90aW9ucyA9IFtTVEFORElORywgV0FMS0lORywgSlVNUElORywgRkFMTElORywgSU5URVJBQ1RJTkddO1xub3V0JC5oZmFjaW5ncyA9IGhmYWNpbmdzID0gW0xFRlQsIFJJR0hUXTtcbm91dCQudmZhY2luZ3MgPSB2ZmFjaW5ncyA9IFtVUCwgRE9XTiwgSE9SSVpPTlRBTF07XG5vdXQkLnN0cmlkZXMgPSBzdHJpZGVzID0gW1NUUklERV9MRUZULCBTVFJJREVfUklHSFQsIFNUUklERV9NSURETEVdO1xub3V0JC5TcHJpdGVTdGF0ZSA9IFNwcml0ZVN0YXRlID0ge1xuICBtYWtlOiBmdW5jdGlvbihoZmFjaW5nLCB2ZmFjaW5nLCBtb3Rpb24sIHN0cmlkZSl7XG4gICAgbW90aW9uID09IG51bGwgJiYgKG1vdGlvbiA9IE5PTkUpO1xuICAgIHN0cmlkZSA9PSBudWxsICYmIChzdHJpZGUgPSBOT05FKTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBoZmFjaW5nIHwgdmZhY2luZyB8IG1vdGlvbiB8IHN0cmlkZSxcbiAgICAgIFVQOiB2ZmFjaW5nID09PSBVUCxcbiAgICAgIERPV046IHZmYWNpbmcgPT09IERPV04sXG4gICAgICBMRUZUOiBoZmFjaW5nID09PSBMRUZULFxuICAgICAgUklHSFQ6IGhmYWNpbmcgPT09IFJJR0hULFxuICAgICAgV0FMS0lORzogbW90aW9uID09PSBXQUxLSU5HLFxuICAgICAgSlVNUElORzogbW90aW9uID09PSBKVU1QSU5HLFxuICAgICAgRkFMTElORzogbW90aW9uID09PSBGQUxMSU5HLFxuICAgICAgU1RBTkRJTkc6IG1vdGlvbiA9PT0gU1RBTkRJTkcsXG4gICAgICBIT1JJWk9OVEFMOiB2ZmFjaW5nID09PSBIT1JJWk9OVEFMLFxuICAgICAgSU5URVJBQ1RJTkc6IG1vdGlvbiA9PT0gSU5URVJBQ1RJTkcsXG4gICAgICBTVFJJREVfTEVGVDogc3RyaWRlID09PSBTVFJJREVfTEVGVCxcbiAgICAgIFNUUklERV9SSUdIVDogc3RyaWRlID09PSBTVFJJREVfUklHSFQsXG4gICAgICBTVFJJREVfTUlERExFOiBzdHJpZGUgPT09IFNUUklERV9NSURETEVcbiAgICB9O1xuICB9LFxuICBnZW5lcmF0ZVdpdGg6IGZ1bmN0aW9uKGZuKXtcbiAgICB2YXIgbSwgaCwgdiwgcywgc3M7XG4gICAgcmV0dXJuIHN0ZC5tYXNoKChmdW5jdGlvbigpe1xuICAgICAgdmFyIGkkLCByZWYkLCBsZW4kLCBqJCwgcmVmMSQsIGxlbjEkLCBrJCwgcmVmMiQsIGxlbjIkLCBsJCwgcmVmMyQsIGxlbjMkLCByZXN1bHRzJCA9IFtdO1xuICAgICAgZm9yIChpJCA9IDAsIGxlbiQgPSAocmVmJCA9IG1vdGlvbnMpLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgICAgIG0gPSByZWYkW2kkXTtcbiAgICAgICAgZm9yIChqJCA9IDAsIGxlbjEkID0gKHJlZjEkID0gaGZhY2luZ3MpLmxlbmd0aDsgaiQgPCBsZW4xJDsgKytqJCkge1xuICAgICAgICAgIGggPSByZWYxJFtqJF07XG4gICAgICAgICAgZm9yIChrJCA9IDAsIGxlbjIkID0gKHJlZjIkID0gdmZhY2luZ3MpLmxlbmd0aDsgayQgPCBsZW4yJDsgKytrJCkge1xuICAgICAgICAgICAgdiA9IHJlZjIkW2skXTtcbiAgICAgICAgICAgIGZvciAobCQgPSAwLCBsZW4zJCA9IChyZWYzJCA9IHN0cmlkZXMpLmxlbmd0aDsgbCQgPCBsZW4zJDsgKytsJCkge1xuICAgICAgICAgICAgICBzID0gcmVmMyRbbCRdO1xuICAgICAgICAgICAgICBzcyA9IFNwcml0ZVN0YXRlLm1ha2UoaCwgdiwgbSwgcyk7XG4gICAgICAgICAgICAgIHJlc3VsdHMkLnB1c2goW3NzLmtleSwgZm4oc3MpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cyQ7XG4gICAgfSgpKSk7XG4gIH1cbn07IiwidmFyIHN0ZCwgU3ByaXRlU291cmNlLCBJbW1vYmlsZVNpbmdsZUxvb3BQYXJ0aWNsZSwga1N0YXJTcmMsIFN0YXJQYXJ0aWNsZSwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcbnN0ZCA9IHJlcXVpcmUoJ3N0ZCcpO1xuU3ByaXRlU291cmNlID0gcmVxdWlyZSgnLi9yZWN0YW5nbGUnKS5TcHJpdGVTb3VyY2U7XG5JbW1vYmlsZVNpbmdsZUxvb3BQYXJ0aWNsZSA9IHJlcXVpcmUoJy4vaW1tb2JpbGUtc2luZ2xlLWxvb3AtcGFydGljbGUnKS5JbW1vYmlsZVNpbmdsZUxvb3BQYXJ0aWNsZTtcbmtTdGFyU3JjID0gbmV3IFNwcml0ZVNvdXJjZSgwLCAzKTtcbm91dCQuU3RhclBhcnRpY2xlID0gU3RhclBhcnRpY2xlID0gKGZ1bmN0aW9uKHN1cGVyY2xhc3Mpe1xuICB2YXIgcHJvdG90eXBlID0gZXh0ZW5kJCgoaW1wb3J0JChTdGFyUGFydGljbGUsIHN1cGVyY2xhc3MpLmRpc3BsYXlOYW1lID0gJ1N0YXJQYXJ0aWNsZScsIFN0YXJQYXJ0aWNsZSksIHN1cGVyY2xhc3MpLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBTdGFyUGFydGljbGU7XG4gIGZ1bmN0aW9uIFN0YXJQYXJ0aWNsZShncmFwaGljcywgeCwgeSl7XG4gICAgU3RhclBhcnRpY2xlLnN1cGVyY2xhc3MuY2FsbCh0aGlzLCBncmFwaGljcywgeCwgeSwgJ0NhcmV0Jywga1N0YXJTcmMsIDE4LCA0KTtcbiAgfVxuICByZXR1cm4gU3RhclBhcnRpY2xlO1xufShJbW1vYmlsZVNpbmdsZUxvb3BQYXJ0aWNsZSkpO1xuZnVuY3Rpb24gZXh0ZW5kJChzdWIsIHN1cCl7XG4gIGZ1bmN0aW9uIGZ1bigpe30gZnVuLnByb3RvdHlwZSA9IChzdWIuc3VwZXJjbGFzcyA9IHN1cCkucHJvdG90eXBlO1xuICAoc3ViLnByb3RvdHlwZSA9IG5ldyBmdW4pLmNvbnN0cnVjdG9yID0gc3ViO1xuICBpZiAodHlwZW9mIHN1cC5leHRlbmRlZCA9PSAnZnVuY3Rpb24nKSBzdXAuZXh0ZW5kZWQoc3ViKTtcbiAgcmV0dXJuIHN1Yjtcbn1cbmZ1bmN0aW9uIGltcG9ydCQob2JqLCBzcmMpe1xuICB2YXIgb3duID0ge30uaGFzT3duUHJvcGVydHk7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIGlmIChvd24uY2FsbChzcmMsIGtleSkpIG9ialtrZXldID0gc3JjW2tleV07XG4gIHJldHVybiBvYmo7XG59IiwidmFyIHJlZiQsIGlkLCBtYXAsIGZpbHRlciwgcmVqZWN0LCBhbnksIGRpdiwgbG9nLCBpbmZvLCBvYmpNYXAsIG1hc2gsIGZsaXAsIGRlbGF5LCByb3VuZCwgZmxvb3IsIGFicywgbWF4LCBtaW4sIHNpbiwgY29zLCBwaSwgdGF1LCByYW5kLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xucmVmJCA9IHJlcXVpcmUoJ3ByZWx1ZGUtbHMnKSwgaWQgPSByZWYkLmlkLCBtYXAgPSByZWYkLm1hcCwgZmlsdGVyID0gcmVmJC5maWx0ZXIsIHJlamVjdCA9IHJlZiQucmVqZWN0LCBhbnkgPSByZWYkLmFueSwgZGl2ID0gcmVmJC5kaXY7XG5vdXQkLmxvZyA9IGxvZyA9IGZ1bmN0aW9uKCl7XG4gIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gIHJldHVybiBhcmd1bWVudHNbMF07XG59O1xub3V0JC5pbmZvID0gaW5mbyA9IGZ1bmN0aW9uKCl7XG4gIGNvbnNvbGUuaW5mby5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICByZXR1cm4gYXJndW1lbnRzWzBdO1xufTtcbm91dCQub2JqTWFwID0gb2JqTWFwID0gY3VycnkkKGZ1bmN0aW9uKM67LCBvKXtcbiAgdmFyIGssIHYsIHJlc3VsdHMkID0gW107XG4gIGZvciAoayBpbiBvKSB7XG4gICAgdiA9IG9ba107XG4gICAgcmVzdWx0cyQucHVzaCjOuyhrLCB2KSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHMkO1xufSk7XG5vdXQkLm1hc2ggPSBtYXNoID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgaSQsIGxlbiQsIHJlZiQsIGssIHYsIHJlc3VsdHMkID0ge307XG4gIGZvciAoaSQgPSAwLCBsZW4kID0gaXQubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICByZWYkID0gaXRbaSRdLCBrID0gcmVmJFswXSwgdiA9IHJlZiRbMV07XG4gICAgcmVzdWx0cyRba10gPSB2O1xuICB9XG4gIHJldHVybiByZXN1bHRzJDtcbn07XG5vdXQkLmZsaXAgPSBmbGlwID0gZnVuY3Rpb24ozrspe1xuICByZXR1cm4gY3VycnkkKGZ1bmN0aW9uKGEsIGIpe1xuICAgIHJldHVybiDOuyhiLCBhKTtcbiAgfSk7XG59O1xub3V0JC5kZWxheSA9IGRlbGF5ID0gZmxpcChzZXRUaW1lb3V0KTtcbm91dCQucm91bmQgPSByb3VuZCA9IE1hdGgucm91bmQ7XG5vdXQkLmZsb29yID0gZmxvb3IgPSBNYXRoLmZsb29yO1xub3V0JC5hYnMgPSBhYnMgPSBNYXRoLmFicztcbm91dCQubWF4ID0gbWF4ID0gTWF0aC5tYXg7XG5vdXQkLm1pbiA9IG1pbiA9IE1hdGgubWluO1xub3V0JC5zaW4gPSBzaW4gPSBNYXRoLnNpbjtcbm91dCQuY29zID0gY29zID0gTWF0aC5jb3M7XG5vdXQkLnBpID0gcGkgPSBNYXRoLlBJO1xub3V0JC50YXUgPSB0YXUgPSBNYXRoLlBJICogMjtcbm91dCQucmFuZCA9IHJhbmQgPSBmdW5jdGlvbihtaW4sIG1heCl7XG4gIHJldHVybiBtaW4gKyBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbik7XG59O1xucmVmJCA9IG91dCQ7XG5yZWYkLmlkID0gaWQ7XG5yZWYkLmFueSA9IGFueTtcbnJlZiQubWFwID0gbWFwO1xucmVmJC5maWx0ZXIgPSBmaWx0ZXI7XG5yZWYkLnJlamVjdCA9IHJlamVjdDtcbnJlZiQuZGl2ID0gZGl2O1xucmVmJFsnZW51bSddID0gWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsIDE2LCAxNywgMTgsIDE5LCAyMF07XG5yZWYkLmJpdG1hc2sgPSBbMSwgMiwgNCwgOCwgMTYsIDMyLCA2NCwgMTI4LCAyNTYsIDUxMiwgMTAyNCwgMjA0OCwgNDA5Nl07XG5mdW5jdGlvbiBjdXJyeSQoZiwgYm91bmQpe1xuICB2YXIgY29udGV4dCxcbiAgX2N1cnJ5ID0gZnVuY3Rpb24oYXJncykge1xuICAgIHJldHVybiBmLmxlbmd0aCA+IDEgPyBmdW5jdGlvbigpe1xuICAgICAgdmFyIHBhcmFtcyA9IGFyZ3MgPyBhcmdzLmNvbmNhdCgpIDogW107XG4gICAgICBjb250ZXh0ID0gYm91bmQgPyBjb250ZXh0IHx8IHRoaXMgOiB0aGlzO1xuICAgICAgcmV0dXJuIHBhcmFtcy5wdXNoLmFwcGx5KHBhcmFtcywgYXJndW1lbnRzKSA8XG4gICAgICAgICAgZi5sZW5ndGggJiYgYXJndW1lbnRzLmxlbmd0aCA/XG4gICAgICAgIF9jdXJyeS5jYWxsKGNvbnRleHQsIHBhcmFtcykgOiBmLmFwcGx5KGNvbnRleHQsIHBhcmFtcyk7XG4gICAgfSA6IGY7XG4gIH07XG4gIHJldHVybiBfY3VycnkoKTtcbn0iLCJ2YXIgc3RkLCB1bml0cywgVGltZXIsIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5zdGQgPSByZXF1aXJlKCdzdGQnKTtcbnVuaXRzID0gcmVxdWlyZSgnLi91bml0cycpO1xub3V0JC5UaW1lciA9IFRpbWVyID0gKGZ1bmN0aW9uKCl7XG4gIFRpbWVyLmRpc3BsYXlOYW1lID0gJ1RpbWVyJztcbiAgdmFyIGFsbFRpbWVycywgcHJvdG90eXBlID0gVGltZXIucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IFRpbWVyO1xuICBhbGxUaW1lcnMgPSBbXTtcbiAgZnVuY3Rpb24gVGltZXIoZXhwaXJhdGlvblRpbWUsIHN0YXJ0QWN0aXZlKXtcbiAgICB0aGlzLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgc3RhcnRBY3RpdmUgPT0gbnVsbCAmJiAoc3RhcnRBY3RpdmUgPSBmYWxzZSk7XG4gICAgdGhpcy5jdXJyZW50VGltZSA9IHN0YXJ0QWN0aXZlXG4gICAgICA/IDBcbiAgICAgIDogdGhpcy5leHBpcmF0aW9uVGltZTtcbiAgICBhbGxUaW1lcnMucHVzaCh0aGlzKTtcbiAgfVxuICBwcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oZWxhcHNlZFRpbWUpe1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRUaW1lICs9IGVsYXBzZWRUaW1lO1xuICB9O1xuICBwcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRUaW1lID0gMDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgJ2lzQWN0aXZlJywge1xuICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRUaW1lIDwgdGhpcy5leHBpcmF0aW9uVGltZTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCAnaXNFeHBpcmVkJywge1xuICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiAhdGhpcy5pc0FjdGl2ZTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xuICBwcm90b3R5cGUuYWN0aXZlID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50VGltZSA8IHRoaXMuZXhwaXJhdGlvblRpbWU7XG4gIH07XG4gIHByb3RvdHlwZS5leHBpcmVkID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gISh0aGlzLmN1cnJlbnRUaW1lIDwgdGhpcy5leHBpcmF0aW9uVGltZSk7XG4gIH07XG4gIFRpbWVyLnVwZGF0ZUFsbCA9IGZ1bmN0aW9uKGVsYXBzZWRUaW1lKXtcbiAgICByZXR1cm4gYWxsVGltZXJzLm1hcChmdW5jdGlvbihpdCl7XG4gICAgICByZXR1cm4gaXQudXBkYXRlKGVsYXBzZWRUaW1lKTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIFRpbWVyO1xufSgpKTsiLCJ2YXIgc3RkLCBjb25maWcsIGtQaSwga0dhbWVVbml0c1BlclRpbGUsIGtQaXhlbFNjYWxlRmFjdG9yLCBHYW1lLCBQaXhlbCwgVGlsZSwgRGVncmVlcywgR3VuTGV2ZWwsIEZQUywgTVMsIFZlbG9jaXR5LCBBY2NlbGVyYXRpb24sIEhQLCBnYW1lVG9QeCwgZ2FtZVRvVGlsZSwgdGlsZVRvR2FtZSwgdGlsZVRvUHgsIHB4VG9HYW1lLCBweFRvVGlsZSwgZGVnVG9SYWQsIGtPbmVUaWxlLCBrSGFsZlRpbGUsIGtUaWxlUHgsIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5zdGQgPSByZXF1aXJlKCdzdGQnKTtcbmNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5rUGkgPSBNYXRoLlBJO1xua0dhbWVVbml0c1BlclRpbGUgPSAzMjtcbmtQaXhlbFNjYWxlRmFjdG9yID0ga0dhbWVVbml0c1BlclRpbGUgLyBjb25maWcua0dyYXBoaWNzUXVhbGl0eTtcbm91dCQuR2FtZSA9IEdhbWUgPSBzdGQuaWQ7XG5vdXQkLlBpeGVsID0gUGl4ZWwgPSBzdGQuZmxvb3I7XG5vdXQkLlRpbGUgPSBUaWxlID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHN0ZC5hYnMoc3RkLmZsb29yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xufTtcbm91dCQuRGVncmVlcyA9IERlZ3JlZXMgPSBzdGQuaWQ7XG5vdXQkLkd1bkxldmVsID0gR3VuTGV2ZWwgPSBzdGQuZmxvb3I7XG5vdXQkLkZQUyA9IEZQUyA9IHN0ZC5pZDtcbm91dCQuTVMgPSBNUyA9IHN0ZC5pZDtcbm91dCQuVmVsb2NpdHkgPSBWZWxvY2l0eSA9IHN0ZC5pZDtcbm91dCQuQWNjZWxlcmF0aW9uID0gQWNjZWxlcmF0aW9uID0gc3RkLmlkO1xub3V0JC5IUCA9IEhQID0gc3RkLmZsb29yO1xub3V0JC5nYW1lVG9QeCA9IGdhbWVUb1B4ID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIFBpeGVsKChmdW5jdGlvbihpdCl7XG4gICAgcmV0dXJuIGl0IC8ga1BpeGVsU2NhbGVGYWN0b3I7XG4gIH0pLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xufTtcbm91dCQuZ2FtZVRvVGlsZSA9IGdhbWVUb1RpbGUgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gVGlsZSgoZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiBpdCAvIGtHYW1lVW5pdHNQZXJUaWxlO1xuICB9KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbn07XG5vdXQkLnRpbGVUb0dhbWUgPSB0aWxlVG9HYW1lID0gKGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ICoga0dhbWVVbml0c1BlclRpbGU7XG59KTtcbm91dCQudGlsZVRvUHggPSB0aWxlVG9QeCA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiBnYW1lVG9QeCh0aWxlVG9HYW1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xufTtcbm91dCQucHhUb0dhbWUgPSBweFRvR2FtZSA9IChmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCAqIGtQaXhlbFNjYWxlRmFjdG9yO1xufSk7XG5vdXQkLnB4VG9UaWxlID0gcHhUb1RpbGUgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gKGZ1bmN0aW9uKGl0KXtcbiAgICByZXR1cm4gaXQgLyBrR2FtZVVuaXRzUGVyVGlsZTtcbiAgfSkocHhUb0dhbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG59O1xub3V0JC5kZWdUb1JhZCA9IGRlZ1RvUmFkID0gKGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ICoga1BpIC8gMTgwO1xufSk7XG5vdXQkLmtPbmVUaWxlID0ga09uZVRpbGUgPSB0aWxlVG9HYW1lKDEpO1xub3V0JC5rSGFsZlRpbGUgPSBrSGFsZlRpbGUgPSB0aWxlVG9HYW1lKDAuNSk7XG5vdXQkLmtUaWxlUHggPSBrVGlsZVB4ID0gdGlsZVRvUHgoMSk7IiwidmFyIHN0ZCwgdW5pdHMsIFNwcml0ZVNvdXJjZSwgSW1tb2JpbGVTaW5nbGVMb29wUGFydGljbGUsIGtXYWxsU3JjLCBXYWxsUGFydGljbGUsIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5zdGQgPSByZXF1aXJlKCdzdGQnKTtcbnVuaXRzID0gcmVxdWlyZSgnLi91bml0cycpO1xuU3ByaXRlU291cmNlID0gcmVxdWlyZSgnLi9yZWN0YW5nbGUnKS5TcHJpdGVTb3VyY2U7XG5JbW1vYmlsZVNpbmdsZUxvb3BQYXJ0aWNsZSA9IHJlcXVpcmUoJy4vaW1tb2JpbGUtc2luZ2xlLWxvb3AtcGFydGljbGUnKS5JbW1vYmlsZVNpbmdsZUxvb3BQYXJ0aWNsZTtcbmtXYWxsU3JjID0gbmV3IFNwcml0ZVNvdXJjZSgxMSwgMCk7XG5vdXQkLldhbGxQYXJ0aWNsZSA9IFdhbGxQYXJ0aWNsZSA9IChmdW5jdGlvbihzdXBlcmNsYXNzKXtcbiAgdmFyIHByb3RvdHlwZSA9IGV4dGVuZCQoKGltcG9ydCQoV2FsbFBhcnRpY2xlLCBzdXBlcmNsYXNzKS5kaXNwbGF5TmFtZSA9ICdXYWxsUGFydGljbGUnLCBXYWxsUGFydGljbGUpLCBzdXBlcmNsYXNzKS5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gV2FsbFBhcnRpY2xlO1xuICBmdW5jdGlvbiBXYWxsUGFydGljbGUoZ3JhcGhpY3MsIHgsIHkpe1xuICAgIFdhbGxQYXJ0aWNsZS5zdXBlcmNsYXNzLmNhbGwodGhpcywgZ3JhcGhpY3MsIHgsIHksICdDYXJldCcsIGtXYWxsU3JjLCAxOCwgNCk7XG4gIH1cbiAgcmV0dXJuIFdhbGxQYXJ0aWNsZTtcbn0oSW1tb2JpbGVTaW5nbGVMb29wUGFydGljbGUpKTtcbmZ1bmN0aW9uIGV4dGVuZCQoc3ViLCBzdXApe1xuICBmdW5jdGlvbiBmdW4oKXt9IGZ1bi5wcm90b3R5cGUgPSAoc3ViLnN1cGVyY2xhc3MgPSBzdXApLnByb3RvdHlwZTtcbiAgKHN1Yi5wcm90b3R5cGUgPSBuZXcgZnVuKS5jb25zdHJ1Y3RvciA9IHN1YjtcbiAgaWYgKHR5cGVvZiBzdXAuZXh0ZW5kZWQgPT0gJ2Z1bmN0aW9uJykgc3VwLmV4dGVuZGVkKHN1Yik7XG4gIHJldHVybiBzdWI7XG59XG5mdW5jdGlvbiBpbXBvcnQkKG9iaiwgc3JjKXtcbiAgdmFyIG93biA9IHt9Lmhhc093blByb3BlcnR5O1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSBpZiAob3duLmNhbGwoc3JjLCBrZXkpKSBvYmpba2V5XSA9IHNyY1trZXldO1xuICByZXR1cm4gb2JqO1xufSJdfQ==
