(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var readout, Game;
readout = require('./readout');
Game = require('./game');
readout.install();
Game.start();
},{"./game":13,"./readout":19}],2:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var apply, curry, flip, fix, over;
apply = curry$(function(f, list){
  return f.apply(null, list);
});
curry = function(f){
  return curry$(f);
};
flip = curry$(function(f, x, y){
  return f(y, x);
});
fix = function(f){
  return function(g){
    return function(){
      return f(g(g)).apply(null, arguments);
    };
  }(function(g){
    return function(){
      return f(g(g)).apply(null, arguments);
    };
  });
};
over = curry$(function(f, g, x, y){
  return f(g(x), g(y));
});
module.exports = {
  curry: curry,
  flip: flip,
  fix: fix,
  apply: apply,
  over: over
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{}],3:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var each, map, compact, filter, reject, partition, find, head, first, tail, last, initial, empty, reverse, unique, uniqueBy, fold, foldl, fold1, foldl1, foldr, foldr1, unfoldr, concat, concatMap, flatten, difference, intersection, union, countBy, groupBy, andList, orList, any, all, sort, sortWith, sortBy, sum, product, mean, average, maximum, minimum, maximumBy, minimumBy, scan, scanl, scan1, scanl1, scanr, scanr1, slice, take, drop, splitAt, takeWhile, dropWhile, span, breakList, zip, zipWith, zipAll, zipAllWith, at, elemIndex, elemIndices, findIndex, findIndices, toString$ = {}.toString, slice$ = [].slice;
each = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    f(x);
  }
  return xs;
});
map = curry$(function(f, xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    results$.push(f(x));
  }
  return results$;
});
compact = function(xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (x) {
      results$.push(x);
    }
  }
  return results$;
};
filter = curry$(function(f, xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      results$.push(x);
    }
  }
  return results$;
});
reject = curry$(function(f, xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!f(x)) {
      results$.push(x);
    }
  }
  return results$;
});
partition = curry$(function(f, xs){
  var passed, failed, i$, len$, x;
  passed = [];
  failed = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    (f(x) ? passed : failed).push(x);
  }
  return [passed, failed];
});
find = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      return x;
    }
  }
});
head = first = function(xs){
  return xs[0];
};
tail = function(xs){
  if (!xs.length) {
    return;
  }
  return xs.slice(1);
};
last = function(xs){
  return xs[xs.length - 1];
};
initial = function(xs){
  if (!xs.length) {
    return;
  }
  return xs.slice(0, -1);
};
empty = function(xs){
  return !xs.length;
};
reverse = function(xs){
  return xs.concat().reverse();
};
unique = function(xs){
  var result, i$, len$, x;
  result = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!in$(x, result)) {
      result.push(x);
    }
  }
  return result;
};
uniqueBy = curry$(function(f, xs){
  var seen, i$, len$, x, val, results$ = [];
  seen = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    val = f(x);
    if (in$(val, seen)) {
      continue;
    }
    seen.push(val);
    results$.push(x);
  }
  return results$;
});
fold = foldl = curry$(function(f, memo, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    memo = f(memo, x);
  }
  return memo;
});
fold1 = foldl1 = curry$(function(f, xs){
  return fold(f, xs[0], xs.slice(1));
});
foldr = curry$(function(f, memo, xs){
  var i$, x;
  for (i$ = xs.length - 1; i$ >= 0; --i$) {
    x = xs[i$];
    memo = f(x, memo);
  }
  return memo;
});
foldr1 = curry$(function(f, xs){
  return foldr(f, xs[xs.length - 1], xs.slice(0, -1));
});
unfoldr = curry$(function(f, b){
  var result, x, that;
  result = [];
  x = b;
  while ((that = f(x)) != null) {
    result.push(that[0]);
    x = that[1];
  }
  return result;
});
concat = function(xss){
  return [].concat.apply([], xss);
};
concatMap = curry$(function(f, xs){
  var x;
  return [].concat.apply([], (function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      results$.push(f(x));
    }
    return results$;
  }()));
});
flatten = function(xs){
  var x;
  return [].concat.apply([], (function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      if (toString$.call(x).slice(8, -1) === 'Array') {
        results$.push(flatten(x));
      } else {
        results$.push(x);
      }
    }
    return results$;
  }()));
};
difference = function(xs){
  var yss, results, i$, len$, x, j$, len1$, ys;
  yss = slice$.call(arguments, 1);
  results = [];
  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
      ys = yss[j$];
      if (in$(x, ys)) {
        continue outer;
      }
    }
    results.push(x);
  }
  return results;
};
intersection = function(xs){
  var yss, results, i$, len$, x, j$, len1$, ys;
  yss = slice$.call(arguments, 1);
  results = [];
  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
      ys = yss[j$];
      if (!in$(x, ys)) {
        continue outer;
      }
    }
    results.push(x);
  }
  return results;
};
union = function(){
  var xss, results, i$, len$, xs, j$, len1$, x;
  xss = slice$.call(arguments);
  results = [];
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    for (j$ = 0, len1$ = xs.length; j$ < len1$; ++j$) {
      x = xs[j$];
      if (!in$(x, results)) {
        results.push(x);
      }
    }
  }
  return results;
};
countBy = curry$(function(f, xs){
  var results, i$, len$, x, key;
  results = {};
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    key = f(x);
    if (key in results) {
      results[key] += 1;
    } else {
      results[key] = 1;
    }
  }
  return results;
});
groupBy = curry$(function(f, xs){
  var results, i$, len$, x, key;
  results = {};
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    key = f(x);
    if (key in results) {
      results[key].push(x);
    } else {
      results[key] = [x];
    }
  }
  return results;
});
andList = function(xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!x) {
      return false;
    }
  }
  return true;
};
orList = function(xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (x) {
      return true;
    }
  }
  return false;
};
any = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      return true;
    }
  }
  return false;
});
all = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!f(x)) {
      return false;
    }
  }
  return true;
});
sort = function(xs){
  return xs.concat().sort(function(x, y){
    if (x > y) {
      return 1;
    } else if (x < y) {
      return -1;
    } else {
      return 0;
    }
  });
};
sortWith = curry$(function(f, xs){
  return xs.concat().sort(f);
});
sortBy = curry$(function(f, xs){
  return xs.concat().sort(function(x, y){
    if (f(x) > f(y)) {
      return 1;
    } else if (f(x) < f(y)) {
      return -1;
    } else {
      return 0;
    }
  });
});
sum = function(xs){
  var result, i$, len$, x;
  result = 0;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    result += x;
  }
  return result;
};
product = function(xs){
  var result, i$, len$, x;
  result = 1;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    result *= x;
  }
  return result;
};
mean = average = function(xs){
  var sum, i$, len$, x;
  sum = 0;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    sum += x;
  }
  return sum / xs.length;
};
maximum = function(xs){
  var max, i$, ref$, len$, x;
  max = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (x > max) {
      max = x;
    }
  }
  return max;
};
minimum = function(xs){
  var min, i$, ref$, len$, x;
  min = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (x < min) {
      min = x;
    }
  }
  return min;
};
maximumBy = curry$(function(f, xs){
  var max, i$, ref$, len$, x;
  max = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (f(x) > f(max)) {
      max = x;
    }
  }
  return max;
});
minimumBy = curry$(function(f, xs){
  var min, i$, ref$, len$, x;
  min = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (f(x) < f(min)) {
      min = x;
    }
  }
  return min;
});
scan = scanl = curry$(function(f, memo, xs){
  var last, x;
  last = memo;
  return [memo].concat((function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      results$.push(last = f(last, x));
    }
    return results$;
  }()));
});
scan1 = scanl1 = curry$(function(f, xs){
  if (!xs.length) {
    return;
  }
  return scan(f, xs[0], xs.slice(1));
});
scanr = curry$(function(f, memo, xs){
  xs = xs.concat().reverse();
  return scan(f, memo, xs).reverse();
});
scanr1 = curry$(function(f, xs){
  if (!xs.length) {
    return;
  }
  xs = xs.concat().reverse();
  return scan(f, xs[0], xs.slice(1)).reverse();
});
slice = curry$(function(x, y, xs){
  return xs.slice(x, y);
});
take = curry$(function(n, xs){
  if (n <= 0) {
    return xs.slice(0, 0);
  } else {
    return xs.slice(0, n);
  }
});
drop = curry$(function(n, xs){
  if (n <= 0) {
    return xs;
  } else {
    return xs.slice(n);
  }
});
splitAt = curry$(function(n, xs){
  return [take(n, xs), drop(n, xs)];
});
takeWhile = curry$(function(p, xs){
  var len, i;
  len = xs.length;
  if (!len) {
    return xs;
  }
  i = 0;
  while (i < len && p(xs[i])) {
    i += 1;
  }
  return xs.slice(0, i);
});
dropWhile = curry$(function(p, xs){
  var len, i;
  len = xs.length;
  if (!len) {
    return xs;
  }
  i = 0;
  while (i < len && p(xs[i])) {
    i += 1;
  }
  return xs.slice(i);
});
span = curry$(function(p, xs){
  return [takeWhile(p, xs), dropWhile(p, xs)];
});
breakList = curry$(function(p, xs){
  return span(function(){
    return not$(p.apply(this, arguments));
  }, xs);
});
zip = curry$(function(xs, ys){
  var result, len, i$, len$, i, x;
  result = [];
  len = ys.length;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (i === len) {
      break;
    }
    result.push([x, ys[i]]);
  }
  return result;
});
zipWith = curry$(function(f, xs, ys){
  var result, len, i$, len$, i, x;
  result = [];
  len = ys.length;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (i === len) {
      break;
    }
    result.push(f(x, ys[i]));
  }
  return result;
});
zipAll = function(){
  var xss, minLength, i$, len$, xs, ref$, i, lresult$, j$, results$ = [];
  xss = slice$.call(arguments);
  minLength = 9e9;
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    minLength <= (ref$ = xs.length) || (minLength = ref$);
  }
  for (i$ = 0; i$ < minLength; ++i$) {
    i = i$;
    lresult$ = [];
    for (j$ = 0, len$ = xss.length; j$ < len$; ++j$) {
      xs = xss[j$];
      lresult$.push(xs[i]);
    }
    results$.push(lresult$);
  }
  return results$;
};
zipAllWith = function(f){
  var xss, minLength, i$, len$, xs, ref$, i, results$ = [];
  xss = slice$.call(arguments, 1);
  minLength = 9e9;
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    minLength <= (ref$ = xs.length) || (minLength = ref$);
  }
  for (i$ = 0; i$ < minLength; ++i$) {
    i = i$;
    results$.push(f.apply(null, (fn$())));
  }
  return results$;
  function fn$(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xss).length; i$ < len$; ++i$) {
      xs = ref$[i$];
      results$.push(xs[i]);
    }
    return results$;
  }
};
at = curry$(function(n, xs){
  if (n < 0) {
    return xs[xs.length + n];
  } else {
    return xs[n];
  }
});
elemIndex = curry$(function(el, xs){
  var i$, len$, i, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (x === el) {
      return i;
    }
  }
});
elemIndices = curry$(function(el, xs){
  var i$, len$, i, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (x === el) {
      results$.push(i);
    }
  }
  return results$;
});
findIndex = curry$(function(f, xs){
  var i$, len$, i, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (f(x)) {
      return i;
    }
  }
});
findIndices = curry$(function(f, xs){
  var i$, len$, i, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (f(x)) {
      results$.push(i);
    }
  }
  return results$;
});
module.exports = {
  each: each,
  map: map,
  filter: filter,
  compact: compact,
  reject: reject,
  partition: partition,
  find: find,
  head: head,
  first: first,
  tail: tail,
  last: last,
  initial: initial,
  empty: empty,
  reverse: reverse,
  difference: difference,
  intersection: intersection,
  union: union,
  countBy: countBy,
  groupBy: groupBy,
  fold: fold,
  fold1: fold1,
  foldl: foldl,
  foldl1: foldl1,
  foldr: foldr,
  foldr1: foldr1,
  unfoldr: unfoldr,
  andList: andList,
  orList: orList,
  any: any,
  all: all,
  unique: unique,
  uniqueBy: uniqueBy,
  sort: sort,
  sortWith: sortWith,
  sortBy: sortBy,
  sum: sum,
  product: product,
  mean: mean,
  average: average,
  concat: concat,
  concatMap: concatMap,
  flatten: flatten,
  maximum: maximum,
  minimum: minimum,
  maximumBy: maximumBy,
  minimumBy: minimumBy,
  scan: scan,
  scan1: scan1,
  scanl: scanl,
  scanl1: scanl1,
  scanr: scanr,
  scanr1: scanr1,
  slice: slice,
  take: take,
  drop: drop,
  splitAt: splitAt,
  takeWhile: takeWhile,
  dropWhile: dropWhile,
  span: span,
  breakList: breakList,
  zip: zip,
  zipWith: zipWith,
  zipAll: zipAll,
  zipAllWith: zipAllWith,
  at: at,
  elemIndex: elemIndex,
  elemIndices: elemIndices,
  findIndex: findIndex,
  findIndices: findIndices
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
function in$(x, xs){
  var i = -1, l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}
function not$(x){ return !x; }
},{}],4:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var max, min, negate, abs, signum, quot, rem, div, mod, recip, pi, tau, exp, sqrt, ln, pow, sin, tan, cos, asin, acos, atan, atan2, truncate, round, ceiling, floor, isItNaN, even, odd, gcd, lcm;
max = curry$(function(x$, y$){
  return x$ > y$ ? x$ : y$;
});
min = curry$(function(x$, y$){
  return x$ < y$ ? x$ : y$;
});
negate = function(x){
  return -x;
};
abs = Math.abs;
signum = function(x){
  if (x < 0) {
    return -1;
  } else if (x > 0) {
    return 1;
  } else {
    return 0;
  }
};
quot = curry$(function(x, y){
  return ~~(x / y);
});
rem = curry$(function(x$, y$){
  return x$ % y$;
});
div = curry$(function(x, y){
  return Math.floor(x / y);
});
mod = curry$(function(x$, y$){
  var ref$;
  return ((x$) % (ref$ = y$) + ref$) % ref$;
});
recip = (function(it){
  return 1 / it;
});
pi = Math.PI;
tau = pi * 2;
exp = Math.exp;
sqrt = Math.sqrt;
ln = Math.log;
pow = curry$(function(x$, y$){
  return Math.pow(x$, y$);
});
sin = Math.sin;
tan = Math.tan;
cos = Math.cos;
asin = Math.asin;
acos = Math.acos;
atan = Math.atan;
atan2 = curry$(function(x, y){
  return Math.atan2(x, y);
});
truncate = function(x){
  return ~~x;
};
round = Math.round;
ceiling = Math.ceil;
floor = Math.floor;
isItNaN = function(x){
  return x !== x;
};
even = function(x){
  return x % 2 === 0;
};
odd = function(x){
  return x % 2 !== 0;
};
gcd = curry$(function(x, y){
  var z;
  x = Math.abs(x);
  y = Math.abs(y);
  while (y !== 0) {
    z = x % y;
    x = y;
    y = z;
  }
  return x;
});
lcm = curry$(function(x, y){
  return Math.abs(Math.floor(x / gcd(x, y) * y));
});
module.exports = {
  max: max,
  min: min,
  negate: negate,
  abs: abs,
  signum: signum,
  quot: quot,
  rem: rem,
  div: div,
  mod: mod,
  recip: recip,
  pi: pi,
  tau: tau,
  exp: exp,
  sqrt: sqrt,
  ln: ln,
  pow: pow,
  sin: sin,
  tan: tan,
  cos: cos,
  acos: acos,
  asin: asin,
  atan: atan,
  atan2: atan2,
  truncate: truncate,
  round: round,
  ceiling: ceiling,
  floor: floor,
  isItNaN: isItNaN,
  even: even,
  odd: odd,
  gcd: gcd,
  lcm: lcm
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{}],5:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var values, keys, pairsToObj, objToPairs, listsToObj, objToLists, empty, each, map, compact, filter, reject, partition, find;
values = function(object){
  var i$, x, results$ = [];
  for (i$ in object) {
    x = object[i$];
    results$.push(x);
  }
  return results$;
};
keys = function(object){
  var x, results$ = [];
  for (x in object) {
    results$.push(x);
  }
  return results$;
};
pairsToObj = function(object){
  var i$, len$, x, results$ = {};
  for (i$ = 0, len$ = object.length; i$ < len$; ++i$) {
    x = object[i$];
    results$[x[0]] = x[1];
  }
  return results$;
};
objToPairs = function(object){
  var key, value, results$ = [];
  for (key in object) {
    value = object[key];
    results$.push([key, value]);
  }
  return results$;
};
listsToObj = curry$(function(keys, values){
  var i$, len$, i, key, results$ = {};
  for (i$ = 0, len$ = keys.length; i$ < len$; ++i$) {
    i = i$;
    key = keys[i$];
    results$[key] = values[i];
  }
  return results$;
});
objToLists = function(object){
  var keys, values, key, value;
  keys = [];
  values = [];
  for (key in object) {
    value = object[key];
    keys.push(key);
    values.push(value);
  }
  return [keys, values];
};
empty = function(object){
  var x;
  for (x in object) {
    return false;
  }
  return true;
};
each = curry$(function(f, object){
  var i$, x;
  for (i$ in object) {
    x = object[i$];
    f(x);
  }
  return object;
});
map = curry$(function(f, object){
  var k, x, results$ = {};
  for (k in object) {
    x = object[k];
    results$[k] = f(x);
  }
  return results$;
});
compact = function(object){
  var k, x, results$ = {};
  for (k in object) {
    x = object[k];
if (x) {
      results$[k] = x;
    }
  }
  return results$;
};
filter = curry$(function(f, object){
  var k, x, results$ = {};
  for (k in object) {
    x = object[k];
if (f(x)) {
      results$[k] = x;
    }
  }
  return results$;
});
reject = curry$(function(f, object){
  var k, x, results$ = {};
  for (k in object) {
    x = object[k];
if (!f(x)) {
      results$[k] = x;
    }
  }
  return results$;
});
partition = curry$(function(f, object){
  var passed, failed, k, x;
  passed = {};
  failed = {};
  for (k in object) {
    x = object[k];
    (f(x) ? passed : failed)[k] = x;
  }
  return [passed, failed];
});
find = curry$(function(f, object){
  var i$, x;
  for (i$ in object) {
    x = object[i$];
    if (f(x)) {
      return x;
    }
  }
});
module.exports = {
  values: values,
  keys: keys,
  pairsToObj: pairsToObj,
  objToPairs: objToPairs,
  listsToObj: listsToObj,
  objToLists: objToLists,
  empty: empty,
  each: each,
  map: map,
  filter: filter,
  compact: compact,
  reject: reject,
  partition: partition,
  find: find
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{}],6:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var split, join, lines, unlines, words, unwords, chars, unchars, reverse, repeat, capitalize, camelize, dasherize;
split = curry$(function(sep, str){
  return str.split(sep);
});
join = curry$(function(sep, xs){
  return xs.join(sep);
});
lines = function(str){
  if (!str.length) {
    return [];
  }
  return str.split('\n');
};
unlines = function(it){
  return it.join('\n');
};
words = function(str){
  if (!str.length) {
    return [];
  }
  return str.split(/[ ]+/);
};
unwords = function(it){
  return it.join(' ');
};
chars = function(it){
  return it.split('');
};
unchars = function(it){
  return it.join('');
};
reverse = function(str){
  return str.split('').reverse().join('');
};
repeat = curry$(function(n, str){
  var result, i$;
  result = '';
  for (i$ = 0; i$ < n; ++i$) {
    result += str;
  }
  return result;
});
capitalize = function(str){
  return str.charAt(0).toUpperCase() + str.slice(1);
};
camelize = function(it){
  return it.replace(/[-_]+(.)?/g, function(arg$, c){
    return (c != null ? c : '').toUpperCase();
  });
};
dasherize = function(str){
  return str.replace(/([^-A-Z])([A-Z]+)/g, function(arg$, lower, upper){
    return lower + "-" + (upper.length > 1
      ? upper
      : upper.toLowerCase());
  }).replace(/^([A-Z]+)/, function(arg$, upper){
    if (upper.length > 1) {
      return upper + "-";
    } else {
      return upper.toLowerCase();
    }
  });
};
module.exports = {
  split: split,
  join: join,
  lines: lines,
  unlines: unlines,
  words: words,
  unwords: unwords,
  chars: chars,
  unchars: unchars,
  reverse: reverse,
  repeat: repeat,
  capitalize: capitalize,
  camelize: camelize,
  dasherize: dasherize
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{}],7:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var Func, List, Obj, Str, Num, id, isType, replicate, prelude, toString$ = {}.toString;
Func = require('./Func.js');
List = require('./List.js');
Obj = require('./Obj.js');
Str = require('./Str.js');
Num = require('./Num.js');
id = function(x){
  return x;
};
isType = curry$(function(type, x){
  return toString$.call(x).slice(8, -1) === type;
});
replicate = curry$(function(n, x){
  var i$, results$ = [];
  for (i$ = 0; i$ < n; ++i$) {
    results$.push(x);
  }
  return results$;
});
Str.empty = List.empty;
Str.slice = List.slice;
Str.take = List.take;
Str.drop = List.drop;
Str.splitAt = List.splitAt;
Str.takeWhile = List.takeWhile;
Str.dropWhile = List.dropWhile;
Str.span = List.span;
Str.breakStr = List.breakList;
prelude = {
  Func: Func,
  List: List,
  Obj: Obj,
  Str: Str,
  Num: Num,
  id: id,
  isType: isType,
  replicate: replicate
};
prelude.each = List.each;
prelude.map = List.map;
prelude.filter = List.filter;
prelude.compact = List.compact;
prelude.reject = List.reject;
prelude.partition = List.partition;
prelude.find = List.find;
prelude.head = List.head;
prelude.first = List.first;
prelude.tail = List.tail;
prelude.last = List.last;
prelude.initial = List.initial;
prelude.empty = List.empty;
prelude.reverse = List.reverse;
prelude.difference = List.difference;
prelude.intersection = List.intersection;
prelude.union = List.union;
prelude.countBy = List.countBy;
prelude.groupBy = List.groupBy;
prelude.fold = List.fold;
prelude.foldl = List.foldl;
prelude.fold1 = List.fold1;
prelude.foldl1 = List.foldl1;
prelude.foldr = List.foldr;
prelude.foldr1 = List.foldr1;
prelude.unfoldr = List.unfoldr;
prelude.andList = List.andList;
prelude.orList = List.orList;
prelude.any = List.any;
prelude.all = List.all;
prelude.unique = List.unique;
prelude.uniqueBy = List.uniqueBy;
prelude.sort = List.sort;
prelude.sortWith = List.sortWith;
prelude.sortBy = List.sortBy;
prelude.sum = List.sum;
prelude.product = List.product;
prelude.mean = List.mean;
prelude.average = List.average;
prelude.concat = List.concat;
prelude.concatMap = List.concatMap;
prelude.flatten = List.flatten;
prelude.maximum = List.maximum;
prelude.minimum = List.minimum;
prelude.maximumBy = List.maximumBy;
prelude.minimumBy = List.minimumBy;
prelude.scan = List.scan;
prelude.scanl = List.scanl;
prelude.scan1 = List.scan1;
prelude.scanl1 = List.scanl1;
prelude.scanr = List.scanr;
prelude.scanr1 = List.scanr1;
prelude.slice = List.slice;
prelude.take = List.take;
prelude.drop = List.drop;
prelude.splitAt = List.splitAt;
prelude.takeWhile = List.takeWhile;
prelude.dropWhile = List.dropWhile;
prelude.span = List.span;
prelude.breakList = List.breakList;
prelude.zip = List.zip;
prelude.zipWith = List.zipWith;
prelude.zipAll = List.zipAll;
prelude.zipAllWith = List.zipAllWith;
prelude.at = List.at;
prelude.elemIndex = List.elemIndex;
prelude.elemIndices = List.elemIndices;
prelude.findIndex = List.findIndex;
prelude.findIndices = List.findIndices;
prelude.apply = Func.apply;
prelude.curry = Func.curry;
prelude.flip = Func.flip;
prelude.fix = Func.fix;
prelude.over = Func.over;
prelude.split = Str.split;
prelude.join = Str.join;
prelude.lines = Str.lines;
prelude.unlines = Str.unlines;
prelude.words = Str.words;
prelude.unwords = Str.unwords;
prelude.chars = Str.chars;
prelude.unchars = Str.unchars;
prelude.repeat = Str.repeat;
prelude.capitalize = Str.capitalize;
prelude.camelize = Str.camelize;
prelude.dasherize = Str.dasherize;
prelude.values = Obj.values;
prelude.keys = Obj.keys;
prelude.pairsToObj = Obj.pairsToObj;
prelude.objToPairs = Obj.objToPairs;
prelude.listsToObj = Obj.listsToObj;
prelude.objToLists = Obj.objToLists;
prelude.max = Num.max;
prelude.min = Num.min;
prelude.negate = Num.negate;
prelude.abs = Num.abs;
prelude.signum = Num.signum;
prelude.quot = Num.quot;
prelude.rem = Num.rem;
prelude.div = Num.div;
prelude.mod = Num.mod;
prelude.recip = Num.recip;
prelude.pi = Num.pi;
prelude.tau = Num.tau;
prelude.exp = Num.exp;
prelude.sqrt = Num.sqrt;
prelude.ln = Num.ln;
prelude.pow = Num.pow;
prelude.sin = Num.sin;
prelude.tan = Num.tan;
prelude.cos = Num.cos;
prelude.acos = Num.acos;
prelude.asin = Num.asin;
prelude.atan = Num.atan;
prelude.atan2 = Num.atan2;
prelude.truncate = Num.truncate;
prelude.round = Num.round;
prelude.ceiling = Num.ceiling;
prelude.floor = Num.floor;
prelude.isItNaN = Num.isItNaN;
prelude.even = Num.even;
prelude.odd = Num.odd;
prelude.gcd = Num.gcd;
prelude.lcm = Num.lcm;
prelude.VERSION = '1.1.1';
module.exports = prelude;
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{"./Func.js":2,"./List.js":3,"./Num.js":4,"./Obj.js":5,"./Str.js":6}],8:[function(require,module,exports){
var std, units, kHalfTile, tileToPx, tileToGame, gameToPx, Sprite, SpriteState, STANDING, WALKING, JUMPING, FALLING, INTERACTING, LEFT, RIGHT, UP, DOWN, HORIZONTAL, kArmsSpritePath, kSpriteWidth, kSpriteHeight, kUpOffset, kDownOffset, kHorizontalOffset, kRightOffset, kLeftOffset, kPolarStarIndex, PolarStar, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
kHalfTile = units.kHalfTile, tileToPx = units.tileToPx, tileToGame = units.tileToGame, gameToPx = units.gameToPx;
Sprite = require('./sprite').Sprite;
SpriteState = require('./spritestate'), STANDING = SpriteState.STANDING, WALKING = SpriteState.WALKING, JUMPING = SpriteState.JUMPING, FALLING = SpriteState.FALLING, INTERACTING = SpriteState.INTERACTING, LEFT = SpriteState.LEFT, RIGHT = SpriteState.RIGHT, UP = SpriteState.UP, DOWN = SpriteState.DOWN, HORIZONTAL = SpriteState.HORIZONTAL;
kArmsSpritePath = 'data/16x16/Arms.bmp';
kSpriteWidth = 1.5;
kSpriteHeight = 1.0;
kUpOffset = 2;
kDownOffset = 4;
kHorizontalOffset = 0;
kRightOffset = 1;
kLeftOffset = 0;
kPolarStarIndex = 2;
out$.PolarStar = PolarStar = (function(){
  PolarStar.displayName = 'PolarStar';
  var prototype = PolarStar.prototype, constructor = PolarStar;
  function PolarStar(graphics){
    std.log(this.sprites = this.initialiseSprites(graphics));
  }
  prototype.initialiseSprite = function(graphics, hfacing, vfacing){
    var tileY;
    tileY = hfacing === LEFT ? kLeftOffset : kRightOffset;
    switch (vfacing) {
    case HORIZONTAL:
      tileY += kHorizontalOffset;
      break;
    case UP:
      tileY += kUpOffset;
      break;
    case DOWN:
      tileY += kDownOffset;
      break;
    }
    return new Sprite(graphics, kArmsSpritePath, tileToPx(kPolarStarIndex * kSpriteWidth), tileToPx(tileY), tileToPx(kSpriteWidth), tileToPx(kSpriteHeight));
  };
  prototype.initialiseSprites = function(graphics, spriteMap){
    var i$, ref$, len$, hfacing, j$, ref1$, len1$, vfacing;
    spriteMap == null && (spriteMap = {});
    for (i$ = 0, len$ = (ref$ = [LEFT, RIGHT]).length; i$ < len$; ++i$) {
      hfacing = ref$[i$];
      for (j$ = 0, len1$ = (ref1$ = [UP, DOWN, HORIZONTAL]).length; j$ < len1$; ++j$) {
        vfacing = ref1$[j$];
        spriteMap[SpriteState.key(hfacing, vfacing)] = this.initialiseSprite(graphics, hfacing, vfacing);
      }
    }
    return spriteMap;
  };
  prototype.update = function(elapsedTime){};
  prototype.draw = function(graphics, x, y, hfacing, vfacing){
    var xOffset, yOffset;
    xOffset = hfacing === LEFT ? -kHalfTile : 0;
    yOffset = vfacing === UP ? -kHalfTile / 2 : 0;
    yOffset = vfacing === DOWN ? kHalfTile / 2 : 0;
    return this.sprites[SpriteState.key(hfacing, vfacing)].draw(graphics, x + xOffset, y + yOffset);
  };
  return PolarStar;
}());
},{"./sprite":29,"./spritestate":30,"./units":33,"std":31}],9:[function(require,module,exports){
var std, SDL, units, config, kScreenWidth, kScreenHeight, kBackgroundSize, FixedBackdrop, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
SDL = require('SDL');
units = require('./units');
config = require('./config');
kScreenWidth = config.kScreenWidth, kScreenHeight = config.kScreenHeight;
kBackgroundSize = 4;
out$.FixedBackdrop = FixedBackdrop = (function(){
  FixedBackdrop.displayName = 'FixedBackdrop';
  var prototype = FixedBackdrop.prototype, constructor = FixedBackdrop;
  function FixedBackdrop(path, graphics){
    this.surface = graphics.loadImage(path);
  }
  prototype.draw = function(graphics){
    var i$, step$, to$, x, lresult$, j$, step1$, to1$, y, destRect, results$ = [];
    for (i$ = 0, to$ = units.tileToPx(kScreenWidth + kBackgroundSize), step$ = units.tileToPx(kBackgroundSize); step$ < 0 ? i$ >= to$ : i$ <= to$; i$ += step$) {
      x = i$;
      lresult$ = [];
      for (j$ = 0, to1$ = units.tileToPx(kScreenHeight + kBackgroundSize), step1$ = units.tileToPx(kBackgroundSize); step1$ < 0 ? j$ >= to1$ : j$ <= to1$; j$ += step1$) {
        y = j$;
        destRect = new SDL.Rect(x, y, units.tileToPx(kBackgroundSize), units.tileToPx(kBackgroundSize));
        lresult$.push(graphics.blitSurface(this.surface, null, destRect));
      }
      results$.push(lresult$);
    }
    return results$;
  };
  return FixedBackdrop;
}());
},{"./config":10,"./units":33,"SDL":23,"std":31}],10:[function(require,module,exports){
var kScreenWidth, kScreenHeight, kFps, kMaxFrameTime, kDebugMode, kGraphicsQuality, out$ = typeof exports != 'undefined' && exports || this;
out$.kScreenWidth = kScreenWidth = 20;
out$.kScreenHeight = kScreenHeight = 15;
out$.kFps = kFps = 60;
out$.kMaxFrameTime = kMaxFrameTime = 5 * 1000 / kFps;
out$.kDebugMode = kDebugMode = true;
out$.kGraphicsQuality = kGraphicsQuality = 16;
},{}],11:[function(require,module,exports){
var std, units, Timer, NumberSprite, kVelocity, kVanishTime, DamageText, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
Timer = require('./timer').Timer;
NumberSprite = require('./sprite').NumberSprite;
kVelocity = -units.kHalfTile / 250;
kVanishTime = 2000;
out$.DamageText = DamageText = (function(){
  DamageText.displayName = 'DamageText';
  var prototype = DamageText.prototype, constructor = DamageText;
  function DamageText(graphics, x, y){
    this.x = x;
    this.y = y;
    this.timer = new Timer(kVanishTime);
    this.damage = 0;
    this.offsetY = 0;
  }
  prototype.setDamage = function(damage){
    this.damage = damage;
    this.timer.reset();
    return this.offsetY = 0;
  };
  prototype.update = function(elapsedTime){
    return this.offsetY = std.max(units.tileToGame(-1), this.offsetY + kVelocity * elapsedTime);
  };
  prototype.draw = function(graphics, x, y){
    if (this.timer.isActive()) {
      return new NumberSprite.DamageNumber(graphics, this.damage).drawCentered(graphics, x, y + this.offsetY);
    }
  };
  return DamageText;
}());
},{"./sprite":29,"./timer":32,"./units":33,"std":31}],12:[function(require,module,exports){
var std, units, tileToPx, tileToGame, kHalfTile, kTilePx, Rect, ref$, Sprite, AnimatedSprite, RIGHT, LEFT, kAngularVelocity, kFlyFps, kNumFlyFrames, kContactDamage, SpriteState, FirstCaveBat, slice$ = [].slice, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
tileToPx = units.tileToPx, tileToGame = units.tileToGame, kHalfTile = units.kHalfTile, kTilePx = units.kTilePx;
Rect = require('./rectangle').Rectangle;
ref$ = require('./sprite'), Sprite = ref$.Sprite, AnimatedSprite = ref$.AnimatedSprite;
RIGHT = "R";
LEFT = "L";
kAngularVelocity = 120 / 1000;
kFlyFps = 15;
kNumFlyFrames = 3;
kContactDamage = 1;
SpriteState = function(){
  var args;
  args = slice$.call(arguments);
  return String(args.join('-'));
};
out$.FirstCaveBat = FirstCaveBat = (function(){
  FirstCaveBat.displayName = 'FirstCaveBat';
  var prototype = FirstCaveBat.prototype, constructor = FirstCaveBat;
  function FirstCaveBat(graphics, x, centerY){
    this.x = x;
    this.centerY = centerY;
    this.y = this.centerY;
    this.flightAngle = 0;
    this.angularVelocity = kAngularVelocity;
    this.horizontalFacing = RIGHT;
    this.sprites = this.initialiseSprites(graphics);
    this.contactDamage = kContactDamage;
  }
  prototype.getSpriteState = function(){
    return SpriteState(this.horizontalFacing);
  };
  prototype.initialiseSprite = function(graphics, facing){
    var facingOffset;
    facingOffset = facing === RIGHT ? 1 : 0;
    return new AnimatedSprite(graphics, 'data/16x16/Npc/NpcCemet.bmp', tileToPx(2), tileToPx(2 + facingOffset), kTilePx, kTilePx, kFlyFps, kNumFlyFrames);
  };
  prototype.initialiseSprites = function(graphics, spriteMap){
    var i$, ref$, len$, facing;
    spriteMap == null && (spriteMap = {});
    for (i$ = 0, len$ = (ref$ = [LEFT, RIGHT]).length; i$ < len$; ++i$) {
      facing = ref$[i$];
      spriteMap[SpriteState(facing)] = this.initialiseSprite(graphics, facing);
    }
    return spriteMap;
  };
  prototype.update = function(elapsedTime, playerX){
    this.horizontalFacing = playerX < this.x ? LEFT : RIGHT;
    this.flightAngle += this.angularVelocity * elapsedTime;
    this.y = this.centerY + units.tileToGame(5) / 2 * std.sin(units.degToRad(this.flightAngle));
    return this.sprites[this.getSpriteState()].update(elapsedTime);
  };
  prototype.draw = function(graphics){
    return this.sprites[this.getSpriteState()].draw(graphics, this.x, this.y);
  };
  prototype.damageCollision = function(){
    return new Rect(this.x + kHalfTile, this.y + kHalfTile, 1, 1);
  };
  return FirstCaveBat;
}());
},{"./rectangle":20,"./sprite":29,"./units":33,"std":31}],13:[function(require,module,exports){
var std, SDL, input, units, config, readout, graphics, Map, tileToGame, Timer, Player, Rectangle, FirstCaveBat, FixedBackdrop, kScreenWidth, kScreenHeight, kFps, kMaxFrameTime, kDebugMode, running, player, bat, map, lastFrameTime, anyKeysPressed, eventLoop, update, draw, createTestWorld, start, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
SDL = require('SDL');
input = require('./input');
units = require('./units');
config = require('./config');
readout = require('./readout');
graphics = require('./graphics');
Map = require('./map');
tileToGame = units.tileToGame;
Timer = require('./timer').Timer;
Player = require('./player').Player;
Rectangle = require('./rectangle').Rectangle;
FirstCaveBat = require('./first-cave-bat').FirstCaveBat;
FixedBackdrop = require('./backdrop').FixedBackdrop;
kScreenWidth = config.kScreenWidth, kScreenHeight = config.kScreenHeight, kFps = config.kFps, kMaxFrameTime = config.kMaxFrameTime, kDebugMode = config.kDebugMode;
running = true;
player = null;
bat = null;
map = null;
lastFrameTime = 0;
anyKeysPressed = false;
eventLoop = function(){
  var startTime, event, Δt, elapsedTime;
  startTime = SDL.getTicks();
  input.beginNewFrame();
  while (event = SDL.pollEvent()) {
    anyKeysPressed = true;
    readout.update('willstop', false);
    switch (event.type) {
    case SDL.KEYDOWN:
      input.keyDownEvent(event);
      break;
    case SDL.KEYUP:
      input.keyUpEvent(event);
      break;
    default:
      throw new Error({
        message: "Unknown event type: " + event
      });
    }
  }
  if (input.wasKeyPressed(SDL.KEY.ESCAPE)) {
    running = false;
  }
  if (input.isKeyHeld(SDL.KEY.LEFT) && input.isKeyHeld(SDL.KEY.RIGHT)) {
    player.stopMoving();
  } else if (input.isKeyHeld(SDL.KEY.LEFT)) {
    player.startMovingLeft();
  } else if (input.isKeyHeld(SDL.KEY.RIGHT)) {
    player.startMovingRight();
  } else {
    player.stopMoving();
  }
  if (input.wasKeyPressed(SDL.KEY.Z)) {
    player.startJump();
  } else if (input.wasKeyReleased(SDL.KEY.Z)) {
    player.stopJump();
  }
  if (input.isKeyHeld(SDL.KEY.UP) && input.isKeyHeld(SDL.KEY.DOWN)) {
    player.lookHorizontal();
  } else if (input.isKeyHeld(SDL.KEY.UP)) {
    player.lookUp();
  } else if (input.isKeyHeld(SDL.KEY.DOWN)) {
    player.lookDown();
  } else {
    player.lookHorizontal();
  }
  Δt = std.min(SDL.getTicks() - lastFrameTime, kMaxFrameTime);
  update(Δt);
  draw();
  if (running) {
    lastFrameTime = SDL.getTicks();
    elapsedTime = lastFrameTime - startTime;
    readout.update('frametime', std.floor(1000 / Δt));
    readout.update('drawtime', elapsedTime);
    return SDL.delay(1000 / kFps - elapsedTime, eventLoop);
  } else {
    return std.log('Game stopped.');
  }
};
update = function(elapsedTime){
  Timer.updateAll(elapsedTime);
  player.update(elapsedTime, map);
  bat.update(elapsedTime, player.x);
  if (bat.damageCollision().collidesWith(player.damageCollision())) {
    readout.update('collided', true);
    return player.takeDamage(bat.contactDamage);
  } else {
    return readout.update('collided', false);
  }
};
draw = function(){
  graphics.clear();
  map.drawBackground(graphics);
  bat.draw(graphics);
  player.draw(graphics);
  map.draw(graphics);
  return player.drawHud(graphics);
};
createTestWorld = function(){
  map = Map.createTestMap(graphics);
  player = new Player(graphics, units.tileToGame(kScreenWidth / 2), units.tileToGame(10));
  return bat = new FirstCaveBat(graphics, units.tileToGame(7), units.tileToGame(8));
};
out$.start = start = function(){
  SDL.init(SDL.INIT_EVERYTHING);
  readout.addReader('frametime', 'Frame time');
  readout.addReader('drawtime', 'Draw time');
  readout.addReader('willstop', 'Will stop', true);
  readout.addReader('collided', 'Collision?', false);
  createTestWorld();
  eventLoop();
  player.startMovingLeft();
  return std.delay(5000, function(){
    if (!anyKeysPressed) {
      return running = false;
    } else {
      return std.log("Game being interacted with. Don't shut down");
    }
  });
};
},{"./backdrop":9,"./config":10,"./first-cave-bat":12,"./graphics":14,"./input":16,"./map":17,"./player":18,"./readout":19,"./rectangle":20,"./timer":32,"./units":33,"SDL":23,"std":31}],14:[function(require,module,exports){
var std, SDL, config, units, kScreenWidth, kScreenHeight, kTransparentColor, kScreenScaleFactor, spritesheets, screen, loadImage, blitSurface, visualiseRect, clear, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
SDL = require('SDL');
config = require('./config');
units = require('./units');
kScreenWidth = config.kScreenWidth, kScreenHeight = config.kScreenHeight;
kTransparentColor = [0, 0, 0];
kScreenScaleFactor = 2;
spritesheets = {};
screen = SDL.setVideoMode(units.tileToPx(kScreenWidth), units.tileToPx(kScreenHeight), kScreenScaleFactor);
out$.loadImage = loadImage = function(path, useTransparency){
  useTransparency == null && (useTransparency = false);
  if (spritesheets[path] == null) {
    spritesheets[path] = SDL.loadImage(path);
    if (useTransparency) {
      SDL.setColorKey(spritesheets[path], kTransparentColor);
    }
    if (config.kDebugMode) {
      document.body.appendChild(spritesheets[path].canvas);
    }
  }
  return spritesheets[path];
};
out$.blitSurface = blitSurface = function(source, srcRect, destRect){
  return SDL.blitSurface(source, srcRect, screen, destRect);
};
out$.visualiseRect = visualiseRect = function(rect, fill){
  var paintRect;
  paintRect = new SDL.Rect(units.gameToPx(rect.left), units.gameToPx(rect.top), units.gameToPx(rect.w), units.gameToPx(rect.h));
  if (fill) {
    return screen.drawRect(paintRect, 'red');
  } else {
    return screen.drawBox(paintRect, 'red');
  }
};
out$.clear = clear = function(){
  return screen.clear();
};
},{"./config":10,"./units":33,"SDL":23,"std":31}],15:[function(require,module,exports){
var std, units, div, kHalfTile, tileToPx, pxToGame, tileToGame, Timer, ref$, Sprite, NumberSprite, VaryingWidthSprite, kHealthBarX, kHealthBarY, kHealthFillX, kHealthFillY, kHealthNumX, kHealthNumY, kMaxFillPx, kDamageDelay, kSpritePath, Health, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
div = std.div;
kHalfTile = units.kHalfTile, tileToPx = units.tileToPx, pxToGame = units.pxToGame, tileToGame = units.tileToGame;
Timer = require('./timer').Timer;
ref$ = require('./sprite'), Sprite = ref$.Sprite, NumberSprite = ref$.NumberSprite, VaryingWidthSprite = ref$.VaryingWidthSprite;
kHealthBarX = tileToGame(1);
kHealthBarY = tileToGame(2);
kHealthFillX = tileToGame(2.5);
kHealthFillY = tileToGame(2);
kHealthNumX = tileToGame(1.5);
kHealthNumY = tileToGame(2);
kMaxFillPx = tileToPx(2.5) - 1;
kDamageDelay = 1500;
kSpritePath = 'data/16x16/TextBox.bmp';
out$.Health = Health = (function(){
  Health.displayName = 'Health';
  var prototype = Health.prototype, constructor = Health;
  function Health(graphics, maxHealth){
    this.maxHealth = maxHealth != null ? maxHealth : 6;
    this.currentHealth = this.maxHealth;
    this.damage = 0;
    this.damageTimer = new Timer(kDamageDelay);
    this.healthBarSprite = new Sprite(graphics, kSpritePath, 0, tileToPx(2.5), tileToPx(4), tileToPx(0.5));
    this.healthFillSprite = new VaryingWidthSprite(graphics, kSpritePath, 0, tileToPx(1.5), kMaxFillPx, tileToPx(0.5));
    this.damageFillSprite = new VaryingWidthSprite(graphics, kSpritePath, 0, tileToPx(2.0), kMaxFillPx, tileToPx(0.5));
  }
  prototype.takeDamage = function(damage){
    if (this.currentHealth === 0) {
      return;
    }
    this.damageTimer.reset();
    this.healthFillSprite.setWidth(this.fillOffset(this.currentHealth - damage));
    this.damageFillSprite.setWidth(this.fillOffset(damage));
    this.damage = damage;
    return this.currentHealth - damage <= 0;
  };
  prototype.update = function(elapsedTime){
    if (this.damage > 0 && this.damageTimer.isExpired()) {
      this.currentHealth = std.max(0, this.currentHealth - this.damage);
      return this.damage = 0;
    }
  };
  prototype.fillOffset = function(health){
    return kMaxFillPx * (health / this.maxHealth);
  };
  prototype.draw = function(graphics){
    var x;
    this.healthBarSprite.draw(graphics, kHealthBarX, kHealthBarY);
    if (this.currentHealth !== 0) {
      this.healthFillSprite.draw(graphics, kHealthFillX, kHealthFillY);
      if (this.damage) {
        x = kHealthFillX + pxToGame(this.fillOffset(this.currentHealth - this.damage));
        this.damageFillSprite.draw(graphics, x, kHealthFillY);
      }
    }
    return new NumberSprite.HUDNumber(graphics, this.currentHealth, 2).draw(graphics, kHealthNumX, kHealthNumY);
  };
  return Health;
}());
},{"./sprite":29,"./timer":32,"./units":33,"std":31}],16:[function(require,module,exports){
var std, Input;
std = require('std');
Input = (function(){
  Input.displayName = 'Input';
  var prototype = Input.prototype, constructor = Input;
  function Input(){
    this.heldKeys = {};
    this.pressedKeys = {};
    this.releasedKeys = {};
  }
  prototype.beginNewFrame = function(){
    this.pressedKeys = {};
    return this.releasedKeys = {};
  };
  prototype.keyDownEvent = function(event){
    this.pressedKeys[event.key] = true;
    return this.heldKeys[event.key] = true;
  };
  prototype.keyUpEvent = function(event){
    this.releasedKeys[event.key] = true;
    return this.heldKeys[event.key] = false;
  };
  prototype.wasKeyPressed = function(key){
    return this.pressedKeys[key];
  };
  prototype.wasKeyReleased = function(key){
    return this.releasedKeys[key];
  };
  prototype.isKeyHeld = function(key){
    return this.heldKeys[key];
  };
  return Input;
}());
module.exports = new Input;
},{"std":31}],17:[function(require,module,exports){
var std, units, div, tileToPx, Sprite, FixedBackdrop, Rect, ref$, AIR_TILE, WALL_TILE, Tile, CollisionTile, Map;
std = require('std');
units = require('./units');
div = std.div;
tileToPx = units.tileToPx;
Sprite = require('./sprite').Sprite;
FixedBackdrop = require('./backdrop').FixedBackdrop;
Rect = require('./rectangle').Rectangle;
ref$ = std['enum'], AIR_TILE = ref$[0], WALL_TILE = ref$[1];
Tile = (function(){
  Tile.displayName = 'Tile';
  var prototype = Tile.prototype, constructor = Tile;
  function Tile(type, sprite){
    this.type = type != null ? type : AIR_TILE;
    this.sprite = sprite;
  }
  return Tile;
}());
CollisionTile = (function(){
  CollisionTile.displayName = 'CollisionTile';
  var prototype = CollisionTile.prototype, constructor = CollisionTile;
  function CollisionTile(row, col, type){
    this.row = row;
    this.col = col;
    this.type = type;
  }
  return CollisionTile;
}());
module.exports = Map = (function(){
  Map.displayName = 'Map';
  var prototype = Map.prototype, constructor = Map;
  function Map(){
    this.backdrop = null;
    this.tiles = Map.createMatrix(new Tile, 20, 15);
    this.bgTiles = Map.createMatrix(null, 20, 15);
  }
  prototype.update = function(elapsedTime){
    var i$, ref$, len$, row, lresult$, j$, len1$, tile, ref1$, results$ = [];
    for (i$ = 0, len$ = (ref$ = this.tiles).length; i$ < len$; ++i$) {
      row = ref$[i$];
      lresult$ = [];
      for (j$ = 0, len1$ = row.length; j$ < len1$; ++j$) {
        tile = row[j$];
        lresult$.push((ref1$ = tile.sprite) != null ? ref1$.update(elapsedTime) : void 8);
      }
      results$.push(lresult$);
    }
    return results$;
  };
  prototype.draw = function(graphics){
    var i$, ref$, len$, y, row, lresult$, j$, len1$, x, tile, ref1$, results$ = [];
    for (i$ = 0, len$ = (ref$ = this.tiles).length; i$ < len$; ++i$) {
      y = i$;
      row = ref$[i$];
      lresult$ = [];
      for (j$ = 0, len1$ = row.length; j$ < len1$; ++j$) {
        x = j$;
        tile = row[j$];
        lresult$.push((ref1$ = tile.sprite) != null ? ref1$.draw(graphics, units.tileToGame(x), units.tileToGame(y)) : void 8);
      }
      results$.push(lresult$);
    }
    return results$;
  };
  prototype.drawBackground = function(graphics){
    var i$, ref$, len$, y, row, lresult$, j$, len1$, x, sprite, results$ = [];
    this.backdrop.draw(graphics);
    for (i$ = 0, len$ = (ref$ = this.bgTiles).length; i$ < len$; ++i$) {
      y = i$;
      row = ref$[i$];
      lresult$ = [];
      for (j$ = 0, len1$ = row.length; j$ < len1$; ++j$) {
        x = j$;
        sprite = row[j$];
        lresult$.push(sprite != null ? sprite.draw(graphics, units.tileToGame(x), units.tileToGame(y)) : void 8);
      }
      results$.push(lresult$);
    }
    return results$;
  };
  prototype.getCollidingTiles = function(rect){
    var firstRow, lastRow, firstCol, lastCol, collisionTiles, i$, row, j$, col;
    firstRow = div(units.gameToPx(rect.top), units.tileToPx(1));
    lastRow = div(units.gameToPx(rect.bottom), units.tileToPx(1));
    firstCol = div(units.gameToPx(rect.left), units.tileToPx(1));
    lastCol = div(units.gameToPx(rect.right), units.tileToPx(1));
    collisionTiles = [];
    for (i$ = firstRow; i$ <= lastRow; ++i$) {
      row = i$;
      for (j$ = firstCol; j$ <= lastCol; ++j$) {
        col = j$;
        collisionTiles.push(new CollisionTile(row, col, this.tiles[row][col].type));
      }
    }
    return collisionTiles;
  };
  Map.createTestMap = function(graphics){
    var map, bgPath, fgPath, numRows, numCols, row, tile, i$, col, chainTop, chainMid, chainBtm, gateA, gateB, gateC, gateD;
    map = new Map;
    bgPath = 'data/16x16/bkBlue.bmp';
    fgPath = 'data/16x16/Stage/PrtCave.bmp';
    map.backdrop = new FixedBackdrop(bgPath, graphics);
    numRows = 15;
    numCols = 20;
    row = 11;
    tile = new Tile(WALL_TILE, new Sprite(graphics, fgPath, units.tileToPx(1), 0, units.tileToPx(1), units.tileToPx(1)));
    for (i$ = 0; i$ <= numCols; ++i$) {
      col = i$;
      map.tiles[row][col] = tile;
    }
    map.tiles[10][5] = tile;
    map.tiles[9][4] = tile;
    map.tiles[8][3] = tile;
    map.tiles[7][2] = tile;
    map.tiles[10][3] = tile;
    chainTop = new Sprite(graphics, fgPath, tileToPx(10), tileToPx(4), tileToPx(1), tileToPx(1));
    chainMid = new Sprite(graphics, fgPath, tileToPx(10), tileToPx(5), tileToPx(1), tileToPx(1));
    chainBtm = new Sprite(graphics, fgPath, tileToPx(10), tileToPx(6), tileToPx(1), tileToPx(1));
    map.bgTiles[8][2] = chainTop;
    map.bgTiles[9][2] = chainMid;
    map.bgTiles[10][2] = chainBtm;
    gateA = new Sprite(graphics, fgPath, tileToPx(8), tileToPx(9), tileToPx(1), tileToPx(1));
    gateB = new Sprite(graphics, fgPath, tileToPx(9), tileToPx(9), tileToPx(1), tileToPx(1));
    gateC = new Sprite(graphics, fgPath, tileToPx(8), tileToPx(10), tileToPx(1), tileToPx(1));
    gateD = new Sprite(graphics, fgPath, tileToPx(9), tileToPx(10), tileToPx(1), tileToPx(1));
    map.bgTiles[9][15] = gateA;
    map.bgTiles[9][16] = gateB;
    map.bgTiles[10][15] = gateC;
    map.bgTiles[10][16] = gateD;
    return map;
  };
  Map.createMatrix = function(value, cols, rows){
    var i$, y, lresult$, j$, z, results$ = [];
    for (i$ = 0; i$ <= rows; ++i$) {
      y = i$;
      lresult$ = [];
      for (j$ = 0; j$ <= cols; ++j$) {
        z = j$;
        lresult$.push(value);
      }
      results$.push(lresult$);
    }
    return results$;
  };
  Map.WALL_TILE = WALL_TILE;
  Map.AIR_TILE = AIR_TILE;
  return Map;
}());
},{"./backdrop":9,"./rectangle":20,"./sprite":29,"./units":33,"std":31}],18:[function(require,module,exports){
var std, units, config, readout, kHalfTile, tileToGame, tileToPx, SpriteState, STANDING, WALKING, JUMPING, FALLING, INTERACTING, LEFT, RIGHT, UP, DOWN, HORIZONTAL, WALL_TILE, Rect, Timer, Health, DamageText, PolarStar, ref$, Sprite, AnimatedSprite, NumberSprite, kCharacterFrame, kWalkFrame, kStandFrame, kJumpFrame, kFallFrame, kUpFrameOffset, kDownFrame, kBackFrame, kWalkFps, kFriction, kGravity, kWalkingAcceleration, kAirAcceleration, kMaxSpeedX, kMaxSpeedY, kJumpSpeed, kShortJumpSpeed, kJumpGravity, kInvincibleTime, kInvincibleFlashTime, kCollisionX, kCollisionY, Player, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
config = require('./config');
readout = require('./readout');
kHalfTile = units.kHalfTile, tileToGame = units.tileToGame, tileToPx = units.tileToPx;
SpriteState = require('./spritestate'), STANDING = SpriteState.STANDING, WALKING = SpriteState.WALKING, JUMPING = SpriteState.JUMPING, FALLING = SpriteState.FALLING, INTERACTING = SpriteState.INTERACTING, LEFT = SpriteState.LEFT, RIGHT = SpriteState.RIGHT, UP = SpriteState.UP, DOWN = SpriteState.DOWN, HORIZONTAL = SpriteState.HORIZONTAL;
WALL_TILE = require('./map').WALL_TILE;
Rect = require('./rectangle').Rectangle;
Timer = require('./timer').Timer;
Health = require('./health').Health;
DamageText = require('./damage-text').DamageText;
PolarStar = require('./arms').PolarStar;
ref$ = require('./sprite'), Sprite = ref$.Sprite, AnimatedSprite = ref$.AnimatedSprite, NumberSprite = ref$.NumberSprite;
kCharacterFrame = 0;
kWalkFrame = 0;
kStandFrame = 0;
kJumpFrame = 1;
kFallFrame = 2;
kUpFrameOffset = 3;
kDownFrame = 6;
kBackFrame = 7;
kWalkFps = 15;
kFriction = 0.00049804687;
kGravity = 0.00078125;
kWalkingAcceleration = 0.00083007812;
kAirAcceleration = 0.0003125;
kMaxSpeedX = 0.15859375;
kMaxSpeedY = 0.2998046875;
kJumpSpeed = 0.25;
kShortJumpSpeed = 0.25 / 1.5;
kJumpGravity = 0.0003125;
kInvincibleTime = 3000;
kInvincibleFlashTime = 50;
kCollisionX = new Rect(6, 10, 20, 12);
kCollisionY = new Rect(10, 2, 12, 30);
out$.Player = Player = (function(){
  Player.displayName = 'Player';
  var prototype = Player.prototype, constructor = Player;
  function Player(graphics, x, y){
    this.x = x;
    this.y = y;
    this.velocityY = 0;
    this.velocityX = 0;
    this.accelerationX = 0;
    this.horizontalFacing = LEFT;
    this.verticalFacing = HORIZONTAL;
    this.onGround = false;
    this.jumpActive = false;
    this.interacting = false;
    this.invincibleTimer = new Timer(kInvincibleTime);
    this.health = new Health(graphics);
    this.sprites = this.initialiseSprites(graphics);
    this.damageText = new DamageText(graphics);
    this.gun = new PolarStar(graphics);
    if (config.kDebugMode) {
      readout.addReader('spritestate', 'SpriteState');
    }
  }
  prototype.initialiseSprite = function(graphics, motion, hfacing, vfacing){
    var tileX, tileY, sourceX;
    tileX = (function(){
      switch (motion) {
      case WALKING:
        return kWalkFrame;
      case STANDING:
        return kStandFrame;
      case JUMPING:
        return kJumpFrame;
      case FALLING:
        return kFallFrame;
      case INTERACTING:
        return kBackFrame;
      }
    }());
    tileX += vfacing === UP ? kUpFrameOffset : 0;
    tileY = kCharacterFrame + (hfacing === LEFT ? 0 : 1);
    if (motion === WALKING) {
      return new AnimatedSprite(graphics, 'data/16x16/MyChar.bmp', units.tileToPx(tileX), units.tileToPx(tileY), units.tileToPx(1), units.tileToPx(1), kWalkFps, 3);
    } else {
      if (vfacing === DOWN && (motion === JUMPING || motion === FALLING)) {
        sourceX = kDownFrame;
      }
      return new Sprite(graphics, 'data/16x16/MyChar.bmp', units.tileToPx(tileX), units.tileToPx(tileY), units.tileToPx(1), units.tileToPx(1));
    }
  };
  prototype.initialiseSprites = function(graphics, spriteMap){
    var i$, ref$, len$, motion, j$, ref1$, len1$, hfacing, k$, ref2$, len2$, vfacing;
    spriteMap == null && (spriteMap = {});
    for (i$ = 0, len$ = (ref$ = [STANDING, WALKING, JUMPING, FALLING, INTERACTING]).length; i$ < len$; ++i$) {
      motion = ref$[i$];
      for (j$ = 0, len1$ = (ref1$ = [LEFT, RIGHT]).length; j$ < len1$; ++j$) {
        hfacing = ref1$[j$];
        for (k$ = 0, len2$ = (ref2$ = [UP, DOWN, HORIZONTAL]).length; k$ < len2$; ++k$) {
          vfacing = ref2$[k$];
          spriteMap[SpriteState.key(motion, hfacing, vfacing)] = this.initialiseSprite(graphics, motion, hfacing, vfacing);
        }
      }
    }
    return spriteMap;
  };
  prototype.update = function(elapsedTime, map){
    this.sprites[this.getSpriteState()].update(elapsedTime);
    this.health.update(elapsedTime);
    this.updateX(elapsedTime, map);
    this.updateY(elapsedTime, map);
    return this.damageText.update(elapsedTime);
  };
  prototype.updateX = function(elapsedTime, map){
    var accX, Δx;
    accX = this.onGround ? kWalkingAcceleration : kAirAcceleration;
    this.velocityX += this.accelerationX * accX * elapsedTime;
    if (this.accelerationX < 0) {
      this.velocityX = std.max(this.velocityX, -kMaxSpeedX);
    } else if (this.accelerationX > 0) {
      this.velocityX = std.min(this.velocityX, kMaxSpeedX);
    } else if (this.onGround) {
      this.velocityX = this.velocityX > 0
        ? std.max(0, this.velocityX - kFriction * elapsedTime)
        : std.min(0, this.velocityX + kFriction * elapsedTime);
    }
    Δx = this.velocityX * elapsedTime;
    if (Δx > 0) {
      this.onWallCollision(map, this.rightCollision(Δx), function(tile){
        if (tile) {
          this.x = units.tileToGame(tile.col) - kCollisionX.right;
          return this.velocityX = 0;
        } else {
          return this.x += Δx;
        }
      });
      return this.onWallCollision(map, this.leftCollision(0), function(tile){
        if (tile) {
          return this.x = units.tileToGame(tile.col) + kCollisionX.right;
        }
      });
    } else {
      this.onWallCollision(map, this.leftCollision(Δx), function(tile){
        if (tile) {
          this.x = units.tileToGame(tile.col) + kCollisionX.right;
          return this.velocityX = 0;
        } else {
          return this.x += Δx;
        }
      });
      return this.onWallCollision(map, this.rightCollision(0), function(tile){
        if (tile) {
          return this.x = units.tileToGame(tile.col) - kCollisionX.right;
        }
      });
    }
  };
  prototype.updateY = function(elapsedTime, map){
    var gravity, Δy;
    gravity = this.jumpActive && this.velocityY < 0 ? kJumpGravity : kGravity;
    this.velocityY = std.min(this.velocityY + gravity * elapsedTime, kMaxSpeedY);
    Δy = this.velocityY * elapsedTime;
    if (Δy > 0) {
      this.onWallCollision(map, this.bottomCollision(Δy), function(tile){
        if (tile) {
          this.y = units.tileToGame(tile.row) - kCollisionY.bottom;
          this.velocityY = 0;
          return this.onGround = true;
        } else {
          this.y += Δy;
          return this.onGround = false;
        }
      });
      return this.onWallCollision(map, this.topCollision(0), function(tile){
        if (tile) {
          return this.y = units.tileToGame(tile.row) + kCollisionY.h;
        }
      });
    } else {
      this.onWallCollision(map, this.topCollision(Δy), function(tile){
        if (tile) {
          this.y = units.tileToGame(tile.row) + kCollisionY.h;
          return this.velocityY = 0;
        } else {
          this.y += Δy;
          return this.onGround = false;
        }
      });
      return this.onWallCollision(map, this.bottomCollision(0), function(tile){
        if (tile) {
          this.y = units.tileToGame(tile.row) - kCollisionY.bottom;
          return this.onGround = true;
        }
      });
    }
  };
  prototype.takeDamage = function(damage){
    damage == null && (damage = 1);
    if (!this.invincibleTimer.isActive()) {
      this.health.takeDamage(damage);
      this.velocityY = std.min(-kShortJumpSpeed, this.velocityY);
      this.invincible = true;
      this.invincibleTimer.reset();
      return this.damageText.setDamage(damage);
    }
  };
  prototype.spriteIsVisible = function(){
    var duty;
    duty = std.div(this.invincibleTimer.currentTime, kInvincibleFlashTime) % 2 === 0;
    return !(this.invincibleTimer.isActive() && duty);
  };
  prototype.draw = function(graphics){
    if (this.spriteIsVisible()) {
      this.sprites[this.getSpriteState()].draw(graphics, this.x, this.y);
      this.gun.draw(graphics, this.x, this.y, this.horizontalFacing, this.verticalFacing);
    }
    return this.damageText.draw(graphics, this.centerX(), this.centerY());
  };
  prototype.drawHud = function(graphics){
    if (!this.spriteIsVisible()) {
      return;
    }
    return this.health.draw(graphics);
  };
  prototype.getSpriteState = function(){
    var motionType, key;
    motionType = this.interacting
      ? INTERACTING
      : this.onGround
        ? this.accelerationX === 0 ? STANDING : WALKING
        : this.velocityY < 0 ? JUMPING : FALLING;
    key = SpriteState.key(motionType, this.horizontalFacing, this.verticalFacing);
    readout.update('spritestate', key);
    return key;
  };
  prototype.leftCollision = function(Δ){
    return new Rect(this.x + kCollisionX.left + Δ, this.y + kCollisionX.top, kCollisionX.w / 2 - Δ, kCollisionX.h);
  };
  prototype.rightCollision = function(Δ){
    return new Rect(this.x + kCollisionX.left + kCollisionX.w / 2, this.y + kCollisionX.top, kCollisionX.w / 2 + Δ, kCollisionX.h);
  };
  prototype.topCollision = function(Δ){
    return new Rect(this.x + kCollisionY.left, this.y + kCollisionY.top + Δ, kCollisionY.w, kCollisionY.h / 2 - Δ);
  };
  prototype.bottomCollision = function(Δ){
    return new Rect(this.x + kCollisionY.left, this.y + kCollisionY.top + kCollisionY.h / 2 + Δ, kCollisionY.w, kCollisionY.h / 2 + Δ);
  };
  prototype.damageCollision = function(){
    return new Rect(this.x + kCollisionX.left, this.y + kCollisionY.top, kCollisionX.w, kCollisionY.h);
  };
  prototype.onWallCollision = function(map, rect, λ){
    var i$, ref$, len$, tile;
    for (i$ = 0, len$ = (ref$ = map.getCollidingTiles(rect)).length; i$ < len$; ++i$) {
      tile = ref$[i$];
      if (tile.type === WALL_TILE) {
        return λ.call(this, tile);
      }
    }
    return λ.call(this);
  };
  prototype.startMovingLeft = function(){
    this.horizontalFacing = LEFT;
    this.accelerationX = -1;
    return this.interacting = false;
  };
  prototype.startMovingRight = function(){
    this.horizontalFacing = RIGHT;
    this.accelerationX = 1;
    return this.interacting = false;
  };
  prototype.stopMoving = function(){
    return this.accelerationX = 0;
  };
  prototype.startJump = function(){
    this.jumpActive = true;
    this.interacting = false;
    if (this.onGround) {
      return this.velocityY = -kJumpSpeed;
    }
  };
  prototype.stopJump = function(){
    return this.jumpActive = false;
  };
  prototype.lookUp = function(){
    this.verticalFacing = UP;
    return this.interacting = false;
  };
  prototype.lookDown = function(){
    if (this.verticalFacing === DOWN) {
      return;
    }
    this.verticalFacing = DOWN;
    return this.interacting = this.onGround;
  };
  prototype.lookHorizontal = function(){
    return this.verticalFacing = HORIZONTAL;
  };
  prototype.centerX = function(){
    return this.x + kHalfTile;
  };
  prototype.centerY = function(){
    return this.y + kHalfTile;
  };
  return Player;
}());
},{"./arms":8,"./config":10,"./damage-text":11,"./health":15,"./map":17,"./readout":19,"./rectangle":20,"./sprite":29,"./spritestate":30,"./timer":32,"./units":33,"std":31}],19:[function(require,module,exports){
var elm, applyStyles, Reader, host, readers, install, addReader, update, removeReader, out$ = typeof exports != 'undefined' && exports || this;
elm = bind$(document, 'createElement');
applyStyles = function(el, styles){
  var k, v, results$ = [];
  for (k in styles) {
    v = styles[k];
    results$.push(el.style[k] = v);
  }
  return results$;
};
Reader = (function(){
  Reader.displayName = 'Reader';
  var prototype = Reader.prototype, constructor = Reader;
  function Reader(name, labelText, value){
    var that;
    this.name = name;
    this.labelText = labelText;
    this.value = value;
    this.dom = elm('tr');
    this.label = elm('td');
    this.output = elm('td');
    this.dom.appendChild(this.label);
    this.dom.appendChild(this.output);
    this.label.innerHTML = this.labelText;
    if (that = this.value) {
      this.output.innerHTML = that;
    }
  }
  prototype.update = function(value){
    this.value = value;
    return this.output.innerHTML = this.value;
  };
  prototype.hide = function(){
    return this.dom.styles.display = 'none';
  };
  prototype.show = function(){
    return this.dom.styles.display = 'block';
  };
  prototype.install = function(host){
    return host.appendChild(this.dom);
  };
  prototype['delete'] = function(){
    return this.dom.parentNode.removeChild(this.dom);
  };
  return Reader;
}());
host = elm('table');
readers = {};
applyStyles(host, {
  fontFamily: 'monospace',
  width: '100%',
  paddingLeft: '10px',
  color: 'lightgrey',
  borderWidth: "3px 1px"
});
out$.install = install = function(){
  return document.body.appendChild(host);
};
out$.addReader = addReader = function(name, label, value){
  readers[name] = new Reader(name, label, value);
  return readers[name].install(host);
};
out$.update = update = function(readerName, value){
  var ref$;
  return (ref$ = readers[readerName]) != null ? ref$.update(value) : void 8;
};
out$.removeReader = removeReader = function(name){
  var ref$;
  readers[name]['delete']();
  return ref$ = readers[name], delete readers[name], ref$;
};
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}
},{}],20:[function(require,module,exports){
var Rectangle, out$ = typeof exports != 'undefined' && exports || this;
out$.Rectangle = Rectangle = (function(){
  Rectangle.displayName = 'Rectangle';
  var prototype = Rectangle.prototype, constructor = Rectangle;
  function Rectangle(x, y, w, h, m){
    m == null && (m = 1);
    this.x = x * m;
    this.y = y * m;
    this.w = w * m;
    this.h = h * m;
    this.top = this.y;
    this.left = this.x;
    this.right = this.x + this.w;
    this.bottom = this.y + this.h;
  }
  prototype.collidesWith = function(other){
    return this.right >= other.left && this.left <= other.right && this.top <= other.bottom && this.bottom >= other.top;
  };
  return Rectangle;
}());
},{}],21:[function(require,module,exports){
var raf, out$ = typeof exports != 'undefined' && exports || this;
raf = requestAnimationFrame;
import$(out$, {
  delay: function(time, λ){
    return raf(λ);
  }
});
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{}],22:[function(require,module,exports){
var std, queue, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
queue = [];
import$(out$, {
  pushEvent: function(event){
    return queue.push(event);
  },
  pollEvent: function(){
    if (queue.length) {
      return queue.shift();
    }
  }
});
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{"std":31}],23:[function(require,module,exports){
var std, delay, timer, screen, keyboard, eventQueue, Rect, Surface, ref$, INIT_EVERYTHING, FULLSCREEN, init, KEY, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
delay = require('./delay');
timer = require('./timer');
screen = require('./screen');
keyboard = require('./keyboard');
eventQueue = require('./event-queue');
out$.Rect = Rect = require('./rect');
out$.Surface = Surface = require('./surface');
ref$ = std['enum'], INIT_EVERYTHING = ref$[0], FULLSCREEN = ref$[1];
out$.init = init = function(mode){
  std.log("SDL::Init - with mode:", mode);
  timer.init();
  return keyboard.init();
};
out$.INIT_EVERYTHING = INIT_EVERYTHING;
out$.FULLSCREEN = FULLSCREEN;
out$.KEYDOWN = keyboard.KEYDOWN;
out$.KEYUP = keyboard.KEYUP;
out$.KEY = KEY = keyboard.KEYCODES;
out$.delay = delay.delay;
out$.getTicks = timer.getTicks;
out$.pollEvent = eventQueue.pollEvent;
out$.setVideoMode = screen.setVideoMode;
out$.blitSurface = Surface.blitSurface;
out$.setColorKey = Surface.setColorKey;
out$.loadImage = Surface.loadImage;
},{"./delay":21,"./event-queue":22,"./keyboard":24,"./rect":25,"./screen":26,"./surface":27,"./timer":28,"std":31}],24:[function(require,module,exports){
var std, queue, ref$, KEYDOWN, KEYUP, KEYCODES, monitorKeys, init, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
queue = require('./event-queue');
ref$ = std['enum'], KEYDOWN = ref$[0], KEYUP = ref$[1];
out$.KEYCODES = KEYCODES = {
  ESCAPE: 27,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  A: 65,
  Q: 81,
  S: 83,
  W: 87,
  X: 88,
  Z: 90
};
monitorKeys = function(){
  document.addEventListener('keydown', function(event){
    var which;
    which = event.which;
    queue.pushEvent({
      type: KEYDOWN,
      key: which
    });
    return event.preventDefault();
  });
  return document.addEventListener('keyup', function(event){
    var which;
    which = event.which;
    queue.pushEvent({
      type: KEYUP,
      key: which
    });
    return event.preventDefault();
  });
};
out$.init = init = function(){
  std.log("SDL::Keyboard - Monitoring key input");
  return monitorKeys();
};
out$.KEYDOWN = KEYDOWN;
out$.KEYUP = KEYUP;
},{"./event-queue":22,"std":31}],25:[function(require,module,exports){
var Rect;
module.exports = Rect = (function(){
  Rect.displayName = 'Rect';
  var prototype = Rect.prototype, constructor = Rect;
  function Rect(x, y, w, h){
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }
  return Rect;
}());
},{}],26:[function(require,module,exports){
var std, Surface, applyScaleStyles, createNewScreen, setVideoMode, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
Surface = require('./surface');
applyScaleStyles = function(canvas, scaleFactor){
  if (scaleFactor !== 0) {
    return canvas.style.width = canvas.width * scaleFactor + 'px';
  }
};
createNewScreen = function(w, h, scaleFactor){
  var screen;
  screen = new Surface(null, w, h);
  document.body.appendChild(screen.canvas);
  applyScaleStyles(screen.canvas, scaleFactor);
  return screen;
};
out$.setVideoMode = setVideoMode = function(width, height, scaleFactor){
  scaleFactor == null && (scaleFactor = 1);
  return createNewScreen(width, height, scaleFactor);
};
},{"./surface":27,"std":31}],27:[function(require,module,exports){
var std, Rect, makeTransparent, Surface;
std = require('std');
Rect = require('./rect');
makeTransparent = function(data, color){
  var canvas, context, pixels, i$, to$, i;
  canvas = document.createElement('canvas');
  canvas.width = data.width;
  canvas.height = data.height;
  context = canvas.getContext('2d');
  context.drawImage(data, 0, 0);
  pixels = context.getImageData(0, 0, canvas.width, canvas.height);
  for (i$ = 0, to$ = pixels.data.length; i$ <= to$; i$ += 4) {
    i = i$;
    if (pixels.data[i + 0] === color[0] && pixels.data[i + 1] === color[1] && pixels.data[i + 2] === color[2]) {
      pixels.data[i + 3] = 0;
    }
  }
  context.putImageData(pixels, 0, 0);
  return canvas;
};
module.exports = Surface = (function(){
  Surface.displayName = 'Surface';
  var prototype = Surface.prototype, constructor = Surface;
  function Surface(src, width, height){
    this.width = width;
    this.height = height;
    this.canvas = document.createElement('canvas');
    this.ctx = this.canvas.getContext('2d');
    this.ready = false;
    this.colorKey = null;
    this.resetCanvasSize();
    this.ctx.fillStyle = 'red';
    this.ctx.fillRect(0, 0, this.width, this.height);
    if (typeof src === 'string') {
      this.loadImageData(src);
    } else if (src != null) {
      this.saveImageData(src);
    } else {}
  }
  prototype.resetCanvasSize = function(){
    this.canvas.width = this.width;
    return this.canvas.height = this.height;
  };
  prototype.inheritSizeFromImage = function(data){
    if (this.width == null && this.height == null) {
      this.width = data.naturalWidth;
      this.height = data.naturalHeight;
      return this.resetCanvasSize();
    }
  };
  prototype.loadImageData = function(path){
    var data, this$ = this;
    data = new Image;
    data.onload = function(){
      this$.inheritSizeFromImage(data);
      return this$.saveImageData(data);
    };
    data.onerror = function(){
      std.log("Cant load:", path);
      return this$.ctx.fillRect(0, 0, this$.width, this$.height);
    };
    return data.src = path;
  };
  prototype.saveImageData = function(data){
    this.data = this.colorKey ? makeTransparent(data, this.colorKey) : data;
    this.ready = true;
    this.ctx.clearRect(0, 0, this.width, this.height);
    return this.ctx.drawImage(this.data, 0, 0, this.width, this.height);
  };
  prototype.setColorKey = function(color){
    this.colorKey = color;
    if (this.ready) {
      return this.saveImageData(this.data);
    }
  };
  prototype.drawRect = function(rect, color){
    color == null && (color = 'black');
    this.ctx.fillStyle = color;
    return this.ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
  };
  prototype.drawBox = function(rect, color){
    color == null && (color = 'black');
    this.ctx.strokeStyle = color;
    this.ctx.beginPath();
    this.ctx.moveTo(0.5 + rect.x, 0.5 + rect.y);
    this.ctx.lineTo(0.5 + rect.x, -0.5 + rect.y + rect.h);
    this.ctx.lineTo(-0.5 + rect.x + rect.w, -0.5 + rect.y + rect.h);
    this.ctx.lineTo(-0.5 + rect.x + rect.w, 0.5 + rect.y);
    this.ctx.lineTo(0.5 + rect.x, 0.5 + rect.y);
    this.ctx.stroke();
    return this.ctx.closePath();
  };
  prototype.clear = function(){
    return this.ctx.clearRect(0, 0, this.width, this.height);
  };
  Surface.setColorKey = function(surface, color){
    return surface.setColorKey(color);
  };
  Surface.blitSurface = function(source, srcRect, dest, destRect){
    if (srcRect) {
      return dest.ctx.drawImage(source.canvas, srcRect.x, srcRect.y, srcRect.w, srcRect.h, destRect.x, destRect.y, destRect.w, destRect.h);
    } else {
      return dest.ctx.drawImage(source.canvas, destRect.x, destRect.y, destRect.w, destRect.h);
    }
  };
  Surface.loadImage = function(path){
    return new Surface(path);
  };
  return Surface;
}());
},{"./rect":25,"std":31}],28:[function(require,module,exports){
var startTime, out$ = typeof exports != 'undefined' && exports || this;
startTime = 0;
import$(out$, {
  init: function(){
    return startTime = Date.now();
  },
  getTicks: function(){
    return Date.now() - startTime;
  }
});
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{}],29:[function(require,module,exports){
var SDL, std, units, div, kHalfTile, tileToPx, gameToPx, Rect, Sprite, AnimatedSprite, NumberSprite, VaryingWidthSprite, out$ = typeof exports != 'undefined' && exports || this;
SDL = require('SDL');
std = require('std');
units = require('./units');
div = std.div;
kHalfTile = units.kHalfTile, tileToPx = units.tileToPx, gameToPx = units.gameToPx;
Rect = require('./rectangle').Rectangle;
out$.Sprite = Sprite = (function(){
  Sprite.displayName = 'Sprite';
  var prototype = Sprite.prototype, constructor = Sprite;
  function Sprite(graphics, path, sourceX, sourceY, width, height){
    this.width = width;
    this.height = height;
    this.sourceRect = new SDL.Rect(sourceX, sourceY, width, height);
    this.spriteSheet = graphics.loadImage(path, true);
  }
  prototype.update = function(){};
  prototype.draw = function(graphics, x, y){
    var destRect;
    destRect = new SDL.Rect(units.gameToPx(x), units.gameToPx(y), this.width, this.height);
    return graphics.blitSurface(this.spriteSheet, this.sourceRect, destRect);
  };
  return Sprite;
}());
out$.AnimatedSprite = AnimatedSprite = (function(superclass){
  var prototype = extend$((import$(AnimatedSprite, superclass).displayName = 'AnimatedSprite', AnimatedSprite), superclass).prototype, constructor = AnimatedSprite;
  function AnimatedSprite(graphics, path, sourceX, sourceY, width, height, fps, numFrames){
    this.width = width;
    this.height = height;
    this.fps = fps;
    this.numFrames = numFrames;
    AnimatedSprite.superclass.apply(this, arguments);
    this.frameTime = 1000 / this.fps;
    this.currentFrame = 0;
    this.elapsedTime = 0;
  }
  prototype.update = function(elapsedTime){
    this.elapsedTime += elapsedTime;
    if (this.elapsedTime > this.frameTime) {
      this.currentFrame += 1;
      this.elapsedTime = 0;
      if (this.currentFrame < this.numFrames) {
        return this.sourceRect.x += this.sourceRect.w;
      } else {
        this.sourceRect.x -= this.sourceRect.w * (this.numFrames - 1);
        return this.currentFrame = 0;
      }
    }
  };
  return AnimatedSprite;
}(Sprite));
out$.NumberSprite = NumberSprite = (function(){
  NumberSprite.displayName = 'NumberSprite';
  var kDigitSrcY, kDigitSrcWidth, kDigitSrcHeight, kOpPlusSrcX, kOpMinusSrcX, kOpSrcY, kDigitSize, kRadix, ref$, WHITE, RED, PLUS, MINUS, NONE, prototype = NumberSprite.prototype, constructor = NumberSprite;
  kDigitSrcY = tileToPx(3.5);
  kDigitSrcWidth = tileToPx(0.5);
  kDigitSrcHeight = tileToPx(0.5);
  kOpPlusSrcX = tileToPx(2);
  kOpMinusSrcX = tileToPx(2.5);
  kOpSrcY = tileToPx(3);
  kDigitSize = units.kHalfTile;
  kRadix = 10;
  ref$ = std['enum'], WHITE = ref$[0], RED = ref$[1];
  ref$ = std['enum'], PLUS = ref$[0], MINUS = ref$[1], NONE = ref$[2];
  function NumberSprite(graphics, num, len, color, op){
    var srcY;
    this.num = num;
    this.len = len;
    this.color = color;
    this.op = op;
    this.digits = NumberSprite.seperateDigits(this.num);
    this.numDigits = this.digits.length;
    this.padding = this.len === 0
      ? 0
      : kDigitSize * (this.len - this.numDigits);
    srcY = this.color === WHITE
      ? kDigitSrcY
      : kDigitSrcY + gameToPx(kHalfTile);
    this.glyphs = this.digits.map(function(it){
      return new Sprite(graphics, 'data/16x16/TextBox.bmp', tileToPx(0.5 * it), srcY, kDigitSrcWidth, kDigitSrcHeight);
    });
    if (this.op === PLUS) {
      this.glyphs.push(new Sprite(graphics, 'data/16x16/TextBox.bmp', kOpPlusSrcX, kOpSrcY, kDigitSrcWidth, kDigitSrcHeight));
    }
    if (this.op === MINUS) {
      this.glyphs.push(new Sprite(graphics, 'data/16x16/TextBox.bmp', kOpMinusSrcX, kOpSrcY, kDigitSrcWidth, kDigitSrcHeight));
    }
    this.width = kHalfTile * this.glyphs.length;
    this.height = kHalfTile;
  }
  prototype.draw = function(graphics, x, y){
    var i$, ref$, len$, i, glyph, offset, results$ = [];
    for (i$ = 0, len$ = (ref$ = this.glyphs).length; i$ < len$; ++i$) {
      i = i$;
      glyph = ref$[i$];
      offset = kDigitSize * (this.glyphs.length - 1 - i);
      results$.push(glyph.draw(graphics, x + this.padding + offset, y));
    }
    return results$;
  };
  prototype.drawCentered = function(graphics, x, y){
    return this.draw(graphics, x - this.width / 2, y - this.height / 2);
  };
  NumberSprite.seperateDigits = function(num){
    var digit, results$ = [];
    if (num === 0) {
      return [0];
    } else {
      while (num !== 0) {
        digit = num % kRadix;
        num = div(num, kRadix);
        results$.push(digit);
      }
      return results$;
    }
  };
  NumberSprite.HUDNumber = function(graphics, num, len){
    this.num = num;
    this.len = len;
    return new NumberSprite(graphics, this.num, this.len, WHITE, NONE);
  };
  NumberSprite.DamageNumber = function(graphics, num){
    this.num = num;
    return new NumberSprite(graphics, this.num, 0, RED, MINUS);
  };
  NumberSprite.ExperienceNumber = function(graphics, num){
    this.num = num;
    return new NumberSprite(graphics, this.num, 0, WHITE, PLUS);
  };
  return NumberSprite;
}());
out$.VaryingWidthSprite = VaryingWidthSprite = (function(superclass){
  var prototype = extend$((import$(VaryingWidthSprite, superclass).displayName = 'VaryingWidthSprite', VaryingWidthSprite), superclass).prototype, constructor = VaryingWidthSprite;
  function VaryingWidthSprite(graphics, path, sourceX, sourceY, initialWidth, height){
    this.initialWidth = initialWidth;
    this.height = height;
    VaryingWidthSprite.superclass.apply(this, arguments);
    this.width = this.initialWidth;
  }
  prototype.setWidth = function(width){
    return this.width = width;
  };
  return VaryingWidthSprite;
}(Sprite));
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{"./rectangle":20,"./units":33,"SDL":23,"std":31}],30:[function(require,module,exports){
var std, units, ref$, STANDING, WALKING, JUMPING, FALLING, INTERACTING, LEFT, RIGHT, UP, DOWN, HORIZONTAL, key, out$ = typeof exports != 'undefined' && exports || this, slice$ = [].slice;
std = require('std');
units = require('./units');
ref$ = ['S', 'W', 'J', 'F', 'I'], STANDING = ref$[0], WALKING = ref$[1], JUMPING = ref$[2], FALLING = ref$[3], INTERACTING = ref$[4];
ref$ = ['L', 'R'], LEFT = ref$[0], RIGHT = ref$[1];
ref$ = ['U', 'D', 'H'], UP = ref$[0], DOWN = ref$[1], HORIZONTAL = ref$[2];
out$.key = key = function(){
  var args;
  args = slice$.call(arguments);
  return args.join('-');
};
ref$ = out$;
ref$.STANDING = STANDING;
ref$.WALKING = WALKING;
ref$.JUMPING = JUMPING;
ref$.FALLING = FALLING;
ref$.INTERACTING = INTERACTING;
ref$.LEFT = LEFT;
ref$.RIGHT = RIGHT;
ref$.UP = UP;
ref$.DOWN = DOWN;
ref$.HORIZONTAL = HORIZONTAL;
},{"./units":33,"std":31}],31:[function(require,module,exports){
var ref$, id, map, filter, any, div, log, info, objMap, flip, delay, round, floor, abs, max, min, sin, out$ = typeof exports != 'undefined' && exports || this;
ref$ = require('prelude-ls'), id = ref$.id, map = ref$.map, filter = ref$.filter, any = ref$.any, div = ref$.div;
out$.log = log = function(){
  console.log.apply(console, arguments);
  return arguments[0];
};
out$.info = info = function(){
  console.info.apply(console, arguments);
  return arguments[0];
};
out$.objMap = objMap = curry$(function(λ, o){
  var k, v, results$ = [];
  for (k in o) {
    v = o[k];
    results$.push(λ(k, v));
  }
  return results$;
});
out$.flip = flip = function(λ){
  return curry$(function(a, b){
    return λ(b, a);
  });
};
out$.delay = delay = flip(setTimeout);
out$.round = round = Math.round;
out$.floor = floor = Math.floor;
out$.abs = abs = Math.abs;
out$.max = max = Math.max;
out$.min = min = Math.min;
out$.sin = sin = Math.sin;
ref$ = out$;
ref$.id = id;
ref$.any = any;
ref$.map = map;
ref$.filter = filter;
ref$.div = div;
ref$['enum'] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20];
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{"prelude-ls":7}],32:[function(require,module,exports){
var std, units, Timer, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
out$.Timer = Timer = (function(){
  Timer.displayName = 'Timer';
  var allTimers, prototype = Timer.prototype, constructor = Timer;
  allTimers = [];
  function Timer(expirationTime){
    this.expirationTime = expirationTime;
    this.currentTime = this.expirationTime;
    allTimers.push(this);
  }
  prototype.update = function(elapsedTime){
    return this.currentTime += elapsedTime;
  };
  prototype.reset = function(){
    return this.currentTime = 0;
  };
  prototype.isActive = function(){
    return this.currentTime < this.expirationTime;
  };
  prototype.isExpired = function(){
    return !this.isActive();
  };
  Timer.updateAll = function(elapsedTime){
    return allTimers.map(function(it){
      return it.update(elapsedTime);
    });
  };
  return Timer;
}());
},{"./units":33,"std":31}],33:[function(require,module,exports){
var std, config, kPi, kGameUnitsPerTile, kPixelScaleFactor, Game, Pixel, Tile, Degrees, FPS, MS, Velocity, Acceleration, HP, gameToPx, gameToTile, tileToGame, tileToPx, degToRad, pxToGame, kOneTile, kHalfTile, kTilePx, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
config = require('./config');
kPi = Math.PI;
kGameUnitsPerTile = 32;
kPixelScaleFactor = kGameUnitsPerTile / config.kGraphicsQuality;
out$.Game = Game = std.id;
out$.Pixel = Pixel = std.floor;
out$.Tile = Tile = function(){
  return std.abs(std.floor.apply(this, arguments));
};
out$.Degrees = Degrees = std.id;
out$.FPS = FPS = std.id;
out$.MS = MS = std.id;
out$.Velocity = Velocity = std.id;
out$.Acceleration = Acceleration = std.id;
out$.HP = HP = std.floor;
out$.gameToPx = gameToPx = function(){
  return Pixel((function(it){
    return it / kPixelScaleFactor;
  }).apply(this, arguments));
};
out$.gameToTile = gameToTile = function(){
  return Tile((function(it){
    return it / kGameUnitsPerTile;
  }).apply(this, arguments));
};
out$.tileToGame = tileToGame = (function(it){
  return it * kGameUnitsPerTile;
});
out$.tileToPx = tileToPx = function(){
  return gameToPx(tileToGame.apply(this, arguments));
};
out$.degToRad = degToRad = (function(it){
  return it * kPi / 180;
});
out$.pxToGame = pxToGame = (function(it){
  return it * kPixelScaleFactor;
});
out$.kOneTile = kOneTile = tileToGame(1);
out$.kHalfTile = kHalfTile = tileToGame(0.5);
out$.kTilePx = kTilePx = tileToPx(1);
},{"./config":10,"std":31}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy90aW1kYXdzb24vRG9jdW1lbnRzL3JlY29uc3RydWN0aW5nLWNhdmUtc3Rvcnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi4vc3JjL2luZGV4LmxzIiwiL1VzZXJzL3RpbWRhd3Nvbi9Eb2N1bWVudHMvcmVjb25zdHJ1Y3RpbmctY2F2ZS1zdG9yeS9ub2RlX21vZHVsZXMvcHJlbHVkZS1scy9saWIvRnVuYy5qcyIsIi9Vc2Vycy90aW1kYXdzb24vRG9jdW1lbnRzL3JlY29uc3RydWN0aW5nLWNhdmUtc3Rvcnkvbm9kZV9tb2R1bGVzL3ByZWx1ZGUtbHMvbGliL0xpc3QuanMiLCIvVXNlcnMvdGltZGF3c29uL0RvY3VtZW50cy9yZWNvbnN0cnVjdGluZy1jYXZlLXN0b3J5L25vZGVfbW9kdWxlcy9wcmVsdWRlLWxzL2xpYi9OdW0uanMiLCIvVXNlcnMvdGltZGF3c29uL0RvY3VtZW50cy9yZWNvbnN0cnVjdGluZy1jYXZlLXN0b3J5L25vZGVfbW9kdWxlcy9wcmVsdWRlLWxzL2xpYi9PYmouanMiLCIvVXNlcnMvdGltZGF3c29uL0RvY3VtZW50cy9yZWNvbnN0cnVjdGluZy1jYXZlLXN0b3J5L25vZGVfbW9kdWxlcy9wcmVsdWRlLWxzL2xpYi9TdHIuanMiLCIvVXNlcnMvdGltZGF3c29uL0RvY3VtZW50cy9yZWNvbnN0cnVjdGluZy1jYXZlLXN0b3J5L25vZGVfbW9kdWxlcy9wcmVsdWRlLWxzL2xpYi9pbmRleC5qcyIsIi9Vc2Vycy90aW1kYXdzb24vRG9jdW1lbnRzL3JlY29uc3RydWN0aW5nLWNhdmUtc3Rvcnkvc3JjL2FybXMubHMiLCIvVXNlcnMvdGltZGF3c29uL0RvY3VtZW50cy9yZWNvbnN0cnVjdGluZy1jYXZlLXN0b3J5L3NyYy9iYWNrZHJvcC5scyIsIi9Vc2Vycy90aW1kYXdzb24vRG9jdW1lbnRzL3JlY29uc3RydWN0aW5nLWNhdmUtc3Rvcnkvc3JjL2NvbmZpZy5scyIsIi9Vc2Vycy90aW1kYXdzb24vRG9jdW1lbnRzL3JlY29uc3RydWN0aW5nLWNhdmUtc3Rvcnkvc3JjL2RhbWFnZS10ZXh0LmxzIiwiL1VzZXJzL3RpbWRhd3Nvbi9Eb2N1bWVudHMvcmVjb25zdHJ1Y3RpbmctY2F2ZS1zdG9yeS9zcmMvZmlyc3QtY2F2ZS1iYXQubHMiLCIvVXNlcnMvdGltZGF3c29uL0RvY3VtZW50cy9yZWNvbnN0cnVjdGluZy1jYXZlLXN0b3J5L3NyYy9nYW1lLmxzIiwiL1VzZXJzL3RpbWRhd3Nvbi9Eb2N1bWVudHMvcmVjb25zdHJ1Y3RpbmctY2F2ZS1zdG9yeS9zcmMvZ3JhcGhpY3MubHMiLCIvVXNlcnMvdGltZGF3c29uL0RvY3VtZW50cy9yZWNvbnN0cnVjdGluZy1jYXZlLXN0b3J5L3NyYy9oZWFsdGgubHMiLCIvVXNlcnMvdGltZGF3c29uL0RvY3VtZW50cy9yZWNvbnN0cnVjdGluZy1jYXZlLXN0b3J5L3NyYy9pbnB1dC5scyIsIi9Vc2Vycy90aW1kYXdzb24vRG9jdW1lbnRzL3JlY29uc3RydWN0aW5nLWNhdmUtc3Rvcnkvc3JjL21hcC5scyIsIi9Vc2Vycy90aW1kYXdzb24vRG9jdW1lbnRzL3JlY29uc3RydWN0aW5nLWNhdmUtc3Rvcnkvc3JjL3BsYXllci5scyIsIi9Vc2Vycy90aW1kYXdzb24vRG9jdW1lbnRzL3JlY29uc3RydWN0aW5nLWNhdmUtc3Rvcnkvc3JjL3JlYWRvdXQubHMiLCIvVXNlcnMvdGltZGF3c29uL0RvY3VtZW50cy9yZWNvbnN0cnVjdGluZy1jYXZlLXN0b3J5L3NyYy9yZWN0YW5nbGUubHMiLCIvVXNlcnMvdGltZGF3c29uL0RvY3VtZW50cy9yZWNvbnN0cnVjdGluZy1jYXZlLXN0b3J5L3NyYy9zZGwvZGVsYXkubHMiLCIvVXNlcnMvdGltZGF3c29uL0RvY3VtZW50cy9yZWNvbnN0cnVjdGluZy1jYXZlLXN0b3J5L3NyYy9zZGwvZXZlbnQtcXVldWUubHMiLCIvVXNlcnMvdGltZGF3c29uL0RvY3VtZW50cy9yZWNvbnN0cnVjdGluZy1jYXZlLXN0b3J5L3NyYy9zZGwvaW5kZXgubHMiLCIvVXNlcnMvdGltZGF3c29uL0RvY3VtZW50cy9yZWNvbnN0cnVjdGluZy1jYXZlLXN0b3J5L3NyYy9zZGwva2V5Ym9hcmQubHMiLCIvVXNlcnMvdGltZGF3c29uL0RvY3VtZW50cy9yZWNvbnN0cnVjdGluZy1jYXZlLXN0b3J5L3NyYy9zZGwvcmVjdC5scyIsIi9Vc2Vycy90aW1kYXdzb24vRG9jdW1lbnRzL3JlY29uc3RydWN0aW5nLWNhdmUtc3Rvcnkvc3JjL3NkbC9zY3JlZW4ubHMiLCIvVXNlcnMvdGltZGF3c29uL0RvY3VtZW50cy9yZWNvbnN0cnVjdGluZy1jYXZlLXN0b3J5L3NyYy9zZGwvc3VyZmFjZS5scyIsIi9Vc2Vycy90aW1kYXdzb24vRG9jdW1lbnRzL3JlY29uc3RydWN0aW5nLWNhdmUtc3Rvcnkvc3JjL3NkbC90aW1lci5scyIsIi9Vc2Vycy90aW1kYXdzb24vRG9jdW1lbnRzL3JlY29uc3RydWN0aW5nLWNhdmUtc3Rvcnkvc3JjL3Nwcml0ZS5scyIsIi9Vc2Vycy90aW1kYXdzb24vRG9jdW1lbnRzL3JlY29uc3RydWN0aW5nLWNhdmUtc3Rvcnkvc3JjL3Nwcml0ZXN0YXRlLmxzIiwiL1VzZXJzL3RpbWRhd3Nvbi9Eb2N1bWVudHMvcmVjb25zdHJ1Y3RpbmctY2F2ZS1zdG9yeS9zcmMvc3RkL2luZGV4LmxzIiwiL1VzZXJzL3RpbWRhd3Nvbi9Eb2N1bWVudHMvcmVjb25zdHJ1Y3RpbmctY2F2ZS1zdG9yeS9zcmMvdGltZXIubHMiLCIvVXNlcnMvdGltZGF3c29uL0RvY3VtZW50cy9yZWNvbnN0cnVjdGluZy1jYXZlLXN0b3J5L3NyYy91bml0cy5scyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwidmFyIHJlYWRvdXQsIEdhbWU7XG5yZWFkb3V0ID0gcmVxdWlyZSgnLi9yZWFkb3V0Jyk7XG5HYW1lID0gcmVxdWlyZSgnLi9nYW1lJyk7XG5yZWFkb3V0Lmluc3RhbGwoKTtcbkdhbWUuc3RhcnQoKTsiLCIvLyBHZW5lcmF0ZWQgYnkgTGl2ZVNjcmlwdCAxLjIuMFxudmFyIGFwcGx5LCBjdXJyeSwgZmxpcCwgZml4LCBvdmVyO1xuYXBwbHkgPSBjdXJyeSQoZnVuY3Rpb24oZiwgbGlzdCl7XG4gIHJldHVybiBmLmFwcGx5KG51bGwsIGxpc3QpO1xufSk7XG5jdXJyeSA9IGZ1bmN0aW9uKGYpe1xuICByZXR1cm4gY3VycnkkKGYpO1xufTtcbmZsaXAgPSBjdXJyeSQoZnVuY3Rpb24oZiwgeCwgeSl7XG4gIHJldHVybiBmKHksIHgpO1xufSk7XG5maXggPSBmdW5jdGlvbihmKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKGcpe1xuICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGYoZyhnKSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9KGZ1bmN0aW9uKGcpe1xuICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGYoZyhnKSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9KTtcbn07XG5vdmVyID0gY3VycnkkKGZ1bmN0aW9uKGYsIGcsIHgsIHkpe1xuICByZXR1cm4gZihnKHgpLCBnKHkpKTtcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGN1cnJ5OiBjdXJyeSxcbiAgZmxpcDogZmxpcCxcbiAgZml4OiBmaXgsXG4gIGFwcGx5OiBhcHBseSxcbiAgb3Zlcjogb3ZlclxufTtcbmZ1bmN0aW9uIGN1cnJ5JChmLCBib3VuZCl7XG4gIHZhciBjb250ZXh0LFxuICBfY3VycnkgPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgcmV0dXJuIGYubGVuZ3RoID4gMSA/IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgcGFyYW1zID0gYXJncyA/IGFyZ3MuY29uY2F0KCkgOiBbXTtcbiAgICAgIGNvbnRleHQgPSBib3VuZCA/IGNvbnRleHQgfHwgdGhpcyA6IHRoaXM7XG4gICAgICByZXR1cm4gcGFyYW1zLnB1c2guYXBwbHkocGFyYW1zLCBhcmd1bWVudHMpIDxcbiAgICAgICAgICBmLmxlbmd0aCAmJiBhcmd1bWVudHMubGVuZ3RoID9cbiAgICAgICAgX2N1cnJ5LmNhbGwoY29udGV4dCwgcGFyYW1zKSA6IGYuYXBwbHkoY29udGV4dCwgcGFyYW1zKTtcbiAgICB9IDogZjtcbiAgfTtcbiAgcmV0dXJuIF9jdXJyeSgpO1xufSIsIi8vIEdlbmVyYXRlZCBieSBMaXZlU2NyaXB0IDEuMi4wXG52YXIgZWFjaCwgbWFwLCBjb21wYWN0LCBmaWx0ZXIsIHJlamVjdCwgcGFydGl0aW9uLCBmaW5kLCBoZWFkLCBmaXJzdCwgdGFpbCwgbGFzdCwgaW5pdGlhbCwgZW1wdHksIHJldmVyc2UsIHVuaXF1ZSwgdW5pcXVlQnksIGZvbGQsIGZvbGRsLCBmb2xkMSwgZm9sZGwxLCBmb2xkciwgZm9sZHIxLCB1bmZvbGRyLCBjb25jYXQsIGNvbmNhdE1hcCwgZmxhdHRlbiwgZGlmZmVyZW5jZSwgaW50ZXJzZWN0aW9uLCB1bmlvbiwgY291bnRCeSwgZ3JvdXBCeSwgYW5kTGlzdCwgb3JMaXN0LCBhbnksIGFsbCwgc29ydCwgc29ydFdpdGgsIHNvcnRCeSwgc3VtLCBwcm9kdWN0LCBtZWFuLCBhdmVyYWdlLCBtYXhpbXVtLCBtaW5pbXVtLCBtYXhpbXVtQnksIG1pbmltdW1CeSwgc2Nhbiwgc2NhbmwsIHNjYW4xLCBzY2FubDEsIHNjYW5yLCBzY2FucjEsIHNsaWNlLCB0YWtlLCBkcm9wLCBzcGxpdEF0LCB0YWtlV2hpbGUsIGRyb3BXaGlsZSwgc3BhbiwgYnJlYWtMaXN0LCB6aXAsIHppcFdpdGgsIHppcEFsbCwgemlwQWxsV2l0aCwgYXQsIGVsZW1JbmRleCwgZWxlbUluZGljZXMsIGZpbmRJbmRleCwgZmluZEluZGljZXMsIHRvU3RyaW5nJCA9IHt9LnRvU3RyaW5nLCBzbGljZSQgPSBbXS5zbGljZTtcbmVhY2ggPSBjdXJyeSQoZnVuY3Rpb24oZiwgeHMpe1xuICB2YXIgaSQsIGxlbiQsIHg7XG4gIGZvciAoaSQgPSAwLCBsZW4kID0geHMubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4ID0geHNbaSRdO1xuICAgIGYoeCk7XG4gIH1cbiAgcmV0dXJuIHhzO1xufSk7XG5tYXAgPSBjdXJyeSQoZnVuY3Rpb24oZiwgeHMpe1xuICB2YXIgaSQsIGxlbiQsIHgsIHJlc3VsdHMkID0gW107XG4gIGZvciAoaSQgPSAwLCBsZW4kID0geHMubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4ID0geHNbaSRdO1xuICAgIHJlc3VsdHMkLnB1c2goZih4KSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHMkO1xufSk7XG5jb21wYWN0ID0gZnVuY3Rpb24oeHMpe1xuICB2YXIgaSQsIGxlbiQsIHgsIHJlc3VsdHMkID0gW107XG4gIGZvciAoaSQgPSAwLCBsZW4kID0geHMubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4ID0geHNbaSRdO1xuICAgIGlmICh4KSB7XG4gICAgICByZXN1bHRzJC5wdXNoKHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0cyQ7XG59O1xuZmlsdGVyID0gY3VycnkkKGZ1bmN0aW9uKGYsIHhzKXtcbiAgdmFyIGkkLCBsZW4kLCB4LCByZXN1bHRzJCA9IFtdO1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IHhzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeCA9IHhzW2kkXTtcbiAgICBpZiAoZih4KSkge1xuICAgICAgcmVzdWx0cyQucHVzaCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHMkO1xufSk7XG5yZWplY3QgPSBjdXJyeSQoZnVuY3Rpb24oZiwgeHMpe1xuICB2YXIgaSQsIGxlbiQsIHgsIHJlc3VsdHMkID0gW107XG4gIGZvciAoaSQgPSAwLCBsZW4kID0geHMubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4ID0geHNbaSRdO1xuICAgIGlmICghZih4KSkge1xuICAgICAgcmVzdWx0cyQucHVzaCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHMkO1xufSk7XG5wYXJ0aXRpb24gPSBjdXJyeSQoZnVuY3Rpb24oZiwgeHMpe1xuICB2YXIgcGFzc2VkLCBmYWlsZWQsIGkkLCBsZW4kLCB4O1xuICBwYXNzZWQgPSBbXTtcbiAgZmFpbGVkID0gW107XG4gIGZvciAoaSQgPSAwLCBsZW4kID0geHMubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4ID0geHNbaSRdO1xuICAgIChmKHgpID8gcGFzc2VkIDogZmFpbGVkKS5wdXNoKHgpO1xuICB9XG4gIHJldHVybiBbcGFzc2VkLCBmYWlsZWRdO1xufSk7XG5maW5kID0gY3VycnkkKGZ1bmN0aW9uKGYsIHhzKXtcbiAgdmFyIGkkLCBsZW4kLCB4O1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IHhzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeCA9IHhzW2kkXTtcbiAgICBpZiAoZih4KSkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9XG59KTtcbmhlYWQgPSBmaXJzdCA9IGZ1bmN0aW9uKHhzKXtcbiAgcmV0dXJuIHhzWzBdO1xufTtcbnRhaWwgPSBmdW5jdGlvbih4cyl7XG4gIGlmICgheHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiB4cy5zbGljZSgxKTtcbn07XG5sYXN0ID0gZnVuY3Rpb24oeHMpe1xuICByZXR1cm4geHNbeHMubGVuZ3RoIC0gMV07XG59O1xuaW5pdGlhbCA9IGZ1bmN0aW9uKHhzKXtcbiAgaWYgKCF4cy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIHhzLnNsaWNlKDAsIC0xKTtcbn07XG5lbXB0eSA9IGZ1bmN0aW9uKHhzKXtcbiAgcmV0dXJuICF4cy5sZW5ndGg7XG59O1xucmV2ZXJzZSA9IGZ1bmN0aW9uKHhzKXtcbiAgcmV0dXJuIHhzLmNvbmNhdCgpLnJldmVyc2UoKTtcbn07XG51bmlxdWUgPSBmdW5jdGlvbih4cyl7XG4gIHZhciByZXN1bHQsIGkkLCBsZW4kLCB4O1xuICByZXN1bHQgPSBbXTtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSB4cy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHggPSB4c1tpJF07XG4gICAgaWYgKCFpbiQoeCwgcmVzdWx0KSkge1xuICAgICAgcmVzdWx0LnB1c2goeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xudW5pcXVlQnkgPSBjdXJyeSQoZnVuY3Rpb24oZiwgeHMpe1xuICB2YXIgc2VlbiwgaSQsIGxlbiQsIHgsIHZhbCwgcmVzdWx0cyQgPSBbXTtcbiAgc2VlbiA9IFtdO1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IHhzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeCA9IHhzW2kkXTtcbiAgICB2YWwgPSBmKHgpO1xuICAgIGlmIChpbiQodmFsLCBzZWVuKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHNlZW4ucHVzaCh2YWwpO1xuICAgIHJlc3VsdHMkLnB1c2goeCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHMkO1xufSk7XG5mb2xkID0gZm9sZGwgPSBjdXJyeSQoZnVuY3Rpb24oZiwgbWVtbywgeHMpe1xuICB2YXIgaSQsIGxlbiQsIHg7XG4gIGZvciAoaSQgPSAwLCBsZW4kID0geHMubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4ID0geHNbaSRdO1xuICAgIG1lbW8gPSBmKG1lbW8sIHgpO1xuICB9XG4gIHJldHVybiBtZW1vO1xufSk7XG5mb2xkMSA9IGZvbGRsMSA9IGN1cnJ5JChmdW5jdGlvbihmLCB4cyl7XG4gIHJldHVybiBmb2xkKGYsIHhzWzBdLCB4cy5zbGljZSgxKSk7XG59KTtcbmZvbGRyID0gY3VycnkkKGZ1bmN0aW9uKGYsIG1lbW8sIHhzKXtcbiAgdmFyIGkkLCB4O1xuICBmb3IgKGkkID0geHMubGVuZ3RoIC0gMTsgaSQgPj0gMDsgLS1pJCkge1xuICAgIHggPSB4c1tpJF07XG4gICAgbWVtbyA9IGYoeCwgbWVtbyk7XG4gIH1cbiAgcmV0dXJuIG1lbW87XG59KTtcbmZvbGRyMSA9IGN1cnJ5JChmdW5jdGlvbihmLCB4cyl7XG4gIHJldHVybiBmb2xkcihmLCB4c1t4cy5sZW5ndGggLSAxXSwgeHMuc2xpY2UoMCwgLTEpKTtcbn0pO1xudW5mb2xkciA9IGN1cnJ5JChmdW5jdGlvbihmLCBiKXtcbiAgdmFyIHJlc3VsdCwgeCwgdGhhdDtcbiAgcmVzdWx0ID0gW107XG4gIHggPSBiO1xuICB3aGlsZSAoKHRoYXQgPSBmKHgpKSAhPSBudWxsKSB7XG4gICAgcmVzdWx0LnB1c2godGhhdFswXSk7XG4gICAgeCA9IHRoYXRbMV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuY29uY2F0ID0gZnVuY3Rpb24oeHNzKXtcbiAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgeHNzKTtcbn07XG5jb25jYXRNYXAgPSBjdXJyeSQoZnVuY3Rpb24oZiwgeHMpe1xuICB2YXIgeDtcbiAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgKGZ1bmN0aW9uKCl7XG4gICAgdmFyIGkkLCByZWYkLCBsZW4kLCByZXN1bHRzJCA9IFtdO1xuICAgIGZvciAoaSQgPSAwLCBsZW4kID0gKHJlZiQgPSB4cykubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICAgIHggPSByZWYkW2kkXTtcbiAgICAgIHJlc3VsdHMkLnB1c2goZih4KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzJDtcbiAgfSgpKSk7XG59KTtcbmZsYXR0ZW4gPSBmdW5jdGlvbih4cyl7XG4gIHZhciB4O1xuICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCAoZnVuY3Rpb24oKXtcbiAgICB2YXIgaSQsIHJlZiQsIGxlbiQsIHJlc3VsdHMkID0gW107XG4gICAgZm9yIChpJCA9IDAsIGxlbiQgPSAocmVmJCA9IHhzKS5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgICAgeCA9IHJlZiRbaSRdO1xuICAgICAgaWYgKHRvU3RyaW5nJC5jYWxsKHgpLnNsaWNlKDgsIC0xKSA9PT0gJ0FycmF5Jykge1xuICAgICAgICByZXN1bHRzJC5wdXNoKGZsYXR0ZW4oeCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0cyQucHVzaCh4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHMkO1xuICB9KCkpKTtcbn07XG5kaWZmZXJlbmNlID0gZnVuY3Rpb24oeHMpe1xuICB2YXIgeXNzLCByZXN1bHRzLCBpJCwgbGVuJCwgeCwgaiQsIGxlbjEkLCB5cztcbiAgeXNzID0gc2xpY2UkLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgcmVzdWx0cyA9IFtdO1xuICBvdXRlcjogZm9yIChpJCA9IDAsIGxlbiQgPSB4cy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHggPSB4c1tpJF07XG4gICAgZm9yIChqJCA9IDAsIGxlbjEkID0geXNzLmxlbmd0aDsgaiQgPCBsZW4xJDsgKytqJCkge1xuICAgICAgeXMgPSB5c3NbaiRdO1xuICAgICAgaWYgKGluJCh4LCB5cykpIHtcbiAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdHMucHVzaCh4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn07XG5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbih4cyl7XG4gIHZhciB5c3MsIHJlc3VsdHMsIGkkLCBsZW4kLCB4LCBqJCwgbGVuMSQsIHlzO1xuICB5c3MgPSBzbGljZSQuY2FsbChhcmd1bWVudHMsIDEpO1xuICByZXN1bHRzID0gW107XG4gIG91dGVyOiBmb3IgKGkkID0gMCwgbGVuJCA9IHhzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeCA9IHhzW2kkXTtcbiAgICBmb3IgKGokID0gMCwgbGVuMSQgPSB5c3MubGVuZ3RoOyBqJCA8IGxlbjEkOyArK2okKSB7XG4gICAgICB5cyA9IHlzc1tqJF07XG4gICAgICBpZiAoIWluJCh4LCB5cykpIHtcbiAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdHMucHVzaCh4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn07XG51bmlvbiA9IGZ1bmN0aW9uKCl7XG4gIHZhciB4c3MsIHJlc3VsdHMsIGkkLCBsZW4kLCB4cywgaiQsIGxlbjEkLCB4O1xuICB4c3MgPSBzbGljZSQuY2FsbChhcmd1bWVudHMpO1xuICByZXN1bHRzID0gW107XG4gIGZvciAoaSQgPSAwLCBsZW4kID0geHNzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeHMgPSB4c3NbaSRdO1xuICAgIGZvciAoaiQgPSAwLCBsZW4xJCA9IHhzLmxlbmd0aDsgaiQgPCBsZW4xJDsgKytqJCkge1xuICAgICAgeCA9IHhzW2okXTtcbiAgICAgIGlmICghaW4kKHgsIHJlc3VsdHMpKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaCh4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuY291bnRCeSA9IGN1cnJ5JChmdW5jdGlvbihmLCB4cyl7XG4gIHZhciByZXN1bHRzLCBpJCwgbGVuJCwgeCwga2V5O1xuICByZXN1bHRzID0ge307XG4gIGZvciAoaSQgPSAwLCBsZW4kID0geHMubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4ID0geHNbaSRdO1xuICAgIGtleSA9IGYoeCk7XG4gICAgaWYgKGtleSBpbiByZXN1bHRzKSB7XG4gICAgICByZXN1bHRzW2tleV0gKz0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0c1trZXldID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59KTtcbmdyb3VwQnkgPSBjdXJyeSQoZnVuY3Rpb24oZiwgeHMpe1xuICB2YXIgcmVzdWx0cywgaSQsIGxlbiQsIHgsIGtleTtcbiAgcmVzdWx0cyA9IHt9O1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IHhzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeCA9IHhzW2kkXTtcbiAgICBrZXkgPSBmKHgpO1xuICAgIGlmIChrZXkgaW4gcmVzdWx0cykge1xuICAgICAgcmVzdWx0c1trZXldLnB1c2goeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdHNba2V5XSA9IFt4XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59KTtcbmFuZExpc3QgPSBmdW5jdGlvbih4cyl7XG4gIHZhciBpJCwgbGVuJCwgeDtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSB4cy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHggPSB4c1tpJF07XG4gICAgaWYgKCF4KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbm9yTGlzdCA9IGZ1bmN0aW9uKHhzKXtcbiAgdmFyIGkkLCBsZW4kLCB4O1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IHhzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeCA9IHhzW2kkXTtcbiAgICBpZiAoeCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5hbnkgPSBjdXJyeSQoZnVuY3Rpb24oZiwgeHMpe1xuICB2YXIgaSQsIGxlbiQsIHg7XG4gIGZvciAoaSQgPSAwLCBsZW4kID0geHMubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4ID0geHNbaSRdO1xuICAgIGlmIChmKHgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufSk7XG5hbGwgPSBjdXJyeSQoZnVuY3Rpb24oZiwgeHMpe1xuICB2YXIgaSQsIGxlbiQsIHg7XG4gIGZvciAoaSQgPSAwLCBsZW4kID0geHMubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4ID0geHNbaSRdO1xuICAgIGlmICghZih4KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn0pO1xuc29ydCA9IGZ1bmN0aW9uKHhzKXtcbiAgcmV0dXJuIHhzLmNvbmNhdCgpLnNvcnQoZnVuY3Rpb24oeCwgeSl7XG4gICAgaWYgKHggPiB5KSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKHggPCB5KSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSk7XG59O1xuc29ydFdpdGggPSBjdXJyeSQoZnVuY3Rpb24oZiwgeHMpe1xuICByZXR1cm4geHMuY29uY2F0KCkuc29ydChmKTtcbn0pO1xuc29ydEJ5ID0gY3VycnkkKGZ1bmN0aW9uKGYsIHhzKXtcbiAgcmV0dXJuIHhzLmNvbmNhdCgpLnNvcnQoZnVuY3Rpb24oeCwgeSl7XG4gICAgaWYgKGYoeCkgPiBmKHkpKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGYoeCkgPCBmKHkpKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSk7XG59KTtcbnN1bSA9IGZ1bmN0aW9uKHhzKXtcbiAgdmFyIHJlc3VsdCwgaSQsIGxlbiQsIHg7XG4gIHJlc3VsdCA9IDA7XG4gIGZvciAoaSQgPSAwLCBsZW4kID0geHMubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4ID0geHNbaSRdO1xuICAgIHJlc3VsdCArPSB4O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xucHJvZHVjdCA9IGZ1bmN0aW9uKHhzKXtcbiAgdmFyIHJlc3VsdCwgaSQsIGxlbiQsIHg7XG4gIHJlc3VsdCA9IDE7XG4gIGZvciAoaSQgPSAwLCBsZW4kID0geHMubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4ID0geHNbaSRdO1xuICAgIHJlc3VsdCAqPSB4O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xubWVhbiA9IGF2ZXJhZ2UgPSBmdW5jdGlvbih4cyl7XG4gIHZhciBzdW0sIGkkLCBsZW4kLCB4O1xuICBzdW0gPSAwO1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IHhzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeCA9IHhzW2kkXTtcbiAgICBzdW0gKz0geDtcbiAgfVxuICByZXR1cm4gc3VtIC8geHMubGVuZ3RoO1xufTtcbm1heGltdW0gPSBmdW5jdGlvbih4cyl7XG4gIHZhciBtYXgsIGkkLCByZWYkLCBsZW4kLCB4O1xuICBtYXggPSB4c1swXTtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSAocmVmJCA9IHhzLnNsaWNlKDEpKS5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHggPSByZWYkW2kkXTtcbiAgICBpZiAoeCA+IG1heCkge1xuICAgICAgbWF4ID0geDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1heDtcbn07XG5taW5pbXVtID0gZnVuY3Rpb24oeHMpe1xuICB2YXIgbWluLCBpJCwgcmVmJCwgbGVuJCwgeDtcbiAgbWluID0geHNbMF07XG4gIGZvciAoaSQgPSAwLCBsZW4kID0gKHJlZiQgPSB4cy5zbGljZSgxKSkubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4ID0gcmVmJFtpJF07XG4gICAgaWYgKHggPCBtaW4pIHtcbiAgICAgIG1pbiA9IHg7XG4gICAgfVxuICB9XG4gIHJldHVybiBtaW47XG59O1xubWF4aW11bUJ5ID0gY3VycnkkKGZ1bmN0aW9uKGYsIHhzKXtcbiAgdmFyIG1heCwgaSQsIHJlZiQsIGxlbiQsIHg7XG4gIG1heCA9IHhzWzBdO1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IChyZWYkID0geHMuc2xpY2UoMSkpLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeCA9IHJlZiRbaSRdO1xuICAgIGlmIChmKHgpID4gZihtYXgpKSB7XG4gICAgICBtYXggPSB4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWF4O1xufSk7XG5taW5pbXVtQnkgPSBjdXJyeSQoZnVuY3Rpb24oZiwgeHMpe1xuICB2YXIgbWluLCBpJCwgcmVmJCwgbGVuJCwgeDtcbiAgbWluID0geHNbMF07XG4gIGZvciAoaSQgPSAwLCBsZW4kID0gKHJlZiQgPSB4cy5zbGljZSgxKSkubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4ID0gcmVmJFtpJF07XG4gICAgaWYgKGYoeCkgPCBmKG1pbikpIHtcbiAgICAgIG1pbiA9IHg7XG4gICAgfVxuICB9XG4gIHJldHVybiBtaW47XG59KTtcbnNjYW4gPSBzY2FubCA9IGN1cnJ5JChmdW5jdGlvbihmLCBtZW1vLCB4cyl7XG4gIHZhciBsYXN0LCB4O1xuICBsYXN0ID0gbWVtbztcbiAgcmV0dXJuIFttZW1vXS5jb25jYXQoKGZ1bmN0aW9uKCl7XG4gICAgdmFyIGkkLCByZWYkLCBsZW4kLCByZXN1bHRzJCA9IFtdO1xuICAgIGZvciAoaSQgPSAwLCBsZW4kID0gKHJlZiQgPSB4cykubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICAgIHggPSByZWYkW2kkXTtcbiAgICAgIHJlc3VsdHMkLnB1c2gobGFzdCA9IGYobGFzdCwgeCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cyQ7XG4gIH0oKSkpO1xufSk7XG5zY2FuMSA9IHNjYW5sMSA9IGN1cnJ5JChmdW5jdGlvbihmLCB4cyl7XG4gIGlmICgheHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBzY2FuKGYsIHhzWzBdLCB4cy5zbGljZSgxKSk7XG59KTtcbnNjYW5yID0gY3VycnkkKGZ1bmN0aW9uKGYsIG1lbW8sIHhzKXtcbiAgeHMgPSB4cy5jb25jYXQoKS5yZXZlcnNlKCk7XG4gIHJldHVybiBzY2FuKGYsIG1lbW8sIHhzKS5yZXZlcnNlKCk7XG59KTtcbnNjYW5yMSA9IGN1cnJ5JChmdW5jdGlvbihmLCB4cyl7XG4gIGlmICgheHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHhzID0geHMuY29uY2F0KCkucmV2ZXJzZSgpO1xuICByZXR1cm4gc2NhbihmLCB4c1swXSwgeHMuc2xpY2UoMSkpLnJldmVyc2UoKTtcbn0pO1xuc2xpY2UgPSBjdXJyeSQoZnVuY3Rpb24oeCwgeSwgeHMpe1xuICByZXR1cm4geHMuc2xpY2UoeCwgeSk7XG59KTtcbnRha2UgPSBjdXJyeSQoZnVuY3Rpb24obiwgeHMpe1xuICBpZiAobiA8PSAwKSB7XG4gICAgcmV0dXJuIHhzLnNsaWNlKDAsIDApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB4cy5zbGljZSgwLCBuKTtcbiAgfVxufSk7XG5kcm9wID0gY3VycnkkKGZ1bmN0aW9uKG4sIHhzKXtcbiAgaWYgKG4gPD0gMCkge1xuICAgIHJldHVybiB4cztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geHMuc2xpY2Uobik7XG4gIH1cbn0pO1xuc3BsaXRBdCA9IGN1cnJ5JChmdW5jdGlvbihuLCB4cyl7XG4gIHJldHVybiBbdGFrZShuLCB4cyksIGRyb3AobiwgeHMpXTtcbn0pO1xudGFrZVdoaWxlID0gY3VycnkkKGZ1bmN0aW9uKHAsIHhzKXtcbiAgdmFyIGxlbiwgaTtcbiAgbGVuID0geHMubGVuZ3RoO1xuICBpZiAoIWxlbikge1xuICAgIHJldHVybiB4cztcbiAgfVxuICBpID0gMDtcbiAgd2hpbGUgKGkgPCBsZW4gJiYgcCh4c1tpXSkpIHtcbiAgICBpICs9IDE7XG4gIH1cbiAgcmV0dXJuIHhzLnNsaWNlKDAsIGkpO1xufSk7XG5kcm9wV2hpbGUgPSBjdXJyeSQoZnVuY3Rpb24ocCwgeHMpe1xuICB2YXIgbGVuLCBpO1xuICBsZW4gPSB4cy5sZW5ndGg7XG4gIGlmICghbGVuKSB7XG4gICAgcmV0dXJuIHhzO1xuICB9XG4gIGkgPSAwO1xuICB3aGlsZSAoaSA8IGxlbiAmJiBwKHhzW2ldKSkge1xuICAgIGkgKz0gMTtcbiAgfVxuICByZXR1cm4geHMuc2xpY2UoaSk7XG59KTtcbnNwYW4gPSBjdXJyeSQoZnVuY3Rpb24ocCwgeHMpe1xuICByZXR1cm4gW3Rha2VXaGlsZShwLCB4cyksIGRyb3BXaGlsZShwLCB4cyldO1xufSk7XG5icmVha0xpc3QgPSBjdXJyeSQoZnVuY3Rpb24ocCwgeHMpe1xuICByZXR1cm4gc3BhbihmdW5jdGlvbigpe1xuICAgIHJldHVybiBub3QkKHAuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH0sIHhzKTtcbn0pO1xuemlwID0gY3VycnkkKGZ1bmN0aW9uKHhzLCB5cyl7XG4gIHZhciByZXN1bHQsIGxlbiwgaSQsIGxlbiQsIGksIHg7XG4gIHJlc3VsdCA9IFtdO1xuICBsZW4gPSB5cy5sZW5ndGg7XG4gIGZvciAoaSQgPSAwLCBsZW4kID0geHMubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICBpID0gaSQ7XG4gICAgeCA9IHhzW2kkXTtcbiAgICBpZiAoaSA9PT0gbGVuKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goW3gsIHlzW2ldXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuemlwV2l0aCA9IGN1cnJ5JChmdW5jdGlvbihmLCB4cywgeXMpe1xuICB2YXIgcmVzdWx0LCBsZW4sIGkkLCBsZW4kLCBpLCB4O1xuICByZXN1bHQgPSBbXTtcbiAgbGVuID0geXMubGVuZ3RoO1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IHhzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgaSA9IGkkO1xuICAgIHggPSB4c1tpJF07XG4gICAgaWYgKGkgPT09IGxlbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKGYoeCwgeXNbaV0pKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG56aXBBbGwgPSBmdW5jdGlvbigpe1xuICB2YXIgeHNzLCBtaW5MZW5ndGgsIGkkLCBsZW4kLCB4cywgcmVmJCwgaSwgbHJlc3VsdCQsIGokLCByZXN1bHRzJCA9IFtdO1xuICB4c3MgPSBzbGljZSQuY2FsbChhcmd1bWVudHMpO1xuICBtaW5MZW5ndGggPSA5ZTk7XG4gIGZvciAoaSQgPSAwLCBsZW4kID0geHNzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeHMgPSB4c3NbaSRdO1xuICAgIG1pbkxlbmd0aCA8PSAocmVmJCA9IHhzLmxlbmd0aCkgfHwgKG1pbkxlbmd0aCA9IHJlZiQpO1xuICB9XG4gIGZvciAoaSQgPSAwOyBpJCA8IG1pbkxlbmd0aDsgKytpJCkge1xuICAgIGkgPSBpJDtcbiAgICBscmVzdWx0JCA9IFtdO1xuICAgIGZvciAoaiQgPSAwLCBsZW4kID0geHNzLmxlbmd0aDsgaiQgPCBsZW4kOyArK2okKSB7XG4gICAgICB4cyA9IHhzc1tqJF07XG4gICAgICBscmVzdWx0JC5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmVzdWx0cyQucHVzaChscmVzdWx0JCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHMkO1xufTtcbnppcEFsbFdpdGggPSBmdW5jdGlvbihmKXtcbiAgdmFyIHhzcywgbWluTGVuZ3RoLCBpJCwgbGVuJCwgeHMsIHJlZiQsIGksIHJlc3VsdHMkID0gW107XG4gIHhzcyA9IHNsaWNlJC5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIG1pbkxlbmd0aCA9IDllOTtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSB4c3MubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4cyA9IHhzc1tpJF07XG4gICAgbWluTGVuZ3RoIDw9IChyZWYkID0geHMubGVuZ3RoKSB8fCAobWluTGVuZ3RoID0gcmVmJCk7XG4gIH1cbiAgZm9yIChpJCA9IDA7IGkkIDwgbWluTGVuZ3RoOyArK2kkKSB7XG4gICAgaSA9IGkkO1xuICAgIHJlc3VsdHMkLnB1c2goZi5hcHBseShudWxsLCAoZm4kKCkpKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHMkO1xuICBmdW5jdGlvbiBmbiQoKXtcbiAgICB2YXIgaSQsIHJlZiQsIGxlbiQsIHJlc3VsdHMkID0gW107XG4gICAgZm9yIChpJCA9IDAsIGxlbiQgPSAocmVmJCA9IHhzcykubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICAgIHhzID0gcmVmJFtpJF07XG4gICAgICByZXN1bHRzJC5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHMkO1xuICB9XG59O1xuYXQgPSBjdXJyeSQoZnVuY3Rpb24obiwgeHMpe1xuICBpZiAobiA8IDApIHtcbiAgICByZXR1cm4geHNbeHMubGVuZ3RoICsgbl07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHhzW25dO1xuICB9XG59KTtcbmVsZW1JbmRleCA9IGN1cnJ5JChmdW5jdGlvbihlbCwgeHMpe1xuICB2YXIgaSQsIGxlbiQsIGksIHg7XG4gIGZvciAoaSQgPSAwLCBsZW4kID0geHMubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICBpID0gaSQ7XG4gICAgeCA9IHhzW2kkXTtcbiAgICBpZiAoeCA9PT0gZWwpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxufSk7XG5lbGVtSW5kaWNlcyA9IGN1cnJ5JChmdW5jdGlvbihlbCwgeHMpe1xuICB2YXIgaSQsIGxlbiQsIGksIHgsIHJlc3VsdHMkID0gW107XG4gIGZvciAoaSQgPSAwLCBsZW4kID0geHMubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICBpID0gaSQ7XG4gICAgeCA9IHhzW2kkXTtcbiAgICBpZiAoeCA9PT0gZWwpIHtcbiAgICAgIHJlc3VsdHMkLnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRzJDtcbn0pO1xuZmluZEluZGV4ID0gY3VycnkkKGZ1bmN0aW9uKGYsIHhzKXtcbiAgdmFyIGkkLCBsZW4kLCBpLCB4O1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IHhzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgaSA9IGkkO1xuICAgIHggPSB4c1tpJF07XG4gICAgaWYgKGYoeCkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxufSk7XG5maW5kSW5kaWNlcyA9IGN1cnJ5JChmdW5jdGlvbihmLCB4cyl7XG4gIHZhciBpJCwgbGVuJCwgaSwgeCwgcmVzdWx0cyQgPSBbXTtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSB4cy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIGkgPSBpJDtcbiAgICB4ID0geHNbaSRdO1xuICAgIGlmIChmKHgpKSB7XG4gICAgICByZXN1bHRzJC5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0cyQ7XG59KTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBlYWNoOiBlYWNoLFxuICBtYXA6IG1hcCxcbiAgZmlsdGVyOiBmaWx0ZXIsXG4gIGNvbXBhY3Q6IGNvbXBhY3QsXG4gIHJlamVjdDogcmVqZWN0LFxuICBwYXJ0aXRpb246IHBhcnRpdGlvbixcbiAgZmluZDogZmluZCxcbiAgaGVhZDogaGVhZCxcbiAgZmlyc3Q6IGZpcnN0LFxuICB0YWlsOiB0YWlsLFxuICBsYXN0OiBsYXN0LFxuICBpbml0aWFsOiBpbml0aWFsLFxuICBlbXB0eTogZW1wdHksXG4gIHJldmVyc2U6IHJldmVyc2UsXG4gIGRpZmZlcmVuY2U6IGRpZmZlcmVuY2UsXG4gIGludGVyc2VjdGlvbjogaW50ZXJzZWN0aW9uLFxuICB1bmlvbjogdW5pb24sXG4gIGNvdW50Qnk6IGNvdW50QnksXG4gIGdyb3VwQnk6IGdyb3VwQnksXG4gIGZvbGQ6IGZvbGQsXG4gIGZvbGQxOiBmb2xkMSxcbiAgZm9sZGw6IGZvbGRsLFxuICBmb2xkbDE6IGZvbGRsMSxcbiAgZm9sZHI6IGZvbGRyLFxuICBmb2xkcjE6IGZvbGRyMSxcbiAgdW5mb2xkcjogdW5mb2xkcixcbiAgYW5kTGlzdDogYW5kTGlzdCxcbiAgb3JMaXN0OiBvckxpc3QsXG4gIGFueTogYW55LFxuICBhbGw6IGFsbCxcbiAgdW5pcXVlOiB1bmlxdWUsXG4gIHVuaXF1ZUJ5OiB1bmlxdWVCeSxcbiAgc29ydDogc29ydCxcbiAgc29ydFdpdGg6IHNvcnRXaXRoLFxuICBzb3J0Qnk6IHNvcnRCeSxcbiAgc3VtOiBzdW0sXG4gIHByb2R1Y3Q6IHByb2R1Y3QsXG4gIG1lYW46IG1lYW4sXG4gIGF2ZXJhZ2U6IGF2ZXJhZ2UsXG4gIGNvbmNhdDogY29uY2F0LFxuICBjb25jYXRNYXA6IGNvbmNhdE1hcCxcbiAgZmxhdHRlbjogZmxhdHRlbixcbiAgbWF4aW11bTogbWF4aW11bSxcbiAgbWluaW11bTogbWluaW11bSxcbiAgbWF4aW11bUJ5OiBtYXhpbXVtQnksXG4gIG1pbmltdW1CeTogbWluaW11bUJ5LFxuICBzY2FuOiBzY2FuLFxuICBzY2FuMTogc2NhbjEsXG4gIHNjYW5sOiBzY2FubCxcbiAgc2NhbmwxOiBzY2FubDEsXG4gIHNjYW5yOiBzY2FucixcbiAgc2NhbnIxOiBzY2FucjEsXG4gIHNsaWNlOiBzbGljZSxcbiAgdGFrZTogdGFrZSxcbiAgZHJvcDogZHJvcCxcbiAgc3BsaXRBdDogc3BsaXRBdCxcbiAgdGFrZVdoaWxlOiB0YWtlV2hpbGUsXG4gIGRyb3BXaGlsZTogZHJvcFdoaWxlLFxuICBzcGFuOiBzcGFuLFxuICBicmVha0xpc3Q6IGJyZWFrTGlzdCxcbiAgemlwOiB6aXAsXG4gIHppcFdpdGg6IHppcFdpdGgsXG4gIHppcEFsbDogemlwQWxsLFxuICB6aXBBbGxXaXRoOiB6aXBBbGxXaXRoLFxuICBhdDogYXQsXG4gIGVsZW1JbmRleDogZWxlbUluZGV4LFxuICBlbGVtSW5kaWNlczogZWxlbUluZGljZXMsXG4gIGZpbmRJbmRleDogZmluZEluZGV4LFxuICBmaW5kSW5kaWNlczogZmluZEluZGljZXNcbn07XG5mdW5jdGlvbiBjdXJyeSQoZiwgYm91bmQpe1xuICB2YXIgY29udGV4dCxcbiAgX2N1cnJ5ID0gZnVuY3Rpb24oYXJncykge1xuICAgIHJldHVybiBmLmxlbmd0aCA+IDEgPyBmdW5jdGlvbigpe1xuICAgICAgdmFyIHBhcmFtcyA9IGFyZ3MgPyBhcmdzLmNvbmNhdCgpIDogW107XG4gICAgICBjb250ZXh0ID0gYm91bmQgPyBjb250ZXh0IHx8IHRoaXMgOiB0aGlzO1xuICAgICAgcmV0dXJuIHBhcmFtcy5wdXNoLmFwcGx5KHBhcmFtcywgYXJndW1lbnRzKSA8XG4gICAgICAgICAgZi5sZW5ndGggJiYgYXJndW1lbnRzLmxlbmd0aCA/XG4gICAgICAgIF9jdXJyeS5jYWxsKGNvbnRleHQsIHBhcmFtcykgOiBmLmFwcGx5KGNvbnRleHQsIHBhcmFtcyk7XG4gICAgfSA6IGY7XG4gIH07XG4gIHJldHVybiBfY3VycnkoKTtcbn1cbmZ1bmN0aW9uIGluJCh4LCB4cyl7XG4gIHZhciBpID0gLTEsIGwgPSB4cy5sZW5ndGggPj4+IDA7XG4gIHdoaWxlICgrK2kgPCBsKSBpZiAoeCA9PT0geHNbaV0pIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBub3QkKHgpeyByZXR1cm4gIXg7IH0iLCIvLyBHZW5lcmF0ZWQgYnkgTGl2ZVNjcmlwdCAxLjIuMFxudmFyIG1heCwgbWluLCBuZWdhdGUsIGFicywgc2lnbnVtLCBxdW90LCByZW0sIGRpdiwgbW9kLCByZWNpcCwgcGksIHRhdSwgZXhwLCBzcXJ0LCBsbiwgcG93LCBzaW4sIHRhbiwgY29zLCBhc2luLCBhY29zLCBhdGFuLCBhdGFuMiwgdHJ1bmNhdGUsIHJvdW5kLCBjZWlsaW5nLCBmbG9vciwgaXNJdE5hTiwgZXZlbiwgb2RkLCBnY2QsIGxjbTtcbm1heCA9IGN1cnJ5JChmdW5jdGlvbih4JCwgeSQpe1xuICByZXR1cm4geCQgPiB5JCA/IHgkIDogeSQ7XG59KTtcbm1pbiA9IGN1cnJ5JChmdW5jdGlvbih4JCwgeSQpe1xuICByZXR1cm4geCQgPCB5JCA/IHgkIDogeSQ7XG59KTtcbm5lZ2F0ZSA9IGZ1bmN0aW9uKHgpe1xuICByZXR1cm4gLXg7XG59O1xuYWJzID0gTWF0aC5hYnM7XG5zaWdudW0gPSBmdW5jdGlvbih4KXtcbiAgaWYgKHggPCAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKHggPiAwKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5xdW90ID0gY3VycnkkKGZ1bmN0aW9uKHgsIHkpe1xuICByZXR1cm4gfn4oeCAvIHkpO1xufSk7XG5yZW0gPSBjdXJyeSQoZnVuY3Rpb24oeCQsIHkkKXtcbiAgcmV0dXJuIHgkICUgeSQ7XG59KTtcbmRpdiA9IGN1cnJ5JChmdW5jdGlvbih4LCB5KXtcbiAgcmV0dXJuIE1hdGguZmxvb3IoeCAvIHkpO1xufSk7XG5tb2QgPSBjdXJyeSQoZnVuY3Rpb24oeCQsIHkkKXtcbiAgdmFyIHJlZiQ7XG4gIHJldHVybiAoKHgkKSAlIChyZWYkID0geSQpICsgcmVmJCkgJSByZWYkO1xufSk7XG5yZWNpcCA9IChmdW5jdGlvbihpdCl7XG4gIHJldHVybiAxIC8gaXQ7XG59KTtcbnBpID0gTWF0aC5QSTtcbnRhdSA9IHBpICogMjtcbmV4cCA9IE1hdGguZXhwO1xuc3FydCA9IE1hdGguc3FydDtcbmxuID0gTWF0aC5sb2c7XG5wb3cgPSBjdXJyeSQoZnVuY3Rpb24oeCQsIHkkKXtcbiAgcmV0dXJuIE1hdGgucG93KHgkLCB5JCk7XG59KTtcbnNpbiA9IE1hdGguc2luO1xudGFuID0gTWF0aC50YW47XG5jb3MgPSBNYXRoLmNvcztcbmFzaW4gPSBNYXRoLmFzaW47XG5hY29zID0gTWF0aC5hY29zO1xuYXRhbiA9IE1hdGguYXRhbjtcbmF0YW4yID0gY3VycnkkKGZ1bmN0aW9uKHgsIHkpe1xuICByZXR1cm4gTWF0aC5hdGFuMih4LCB5KTtcbn0pO1xudHJ1bmNhdGUgPSBmdW5jdGlvbih4KXtcbiAgcmV0dXJuIH5+eDtcbn07XG5yb3VuZCA9IE1hdGgucm91bmQ7XG5jZWlsaW5nID0gTWF0aC5jZWlsO1xuZmxvb3IgPSBNYXRoLmZsb29yO1xuaXNJdE5hTiA9IGZ1bmN0aW9uKHgpe1xuICByZXR1cm4geCAhPT0geDtcbn07XG5ldmVuID0gZnVuY3Rpb24oeCl7XG4gIHJldHVybiB4ICUgMiA9PT0gMDtcbn07XG5vZGQgPSBmdW5jdGlvbih4KXtcbiAgcmV0dXJuIHggJSAyICE9PSAwO1xufTtcbmdjZCA9IGN1cnJ5JChmdW5jdGlvbih4LCB5KXtcbiAgdmFyIHo7XG4gIHggPSBNYXRoLmFicyh4KTtcbiAgeSA9IE1hdGguYWJzKHkpO1xuICB3aGlsZSAoeSAhPT0gMCkge1xuICAgIHogPSB4ICUgeTtcbiAgICB4ID0geTtcbiAgICB5ID0gejtcbiAgfVxuICByZXR1cm4geDtcbn0pO1xubGNtID0gY3VycnkkKGZ1bmN0aW9uKHgsIHkpe1xuICByZXR1cm4gTWF0aC5hYnMoTWF0aC5mbG9vcih4IC8gZ2NkKHgsIHkpICogeSkpO1xufSk7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWF4OiBtYXgsXG4gIG1pbjogbWluLFxuICBuZWdhdGU6IG5lZ2F0ZSxcbiAgYWJzOiBhYnMsXG4gIHNpZ251bTogc2lnbnVtLFxuICBxdW90OiBxdW90LFxuICByZW06IHJlbSxcbiAgZGl2OiBkaXYsXG4gIG1vZDogbW9kLFxuICByZWNpcDogcmVjaXAsXG4gIHBpOiBwaSxcbiAgdGF1OiB0YXUsXG4gIGV4cDogZXhwLFxuICBzcXJ0OiBzcXJ0LFxuICBsbjogbG4sXG4gIHBvdzogcG93LFxuICBzaW46IHNpbixcbiAgdGFuOiB0YW4sXG4gIGNvczogY29zLFxuICBhY29zOiBhY29zLFxuICBhc2luOiBhc2luLFxuICBhdGFuOiBhdGFuLFxuICBhdGFuMjogYXRhbjIsXG4gIHRydW5jYXRlOiB0cnVuY2F0ZSxcbiAgcm91bmQ6IHJvdW5kLFxuICBjZWlsaW5nOiBjZWlsaW5nLFxuICBmbG9vcjogZmxvb3IsXG4gIGlzSXROYU46IGlzSXROYU4sXG4gIGV2ZW46IGV2ZW4sXG4gIG9kZDogb2RkLFxuICBnY2Q6IGdjZCxcbiAgbGNtOiBsY21cbn07XG5mdW5jdGlvbiBjdXJyeSQoZiwgYm91bmQpe1xuICB2YXIgY29udGV4dCxcbiAgX2N1cnJ5ID0gZnVuY3Rpb24oYXJncykge1xuICAgIHJldHVybiBmLmxlbmd0aCA+IDEgPyBmdW5jdGlvbigpe1xuICAgICAgdmFyIHBhcmFtcyA9IGFyZ3MgPyBhcmdzLmNvbmNhdCgpIDogW107XG4gICAgICBjb250ZXh0ID0gYm91bmQgPyBjb250ZXh0IHx8IHRoaXMgOiB0aGlzO1xuICAgICAgcmV0dXJuIHBhcmFtcy5wdXNoLmFwcGx5KHBhcmFtcywgYXJndW1lbnRzKSA8XG4gICAgICAgICAgZi5sZW5ndGggJiYgYXJndW1lbnRzLmxlbmd0aCA/XG4gICAgICAgIF9jdXJyeS5jYWxsKGNvbnRleHQsIHBhcmFtcykgOiBmLmFwcGx5KGNvbnRleHQsIHBhcmFtcyk7XG4gICAgfSA6IGY7XG4gIH07XG4gIHJldHVybiBfY3VycnkoKTtcbn0iLCIvLyBHZW5lcmF0ZWQgYnkgTGl2ZVNjcmlwdCAxLjIuMFxudmFyIHZhbHVlcywga2V5cywgcGFpcnNUb09iaiwgb2JqVG9QYWlycywgbGlzdHNUb09iaiwgb2JqVG9MaXN0cywgZW1wdHksIGVhY2gsIG1hcCwgY29tcGFjdCwgZmlsdGVyLCByZWplY3QsIHBhcnRpdGlvbiwgZmluZDtcbnZhbHVlcyA9IGZ1bmN0aW9uKG9iamVjdCl7XG4gIHZhciBpJCwgeCwgcmVzdWx0cyQgPSBbXTtcbiAgZm9yIChpJCBpbiBvYmplY3QpIHtcbiAgICB4ID0gb2JqZWN0W2kkXTtcbiAgICByZXN1bHRzJC5wdXNoKHgpO1xuICB9XG4gIHJldHVybiByZXN1bHRzJDtcbn07XG5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KXtcbiAgdmFyIHgsIHJlc3VsdHMkID0gW107XG4gIGZvciAoeCBpbiBvYmplY3QpIHtcbiAgICByZXN1bHRzJC5wdXNoKHgpO1xuICB9XG4gIHJldHVybiByZXN1bHRzJDtcbn07XG5wYWlyc1RvT2JqID0gZnVuY3Rpb24ob2JqZWN0KXtcbiAgdmFyIGkkLCBsZW4kLCB4LCByZXN1bHRzJCA9IHt9O1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IG9iamVjdC5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHggPSBvYmplY3RbaSRdO1xuICAgIHJlc3VsdHMkW3hbMF1dID0geFsxXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cyQ7XG59O1xub2JqVG9QYWlycyA9IGZ1bmN0aW9uKG9iamVjdCl7XG4gIHZhciBrZXksIHZhbHVlLCByZXN1bHRzJCA9IFtdO1xuICBmb3IgKGtleSBpbiBvYmplY3QpIHtcbiAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgIHJlc3VsdHMkLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cyQ7XG59O1xubGlzdHNUb09iaiA9IGN1cnJ5JChmdW5jdGlvbihrZXlzLCB2YWx1ZXMpe1xuICB2YXIgaSQsIGxlbiQsIGksIGtleSwgcmVzdWx0cyQgPSB7fTtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSBrZXlzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgaSA9IGkkO1xuICAgIGtleSA9IGtleXNbaSRdO1xuICAgIHJlc3VsdHMkW2tleV0gPSB2YWx1ZXNbaV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHMkO1xufSk7XG5vYmpUb0xpc3RzID0gZnVuY3Rpb24ob2JqZWN0KXtcbiAgdmFyIGtleXMsIHZhbHVlcywga2V5LCB2YWx1ZTtcbiAga2V5cyA9IFtdO1xuICB2YWx1ZXMgPSBbXTtcbiAgZm9yIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIFtrZXlzLCB2YWx1ZXNdO1xufTtcbmVtcHR5ID0gZnVuY3Rpb24ob2JqZWN0KXtcbiAgdmFyIHg7XG4gIGZvciAoeCBpbiBvYmplY3QpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuZWFjaCA9IGN1cnJ5JChmdW5jdGlvbihmLCBvYmplY3Qpe1xuICB2YXIgaSQsIHg7XG4gIGZvciAoaSQgaW4gb2JqZWN0KSB7XG4gICAgeCA9IG9iamVjdFtpJF07XG4gICAgZih4KTtcbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufSk7XG5tYXAgPSBjdXJyeSQoZnVuY3Rpb24oZiwgb2JqZWN0KXtcbiAgdmFyIGssIHgsIHJlc3VsdHMkID0ge307XG4gIGZvciAoayBpbiBvYmplY3QpIHtcbiAgICB4ID0gb2JqZWN0W2tdO1xuICAgIHJlc3VsdHMkW2tdID0gZih4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cyQ7XG59KTtcbmNvbXBhY3QgPSBmdW5jdGlvbihvYmplY3Qpe1xuICB2YXIgaywgeCwgcmVzdWx0cyQgPSB7fTtcbiAgZm9yIChrIGluIG9iamVjdCkge1xuICAgIHggPSBvYmplY3Rba107XG5pZiAoeCkge1xuICAgICAgcmVzdWx0cyRba10gPSB4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0cyQ7XG59O1xuZmlsdGVyID0gY3VycnkkKGZ1bmN0aW9uKGYsIG9iamVjdCl7XG4gIHZhciBrLCB4LCByZXN1bHRzJCA9IHt9O1xuICBmb3IgKGsgaW4gb2JqZWN0KSB7XG4gICAgeCA9IG9iamVjdFtrXTtcbmlmIChmKHgpKSB7XG4gICAgICByZXN1bHRzJFtrXSA9IHg7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRzJDtcbn0pO1xucmVqZWN0ID0gY3VycnkkKGZ1bmN0aW9uKGYsIG9iamVjdCl7XG4gIHZhciBrLCB4LCByZXN1bHRzJCA9IHt9O1xuICBmb3IgKGsgaW4gb2JqZWN0KSB7XG4gICAgeCA9IG9iamVjdFtrXTtcbmlmICghZih4KSkge1xuICAgICAgcmVzdWx0cyRba10gPSB4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0cyQ7XG59KTtcbnBhcnRpdGlvbiA9IGN1cnJ5JChmdW5jdGlvbihmLCBvYmplY3Qpe1xuICB2YXIgcGFzc2VkLCBmYWlsZWQsIGssIHg7XG4gIHBhc3NlZCA9IHt9O1xuICBmYWlsZWQgPSB7fTtcbiAgZm9yIChrIGluIG9iamVjdCkge1xuICAgIHggPSBvYmplY3Rba107XG4gICAgKGYoeCkgPyBwYXNzZWQgOiBmYWlsZWQpW2tdID0geDtcbiAgfVxuICByZXR1cm4gW3Bhc3NlZCwgZmFpbGVkXTtcbn0pO1xuZmluZCA9IGN1cnJ5JChmdW5jdGlvbihmLCBvYmplY3Qpe1xuICB2YXIgaSQsIHg7XG4gIGZvciAoaSQgaW4gb2JqZWN0KSB7XG4gICAgeCA9IG9iamVjdFtpJF07XG4gICAgaWYgKGYoeCkpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdmFsdWVzOiB2YWx1ZXMsXG4gIGtleXM6IGtleXMsXG4gIHBhaXJzVG9PYmo6IHBhaXJzVG9PYmosXG4gIG9ialRvUGFpcnM6IG9ialRvUGFpcnMsXG4gIGxpc3RzVG9PYmo6IGxpc3RzVG9PYmosXG4gIG9ialRvTGlzdHM6IG9ialRvTGlzdHMsXG4gIGVtcHR5OiBlbXB0eSxcbiAgZWFjaDogZWFjaCxcbiAgbWFwOiBtYXAsXG4gIGZpbHRlcjogZmlsdGVyLFxuICBjb21wYWN0OiBjb21wYWN0LFxuICByZWplY3Q6IHJlamVjdCxcbiAgcGFydGl0aW9uOiBwYXJ0aXRpb24sXG4gIGZpbmQ6IGZpbmRcbn07XG5mdW5jdGlvbiBjdXJyeSQoZiwgYm91bmQpe1xuICB2YXIgY29udGV4dCxcbiAgX2N1cnJ5ID0gZnVuY3Rpb24oYXJncykge1xuICAgIHJldHVybiBmLmxlbmd0aCA+IDEgPyBmdW5jdGlvbigpe1xuICAgICAgdmFyIHBhcmFtcyA9IGFyZ3MgPyBhcmdzLmNvbmNhdCgpIDogW107XG4gICAgICBjb250ZXh0ID0gYm91bmQgPyBjb250ZXh0IHx8IHRoaXMgOiB0aGlzO1xuICAgICAgcmV0dXJuIHBhcmFtcy5wdXNoLmFwcGx5KHBhcmFtcywgYXJndW1lbnRzKSA8XG4gICAgICAgICAgZi5sZW5ndGggJiYgYXJndW1lbnRzLmxlbmd0aCA/XG4gICAgICAgIF9jdXJyeS5jYWxsKGNvbnRleHQsIHBhcmFtcykgOiBmLmFwcGx5KGNvbnRleHQsIHBhcmFtcyk7XG4gICAgfSA6IGY7XG4gIH07XG4gIHJldHVybiBfY3VycnkoKTtcbn0iLCIvLyBHZW5lcmF0ZWQgYnkgTGl2ZVNjcmlwdCAxLjIuMFxudmFyIHNwbGl0LCBqb2luLCBsaW5lcywgdW5saW5lcywgd29yZHMsIHVud29yZHMsIGNoYXJzLCB1bmNoYXJzLCByZXZlcnNlLCByZXBlYXQsIGNhcGl0YWxpemUsIGNhbWVsaXplLCBkYXNoZXJpemU7XG5zcGxpdCA9IGN1cnJ5JChmdW5jdGlvbihzZXAsIHN0cil7XG4gIHJldHVybiBzdHIuc3BsaXQoc2VwKTtcbn0pO1xuam9pbiA9IGN1cnJ5JChmdW5jdGlvbihzZXAsIHhzKXtcbiAgcmV0dXJuIHhzLmpvaW4oc2VwKTtcbn0pO1xubGluZXMgPSBmdW5jdGlvbihzdHIpe1xuICBpZiAoIXN0ci5sZW5ndGgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIHN0ci5zcGxpdCgnXFxuJyk7XG59O1xudW5saW5lcyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0LmpvaW4oJ1xcbicpO1xufTtcbndvcmRzID0gZnVuY3Rpb24oc3RyKXtcbiAgaWYgKCFzdHIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBzdHIuc3BsaXQoL1sgXSsvKTtcbn07XG51bndvcmRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQuam9pbignICcpO1xufTtcbmNoYXJzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQuc3BsaXQoJycpO1xufTtcbnVuY2hhcnMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdC5qb2luKCcnKTtcbn07XG5yZXZlcnNlID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpO1xufTtcbnJlcGVhdCA9IGN1cnJ5JChmdW5jdGlvbihuLCBzdHIpe1xuICB2YXIgcmVzdWx0LCBpJDtcbiAgcmVzdWx0ID0gJyc7XG4gIGZvciAoaSQgPSAwOyBpJCA8IG47ICsraSQpIHtcbiAgICByZXN1bHQgKz0gc3RyO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcbmNhcGl0YWxpemUgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufTtcbmNhbWVsaXplID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQucmVwbGFjZSgvWy1fXSsoLik/L2csIGZ1bmN0aW9uKGFyZyQsIGMpe1xuICAgIHJldHVybiAoYyAhPSBudWxsID8gYyA6ICcnKS50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn07XG5kYXNoZXJpemUgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbXi1BLVpdKShbQS1aXSspL2csIGZ1bmN0aW9uKGFyZyQsIGxvd2VyLCB1cHBlcil7XG4gICAgcmV0dXJuIGxvd2VyICsgXCItXCIgKyAodXBwZXIubGVuZ3RoID4gMVxuICAgICAgPyB1cHBlclxuICAgICAgOiB1cHBlci50b0xvd2VyQ2FzZSgpKTtcbiAgfSkucmVwbGFjZSgvXihbQS1aXSspLywgZnVuY3Rpb24oYXJnJCwgdXBwZXIpe1xuICAgIGlmICh1cHBlci5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gdXBwZXIgKyBcIi1cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVwcGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICB9KTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3BsaXQ6IHNwbGl0LFxuICBqb2luOiBqb2luLFxuICBsaW5lczogbGluZXMsXG4gIHVubGluZXM6IHVubGluZXMsXG4gIHdvcmRzOiB3b3JkcyxcbiAgdW53b3JkczogdW53b3JkcyxcbiAgY2hhcnM6IGNoYXJzLFxuICB1bmNoYXJzOiB1bmNoYXJzLFxuICByZXZlcnNlOiByZXZlcnNlLFxuICByZXBlYXQ6IHJlcGVhdCxcbiAgY2FwaXRhbGl6ZTogY2FwaXRhbGl6ZSxcbiAgY2FtZWxpemU6IGNhbWVsaXplLFxuICBkYXNoZXJpemU6IGRhc2hlcml6ZVxufTtcbmZ1bmN0aW9uIGN1cnJ5JChmLCBib3VuZCl7XG4gIHZhciBjb250ZXh0LFxuICBfY3VycnkgPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgcmV0dXJuIGYubGVuZ3RoID4gMSA/IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgcGFyYW1zID0gYXJncyA/IGFyZ3MuY29uY2F0KCkgOiBbXTtcbiAgICAgIGNvbnRleHQgPSBib3VuZCA/IGNvbnRleHQgfHwgdGhpcyA6IHRoaXM7XG4gICAgICByZXR1cm4gcGFyYW1zLnB1c2guYXBwbHkocGFyYW1zLCBhcmd1bWVudHMpIDxcbiAgICAgICAgICBmLmxlbmd0aCAmJiBhcmd1bWVudHMubGVuZ3RoID9cbiAgICAgICAgX2N1cnJ5LmNhbGwoY29udGV4dCwgcGFyYW1zKSA6IGYuYXBwbHkoY29udGV4dCwgcGFyYW1zKTtcbiAgICB9IDogZjtcbiAgfTtcbiAgcmV0dXJuIF9jdXJyeSgpO1xufSIsIi8vIEdlbmVyYXRlZCBieSBMaXZlU2NyaXB0IDEuMi4wXG52YXIgRnVuYywgTGlzdCwgT2JqLCBTdHIsIE51bSwgaWQsIGlzVHlwZSwgcmVwbGljYXRlLCBwcmVsdWRlLCB0b1N0cmluZyQgPSB7fS50b1N0cmluZztcbkZ1bmMgPSByZXF1aXJlKCcuL0Z1bmMuanMnKTtcbkxpc3QgPSByZXF1aXJlKCcuL0xpc3QuanMnKTtcbk9iaiA9IHJlcXVpcmUoJy4vT2JqLmpzJyk7XG5TdHIgPSByZXF1aXJlKCcuL1N0ci5qcycpO1xuTnVtID0gcmVxdWlyZSgnLi9OdW0uanMnKTtcbmlkID0gZnVuY3Rpb24oeCl7XG4gIHJldHVybiB4O1xufTtcbmlzVHlwZSA9IGN1cnJ5JChmdW5jdGlvbih0eXBlLCB4KXtcbiAgcmV0dXJuIHRvU3RyaW5nJC5jYWxsKHgpLnNsaWNlKDgsIC0xKSA9PT0gdHlwZTtcbn0pO1xucmVwbGljYXRlID0gY3VycnkkKGZ1bmN0aW9uKG4sIHgpe1xuICB2YXIgaSQsIHJlc3VsdHMkID0gW107XG4gIGZvciAoaSQgPSAwOyBpJCA8IG47ICsraSQpIHtcbiAgICByZXN1bHRzJC5wdXNoKHgpO1xuICB9XG4gIHJldHVybiByZXN1bHRzJDtcbn0pO1xuU3RyLmVtcHR5ID0gTGlzdC5lbXB0eTtcblN0ci5zbGljZSA9IExpc3Quc2xpY2U7XG5TdHIudGFrZSA9IExpc3QudGFrZTtcblN0ci5kcm9wID0gTGlzdC5kcm9wO1xuU3RyLnNwbGl0QXQgPSBMaXN0LnNwbGl0QXQ7XG5TdHIudGFrZVdoaWxlID0gTGlzdC50YWtlV2hpbGU7XG5TdHIuZHJvcFdoaWxlID0gTGlzdC5kcm9wV2hpbGU7XG5TdHIuc3BhbiA9IExpc3Quc3BhbjtcblN0ci5icmVha1N0ciA9IExpc3QuYnJlYWtMaXN0O1xucHJlbHVkZSA9IHtcbiAgRnVuYzogRnVuYyxcbiAgTGlzdDogTGlzdCxcbiAgT2JqOiBPYmosXG4gIFN0cjogU3RyLFxuICBOdW06IE51bSxcbiAgaWQ6IGlkLFxuICBpc1R5cGU6IGlzVHlwZSxcbiAgcmVwbGljYXRlOiByZXBsaWNhdGVcbn07XG5wcmVsdWRlLmVhY2ggPSBMaXN0LmVhY2g7XG5wcmVsdWRlLm1hcCA9IExpc3QubWFwO1xucHJlbHVkZS5maWx0ZXIgPSBMaXN0LmZpbHRlcjtcbnByZWx1ZGUuY29tcGFjdCA9IExpc3QuY29tcGFjdDtcbnByZWx1ZGUucmVqZWN0ID0gTGlzdC5yZWplY3Q7XG5wcmVsdWRlLnBhcnRpdGlvbiA9IExpc3QucGFydGl0aW9uO1xucHJlbHVkZS5maW5kID0gTGlzdC5maW5kO1xucHJlbHVkZS5oZWFkID0gTGlzdC5oZWFkO1xucHJlbHVkZS5maXJzdCA9IExpc3QuZmlyc3Q7XG5wcmVsdWRlLnRhaWwgPSBMaXN0LnRhaWw7XG5wcmVsdWRlLmxhc3QgPSBMaXN0Lmxhc3Q7XG5wcmVsdWRlLmluaXRpYWwgPSBMaXN0LmluaXRpYWw7XG5wcmVsdWRlLmVtcHR5ID0gTGlzdC5lbXB0eTtcbnByZWx1ZGUucmV2ZXJzZSA9IExpc3QucmV2ZXJzZTtcbnByZWx1ZGUuZGlmZmVyZW5jZSA9IExpc3QuZGlmZmVyZW5jZTtcbnByZWx1ZGUuaW50ZXJzZWN0aW9uID0gTGlzdC5pbnRlcnNlY3Rpb247XG5wcmVsdWRlLnVuaW9uID0gTGlzdC51bmlvbjtcbnByZWx1ZGUuY291bnRCeSA9IExpc3QuY291bnRCeTtcbnByZWx1ZGUuZ3JvdXBCeSA9IExpc3QuZ3JvdXBCeTtcbnByZWx1ZGUuZm9sZCA9IExpc3QuZm9sZDtcbnByZWx1ZGUuZm9sZGwgPSBMaXN0LmZvbGRsO1xucHJlbHVkZS5mb2xkMSA9IExpc3QuZm9sZDE7XG5wcmVsdWRlLmZvbGRsMSA9IExpc3QuZm9sZGwxO1xucHJlbHVkZS5mb2xkciA9IExpc3QuZm9sZHI7XG5wcmVsdWRlLmZvbGRyMSA9IExpc3QuZm9sZHIxO1xucHJlbHVkZS51bmZvbGRyID0gTGlzdC51bmZvbGRyO1xucHJlbHVkZS5hbmRMaXN0ID0gTGlzdC5hbmRMaXN0O1xucHJlbHVkZS5vckxpc3QgPSBMaXN0Lm9yTGlzdDtcbnByZWx1ZGUuYW55ID0gTGlzdC5hbnk7XG5wcmVsdWRlLmFsbCA9IExpc3QuYWxsO1xucHJlbHVkZS51bmlxdWUgPSBMaXN0LnVuaXF1ZTtcbnByZWx1ZGUudW5pcXVlQnkgPSBMaXN0LnVuaXF1ZUJ5O1xucHJlbHVkZS5zb3J0ID0gTGlzdC5zb3J0O1xucHJlbHVkZS5zb3J0V2l0aCA9IExpc3Quc29ydFdpdGg7XG5wcmVsdWRlLnNvcnRCeSA9IExpc3Quc29ydEJ5O1xucHJlbHVkZS5zdW0gPSBMaXN0LnN1bTtcbnByZWx1ZGUucHJvZHVjdCA9IExpc3QucHJvZHVjdDtcbnByZWx1ZGUubWVhbiA9IExpc3QubWVhbjtcbnByZWx1ZGUuYXZlcmFnZSA9IExpc3QuYXZlcmFnZTtcbnByZWx1ZGUuY29uY2F0ID0gTGlzdC5jb25jYXQ7XG5wcmVsdWRlLmNvbmNhdE1hcCA9IExpc3QuY29uY2F0TWFwO1xucHJlbHVkZS5mbGF0dGVuID0gTGlzdC5mbGF0dGVuO1xucHJlbHVkZS5tYXhpbXVtID0gTGlzdC5tYXhpbXVtO1xucHJlbHVkZS5taW5pbXVtID0gTGlzdC5taW5pbXVtO1xucHJlbHVkZS5tYXhpbXVtQnkgPSBMaXN0Lm1heGltdW1CeTtcbnByZWx1ZGUubWluaW11bUJ5ID0gTGlzdC5taW5pbXVtQnk7XG5wcmVsdWRlLnNjYW4gPSBMaXN0LnNjYW47XG5wcmVsdWRlLnNjYW5sID0gTGlzdC5zY2FubDtcbnByZWx1ZGUuc2NhbjEgPSBMaXN0LnNjYW4xO1xucHJlbHVkZS5zY2FubDEgPSBMaXN0LnNjYW5sMTtcbnByZWx1ZGUuc2NhbnIgPSBMaXN0LnNjYW5yO1xucHJlbHVkZS5zY2FucjEgPSBMaXN0LnNjYW5yMTtcbnByZWx1ZGUuc2xpY2UgPSBMaXN0LnNsaWNlO1xucHJlbHVkZS50YWtlID0gTGlzdC50YWtlO1xucHJlbHVkZS5kcm9wID0gTGlzdC5kcm9wO1xucHJlbHVkZS5zcGxpdEF0ID0gTGlzdC5zcGxpdEF0O1xucHJlbHVkZS50YWtlV2hpbGUgPSBMaXN0LnRha2VXaGlsZTtcbnByZWx1ZGUuZHJvcFdoaWxlID0gTGlzdC5kcm9wV2hpbGU7XG5wcmVsdWRlLnNwYW4gPSBMaXN0LnNwYW47XG5wcmVsdWRlLmJyZWFrTGlzdCA9IExpc3QuYnJlYWtMaXN0O1xucHJlbHVkZS56aXAgPSBMaXN0LnppcDtcbnByZWx1ZGUuemlwV2l0aCA9IExpc3QuemlwV2l0aDtcbnByZWx1ZGUuemlwQWxsID0gTGlzdC56aXBBbGw7XG5wcmVsdWRlLnppcEFsbFdpdGggPSBMaXN0LnppcEFsbFdpdGg7XG5wcmVsdWRlLmF0ID0gTGlzdC5hdDtcbnByZWx1ZGUuZWxlbUluZGV4ID0gTGlzdC5lbGVtSW5kZXg7XG5wcmVsdWRlLmVsZW1JbmRpY2VzID0gTGlzdC5lbGVtSW5kaWNlcztcbnByZWx1ZGUuZmluZEluZGV4ID0gTGlzdC5maW5kSW5kZXg7XG5wcmVsdWRlLmZpbmRJbmRpY2VzID0gTGlzdC5maW5kSW5kaWNlcztcbnByZWx1ZGUuYXBwbHkgPSBGdW5jLmFwcGx5O1xucHJlbHVkZS5jdXJyeSA9IEZ1bmMuY3Vycnk7XG5wcmVsdWRlLmZsaXAgPSBGdW5jLmZsaXA7XG5wcmVsdWRlLmZpeCA9IEZ1bmMuZml4O1xucHJlbHVkZS5vdmVyID0gRnVuYy5vdmVyO1xucHJlbHVkZS5zcGxpdCA9IFN0ci5zcGxpdDtcbnByZWx1ZGUuam9pbiA9IFN0ci5qb2luO1xucHJlbHVkZS5saW5lcyA9IFN0ci5saW5lcztcbnByZWx1ZGUudW5saW5lcyA9IFN0ci51bmxpbmVzO1xucHJlbHVkZS53b3JkcyA9IFN0ci53b3JkcztcbnByZWx1ZGUudW53b3JkcyA9IFN0ci51bndvcmRzO1xucHJlbHVkZS5jaGFycyA9IFN0ci5jaGFycztcbnByZWx1ZGUudW5jaGFycyA9IFN0ci51bmNoYXJzO1xucHJlbHVkZS5yZXBlYXQgPSBTdHIucmVwZWF0O1xucHJlbHVkZS5jYXBpdGFsaXplID0gU3RyLmNhcGl0YWxpemU7XG5wcmVsdWRlLmNhbWVsaXplID0gU3RyLmNhbWVsaXplO1xucHJlbHVkZS5kYXNoZXJpemUgPSBTdHIuZGFzaGVyaXplO1xucHJlbHVkZS52YWx1ZXMgPSBPYmoudmFsdWVzO1xucHJlbHVkZS5rZXlzID0gT2JqLmtleXM7XG5wcmVsdWRlLnBhaXJzVG9PYmogPSBPYmoucGFpcnNUb09iajtcbnByZWx1ZGUub2JqVG9QYWlycyA9IE9iai5vYmpUb1BhaXJzO1xucHJlbHVkZS5saXN0c1RvT2JqID0gT2JqLmxpc3RzVG9PYmo7XG5wcmVsdWRlLm9ialRvTGlzdHMgPSBPYmoub2JqVG9MaXN0cztcbnByZWx1ZGUubWF4ID0gTnVtLm1heDtcbnByZWx1ZGUubWluID0gTnVtLm1pbjtcbnByZWx1ZGUubmVnYXRlID0gTnVtLm5lZ2F0ZTtcbnByZWx1ZGUuYWJzID0gTnVtLmFicztcbnByZWx1ZGUuc2lnbnVtID0gTnVtLnNpZ251bTtcbnByZWx1ZGUucXVvdCA9IE51bS5xdW90O1xucHJlbHVkZS5yZW0gPSBOdW0ucmVtO1xucHJlbHVkZS5kaXYgPSBOdW0uZGl2O1xucHJlbHVkZS5tb2QgPSBOdW0ubW9kO1xucHJlbHVkZS5yZWNpcCA9IE51bS5yZWNpcDtcbnByZWx1ZGUucGkgPSBOdW0ucGk7XG5wcmVsdWRlLnRhdSA9IE51bS50YXU7XG5wcmVsdWRlLmV4cCA9IE51bS5leHA7XG5wcmVsdWRlLnNxcnQgPSBOdW0uc3FydDtcbnByZWx1ZGUubG4gPSBOdW0ubG47XG5wcmVsdWRlLnBvdyA9IE51bS5wb3c7XG5wcmVsdWRlLnNpbiA9IE51bS5zaW47XG5wcmVsdWRlLnRhbiA9IE51bS50YW47XG5wcmVsdWRlLmNvcyA9IE51bS5jb3M7XG5wcmVsdWRlLmFjb3MgPSBOdW0uYWNvcztcbnByZWx1ZGUuYXNpbiA9IE51bS5hc2luO1xucHJlbHVkZS5hdGFuID0gTnVtLmF0YW47XG5wcmVsdWRlLmF0YW4yID0gTnVtLmF0YW4yO1xucHJlbHVkZS50cnVuY2F0ZSA9IE51bS50cnVuY2F0ZTtcbnByZWx1ZGUucm91bmQgPSBOdW0ucm91bmQ7XG5wcmVsdWRlLmNlaWxpbmcgPSBOdW0uY2VpbGluZztcbnByZWx1ZGUuZmxvb3IgPSBOdW0uZmxvb3I7XG5wcmVsdWRlLmlzSXROYU4gPSBOdW0uaXNJdE5hTjtcbnByZWx1ZGUuZXZlbiA9IE51bS5ldmVuO1xucHJlbHVkZS5vZGQgPSBOdW0ub2RkO1xucHJlbHVkZS5nY2QgPSBOdW0uZ2NkO1xucHJlbHVkZS5sY20gPSBOdW0ubGNtO1xucHJlbHVkZS5WRVJTSU9OID0gJzEuMS4xJztcbm1vZHVsZS5leHBvcnRzID0gcHJlbHVkZTtcbmZ1bmN0aW9uIGN1cnJ5JChmLCBib3VuZCl7XG4gIHZhciBjb250ZXh0LFxuICBfY3VycnkgPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgcmV0dXJuIGYubGVuZ3RoID4gMSA/IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgcGFyYW1zID0gYXJncyA/IGFyZ3MuY29uY2F0KCkgOiBbXTtcbiAgICAgIGNvbnRleHQgPSBib3VuZCA/IGNvbnRleHQgfHwgdGhpcyA6IHRoaXM7XG4gICAgICByZXR1cm4gcGFyYW1zLnB1c2guYXBwbHkocGFyYW1zLCBhcmd1bWVudHMpIDxcbiAgICAgICAgICBmLmxlbmd0aCAmJiBhcmd1bWVudHMubGVuZ3RoID9cbiAgICAgICAgX2N1cnJ5LmNhbGwoY29udGV4dCwgcGFyYW1zKSA6IGYuYXBwbHkoY29udGV4dCwgcGFyYW1zKTtcbiAgICB9IDogZjtcbiAgfTtcbiAgcmV0dXJuIF9jdXJyeSgpO1xufSIsInZhciBzdGQsIHVuaXRzLCBrSGFsZlRpbGUsIHRpbGVUb1B4LCB0aWxlVG9HYW1lLCBnYW1lVG9QeCwgU3ByaXRlLCBTcHJpdGVTdGF0ZSwgU1RBTkRJTkcsIFdBTEtJTkcsIEpVTVBJTkcsIEZBTExJTkcsIElOVEVSQUNUSU5HLCBMRUZULCBSSUdIVCwgVVAsIERPV04sIEhPUklaT05UQUwsIGtBcm1zU3ByaXRlUGF0aCwga1Nwcml0ZVdpZHRoLCBrU3ByaXRlSGVpZ2h0LCBrVXBPZmZzZXQsIGtEb3duT2Zmc2V0LCBrSG9yaXpvbnRhbE9mZnNldCwga1JpZ2h0T2Zmc2V0LCBrTGVmdE9mZnNldCwga1BvbGFyU3RhckluZGV4LCBQb2xhclN0YXIsIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5zdGQgPSByZXF1aXJlKCdzdGQnKTtcbnVuaXRzID0gcmVxdWlyZSgnLi91bml0cycpO1xua0hhbGZUaWxlID0gdW5pdHMua0hhbGZUaWxlLCB0aWxlVG9QeCA9IHVuaXRzLnRpbGVUb1B4LCB0aWxlVG9HYW1lID0gdW5pdHMudGlsZVRvR2FtZSwgZ2FtZVRvUHggPSB1bml0cy5nYW1lVG9QeDtcblNwcml0ZSA9IHJlcXVpcmUoJy4vc3ByaXRlJykuU3ByaXRlO1xuU3ByaXRlU3RhdGUgPSByZXF1aXJlKCcuL3Nwcml0ZXN0YXRlJyksIFNUQU5ESU5HID0gU3ByaXRlU3RhdGUuU1RBTkRJTkcsIFdBTEtJTkcgPSBTcHJpdGVTdGF0ZS5XQUxLSU5HLCBKVU1QSU5HID0gU3ByaXRlU3RhdGUuSlVNUElORywgRkFMTElORyA9IFNwcml0ZVN0YXRlLkZBTExJTkcsIElOVEVSQUNUSU5HID0gU3ByaXRlU3RhdGUuSU5URVJBQ1RJTkcsIExFRlQgPSBTcHJpdGVTdGF0ZS5MRUZULCBSSUdIVCA9IFNwcml0ZVN0YXRlLlJJR0hULCBVUCA9IFNwcml0ZVN0YXRlLlVQLCBET1dOID0gU3ByaXRlU3RhdGUuRE9XTiwgSE9SSVpPTlRBTCA9IFNwcml0ZVN0YXRlLkhPUklaT05UQUw7XG5rQXJtc1Nwcml0ZVBhdGggPSAnZGF0YS8xNngxNi9Bcm1zLmJtcCc7XG5rU3ByaXRlV2lkdGggPSAxLjU7XG5rU3ByaXRlSGVpZ2h0ID0gMS4wO1xua1VwT2Zmc2V0ID0gMjtcbmtEb3duT2Zmc2V0ID0gNDtcbmtIb3Jpem9udGFsT2Zmc2V0ID0gMDtcbmtSaWdodE9mZnNldCA9IDE7XG5rTGVmdE9mZnNldCA9IDA7XG5rUG9sYXJTdGFySW5kZXggPSAyO1xub3V0JC5Qb2xhclN0YXIgPSBQb2xhclN0YXIgPSAoZnVuY3Rpb24oKXtcbiAgUG9sYXJTdGFyLmRpc3BsYXlOYW1lID0gJ1BvbGFyU3Rhcic7XG4gIHZhciBwcm90b3R5cGUgPSBQb2xhclN0YXIucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IFBvbGFyU3RhcjtcbiAgZnVuY3Rpb24gUG9sYXJTdGFyKGdyYXBoaWNzKXtcbiAgICBzdGQubG9nKHRoaXMuc3ByaXRlcyA9IHRoaXMuaW5pdGlhbGlzZVNwcml0ZXMoZ3JhcGhpY3MpKTtcbiAgfVxuICBwcm90b3R5cGUuaW5pdGlhbGlzZVNwcml0ZSA9IGZ1bmN0aW9uKGdyYXBoaWNzLCBoZmFjaW5nLCB2ZmFjaW5nKXtcbiAgICB2YXIgdGlsZVk7XG4gICAgdGlsZVkgPSBoZmFjaW5nID09PSBMRUZUID8ga0xlZnRPZmZzZXQgOiBrUmlnaHRPZmZzZXQ7XG4gICAgc3dpdGNoICh2ZmFjaW5nKSB7XG4gICAgY2FzZSBIT1JJWk9OVEFMOlxuICAgICAgdGlsZVkgKz0ga0hvcml6b250YWxPZmZzZXQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFVQOlxuICAgICAgdGlsZVkgKz0ga1VwT2Zmc2V0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBET1dOOlxuICAgICAgdGlsZVkgKz0ga0Rvd25PZmZzZXQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTcHJpdGUoZ3JhcGhpY3MsIGtBcm1zU3ByaXRlUGF0aCwgdGlsZVRvUHgoa1BvbGFyU3RhckluZGV4ICoga1Nwcml0ZVdpZHRoKSwgdGlsZVRvUHgodGlsZVkpLCB0aWxlVG9QeChrU3ByaXRlV2lkdGgpLCB0aWxlVG9QeChrU3ByaXRlSGVpZ2h0KSk7XG4gIH07XG4gIHByb3RvdHlwZS5pbml0aWFsaXNlU3ByaXRlcyA9IGZ1bmN0aW9uKGdyYXBoaWNzLCBzcHJpdGVNYXApe1xuICAgIHZhciBpJCwgcmVmJCwgbGVuJCwgaGZhY2luZywgaiQsIHJlZjEkLCBsZW4xJCwgdmZhY2luZztcbiAgICBzcHJpdGVNYXAgPT0gbnVsbCAmJiAoc3ByaXRlTWFwID0ge30pO1xuICAgIGZvciAoaSQgPSAwLCBsZW4kID0gKHJlZiQgPSBbTEVGVCwgUklHSFRdKS5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgICAgaGZhY2luZyA9IHJlZiRbaSRdO1xuICAgICAgZm9yIChqJCA9IDAsIGxlbjEkID0gKHJlZjEkID0gW1VQLCBET1dOLCBIT1JJWk9OVEFMXSkubGVuZ3RoOyBqJCA8IGxlbjEkOyArK2okKSB7XG4gICAgICAgIHZmYWNpbmcgPSByZWYxJFtqJF07XG4gICAgICAgIHNwcml0ZU1hcFtTcHJpdGVTdGF0ZS5rZXkoaGZhY2luZywgdmZhY2luZyldID0gdGhpcy5pbml0aWFsaXNlU3ByaXRlKGdyYXBoaWNzLCBoZmFjaW5nLCB2ZmFjaW5nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNwcml0ZU1hcDtcbiAgfTtcbiAgcHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGVsYXBzZWRUaW1lKXt9O1xuICBwcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGdyYXBoaWNzLCB4LCB5LCBoZmFjaW5nLCB2ZmFjaW5nKXtcbiAgICB2YXIgeE9mZnNldCwgeU9mZnNldDtcbiAgICB4T2Zmc2V0ID0gaGZhY2luZyA9PT0gTEVGVCA/IC1rSGFsZlRpbGUgOiAwO1xuICAgIHlPZmZzZXQgPSB2ZmFjaW5nID09PSBVUCA/IC1rSGFsZlRpbGUgLyAyIDogMDtcbiAgICB5T2Zmc2V0ID0gdmZhY2luZyA9PT0gRE9XTiA/IGtIYWxmVGlsZSAvIDIgOiAwO1xuICAgIHJldHVybiB0aGlzLnNwcml0ZXNbU3ByaXRlU3RhdGUua2V5KGhmYWNpbmcsIHZmYWNpbmcpXS5kcmF3KGdyYXBoaWNzLCB4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICB9O1xuICByZXR1cm4gUG9sYXJTdGFyO1xufSgpKTsiLCJ2YXIgc3RkLCBTREwsIHVuaXRzLCBjb25maWcsIGtTY3JlZW5XaWR0aCwga1NjcmVlbkhlaWdodCwga0JhY2tncm91bmRTaXplLCBGaXhlZEJhY2tkcm9wLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG5TREwgPSByZXF1aXJlKCdTREwnKTtcbnVuaXRzID0gcmVxdWlyZSgnLi91bml0cycpO1xuY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcbmtTY3JlZW5XaWR0aCA9IGNvbmZpZy5rU2NyZWVuV2lkdGgsIGtTY3JlZW5IZWlnaHQgPSBjb25maWcua1NjcmVlbkhlaWdodDtcbmtCYWNrZ3JvdW5kU2l6ZSA9IDQ7XG5vdXQkLkZpeGVkQmFja2Ryb3AgPSBGaXhlZEJhY2tkcm9wID0gKGZ1bmN0aW9uKCl7XG4gIEZpeGVkQmFja2Ryb3AuZGlzcGxheU5hbWUgPSAnRml4ZWRCYWNrZHJvcCc7XG4gIHZhciBwcm90b3R5cGUgPSBGaXhlZEJhY2tkcm9wLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBGaXhlZEJhY2tkcm9wO1xuICBmdW5jdGlvbiBGaXhlZEJhY2tkcm9wKHBhdGgsIGdyYXBoaWNzKXtcbiAgICB0aGlzLnN1cmZhY2UgPSBncmFwaGljcy5sb2FkSW1hZ2UocGF0aCk7XG4gIH1cbiAgcHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihncmFwaGljcyl7XG4gICAgdmFyIGkkLCBzdGVwJCwgdG8kLCB4LCBscmVzdWx0JCwgaiQsIHN0ZXAxJCwgdG8xJCwgeSwgZGVzdFJlY3QsIHJlc3VsdHMkID0gW107XG4gICAgZm9yIChpJCA9IDAsIHRvJCA9IHVuaXRzLnRpbGVUb1B4KGtTY3JlZW5XaWR0aCArIGtCYWNrZ3JvdW5kU2l6ZSksIHN0ZXAkID0gdW5pdHMudGlsZVRvUHgoa0JhY2tncm91bmRTaXplKTsgc3RlcCQgPCAwID8gaSQgPj0gdG8kIDogaSQgPD0gdG8kOyBpJCArPSBzdGVwJCkge1xuICAgICAgeCA9IGkkO1xuICAgICAgbHJlc3VsdCQgPSBbXTtcbiAgICAgIGZvciAoaiQgPSAwLCB0bzEkID0gdW5pdHMudGlsZVRvUHgoa1NjcmVlbkhlaWdodCArIGtCYWNrZ3JvdW5kU2l6ZSksIHN0ZXAxJCA9IHVuaXRzLnRpbGVUb1B4KGtCYWNrZ3JvdW5kU2l6ZSk7IHN0ZXAxJCA8IDAgPyBqJCA+PSB0bzEkIDogaiQgPD0gdG8xJDsgaiQgKz0gc3RlcDEkKSB7XG4gICAgICAgIHkgPSBqJDtcbiAgICAgICAgZGVzdFJlY3QgPSBuZXcgU0RMLlJlY3QoeCwgeSwgdW5pdHMudGlsZVRvUHgoa0JhY2tncm91bmRTaXplKSwgdW5pdHMudGlsZVRvUHgoa0JhY2tncm91bmRTaXplKSk7XG4gICAgICAgIGxyZXN1bHQkLnB1c2goZ3JhcGhpY3MuYmxpdFN1cmZhY2UodGhpcy5zdXJmYWNlLCBudWxsLCBkZXN0UmVjdCkpO1xuICAgICAgfVxuICAgICAgcmVzdWx0cyQucHVzaChscmVzdWx0JCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzJDtcbiAgfTtcbiAgcmV0dXJuIEZpeGVkQmFja2Ryb3A7XG59KCkpOyIsInZhciBrU2NyZWVuV2lkdGgsIGtTY3JlZW5IZWlnaHQsIGtGcHMsIGtNYXhGcmFtZVRpbWUsIGtEZWJ1Z01vZGUsIGtHcmFwaGljc1F1YWxpdHksIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5vdXQkLmtTY3JlZW5XaWR0aCA9IGtTY3JlZW5XaWR0aCA9IDIwO1xub3V0JC5rU2NyZWVuSGVpZ2h0ID0ga1NjcmVlbkhlaWdodCA9IDE1O1xub3V0JC5rRnBzID0ga0ZwcyA9IDYwO1xub3V0JC5rTWF4RnJhbWVUaW1lID0ga01heEZyYW1lVGltZSA9IDUgKiAxMDAwIC8ga0Zwcztcbm91dCQua0RlYnVnTW9kZSA9IGtEZWJ1Z01vZGUgPSB0cnVlO1xub3V0JC5rR3JhcGhpY3NRdWFsaXR5ID0ga0dyYXBoaWNzUXVhbGl0eSA9IDE2OyIsInZhciBzdGQsIHVuaXRzLCBUaW1lciwgTnVtYmVyU3ByaXRlLCBrVmVsb2NpdHksIGtWYW5pc2hUaW1lLCBEYW1hZ2VUZXh0LCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG51bml0cyA9IHJlcXVpcmUoJy4vdW5pdHMnKTtcblRpbWVyID0gcmVxdWlyZSgnLi90aW1lcicpLlRpbWVyO1xuTnVtYmVyU3ByaXRlID0gcmVxdWlyZSgnLi9zcHJpdGUnKS5OdW1iZXJTcHJpdGU7XG5rVmVsb2NpdHkgPSAtdW5pdHMua0hhbGZUaWxlIC8gMjUwO1xua1ZhbmlzaFRpbWUgPSAyMDAwO1xub3V0JC5EYW1hZ2VUZXh0ID0gRGFtYWdlVGV4dCA9IChmdW5jdGlvbigpe1xuICBEYW1hZ2VUZXh0LmRpc3BsYXlOYW1lID0gJ0RhbWFnZVRleHQnO1xuICB2YXIgcHJvdG90eXBlID0gRGFtYWdlVGV4dC5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gRGFtYWdlVGV4dDtcbiAgZnVuY3Rpb24gRGFtYWdlVGV4dChncmFwaGljcywgeCwgeSl7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMudGltZXIgPSBuZXcgVGltZXIoa1ZhbmlzaFRpbWUpO1xuICAgIHRoaXMuZGFtYWdlID0gMDtcbiAgICB0aGlzLm9mZnNldFkgPSAwO1xuICB9XG4gIHByb3RvdHlwZS5zZXREYW1hZ2UgPSBmdW5jdGlvbihkYW1hZ2Upe1xuICAgIHRoaXMuZGFtYWdlID0gZGFtYWdlO1xuICAgIHRoaXMudGltZXIucmVzZXQoKTtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXRZID0gMDtcbiAgfTtcbiAgcHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGVsYXBzZWRUaW1lKXtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXRZID0gc3RkLm1heCh1bml0cy50aWxlVG9HYW1lKC0xKSwgdGhpcy5vZmZzZXRZICsga1ZlbG9jaXR5ICogZWxhcHNlZFRpbWUpO1xuICB9O1xuICBwcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGdyYXBoaWNzLCB4LCB5KXtcbiAgICBpZiAodGhpcy50aW1lci5pc0FjdGl2ZSgpKSB7XG4gICAgICByZXR1cm4gbmV3IE51bWJlclNwcml0ZS5EYW1hZ2VOdW1iZXIoZ3JhcGhpY3MsIHRoaXMuZGFtYWdlKS5kcmF3Q2VudGVyZWQoZ3JhcGhpY3MsIHgsIHkgKyB0aGlzLm9mZnNldFkpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIERhbWFnZVRleHQ7XG59KCkpOyIsInZhciBzdGQsIHVuaXRzLCB0aWxlVG9QeCwgdGlsZVRvR2FtZSwga0hhbGZUaWxlLCBrVGlsZVB4LCBSZWN0LCByZWYkLCBTcHJpdGUsIEFuaW1hdGVkU3ByaXRlLCBSSUdIVCwgTEVGVCwga0FuZ3VsYXJWZWxvY2l0eSwga0ZseUZwcywga051bUZseUZyYW1lcywga0NvbnRhY3REYW1hZ2UsIFNwcml0ZVN0YXRlLCBGaXJzdENhdmVCYXQsIHNsaWNlJCA9IFtdLnNsaWNlLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG51bml0cyA9IHJlcXVpcmUoJy4vdW5pdHMnKTtcbnRpbGVUb1B4ID0gdW5pdHMudGlsZVRvUHgsIHRpbGVUb0dhbWUgPSB1bml0cy50aWxlVG9HYW1lLCBrSGFsZlRpbGUgPSB1bml0cy5rSGFsZlRpbGUsIGtUaWxlUHggPSB1bml0cy5rVGlsZVB4O1xuUmVjdCA9IHJlcXVpcmUoJy4vcmVjdGFuZ2xlJykuUmVjdGFuZ2xlO1xucmVmJCA9IHJlcXVpcmUoJy4vc3ByaXRlJyksIFNwcml0ZSA9IHJlZiQuU3ByaXRlLCBBbmltYXRlZFNwcml0ZSA9IHJlZiQuQW5pbWF0ZWRTcHJpdGU7XG5SSUdIVCA9IFwiUlwiO1xuTEVGVCA9IFwiTFwiO1xua0FuZ3VsYXJWZWxvY2l0eSA9IDEyMCAvIDEwMDA7XG5rRmx5RnBzID0gMTU7XG5rTnVtRmx5RnJhbWVzID0gMztcbmtDb250YWN0RGFtYWdlID0gMTtcblNwcml0ZVN0YXRlID0gZnVuY3Rpb24oKXtcbiAgdmFyIGFyZ3M7XG4gIGFyZ3MgPSBzbGljZSQuY2FsbChhcmd1bWVudHMpO1xuICByZXR1cm4gU3RyaW5nKGFyZ3Muam9pbignLScpKTtcbn07XG5vdXQkLkZpcnN0Q2F2ZUJhdCA9IEZpcnN0Q2F2ZUJhdCA9IChmdW5jdGlvbigpe1xuICBGaXJzdENhdmVCYXQuZGlzcGxheU5hbWUgPSAnRmlyc3RDYXZlQmF0JztcbiAgdmFyIHByb3RvdHlwZSA9IEZpcnN0Q2F2ZUJhdC5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gRmlyc3RDYXZlQmF0O1xuICBmdW5jdGlvbiBGaXJzdENhdmVCYXQoZ3JhcGhpY3MsIHgsIGNlbnRlclkpe1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy5jZW50ZXJZID0gY2VudGVyWTtcbiAgICB0aGlzLnkgPSB0aGlzLmNlbnRlclk7XG4gICAgdGhpcy5mbGlnaHRBbmdsZSA9IDA7XG4gICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgPSBrQW5ndWxhclZlbG9jaXR5O1xuICAgIHRoaXMuaG9yaXpvbnRhbEZhY2luZyA9IFJJR0hUO1xuICAgIHRoaXMuc3ByaXRlcyA9IHRoaXMuaW5pdGlhbGlzZVNwcml0ZXMoZ3JhcGhpY3MpO1xuICAgIHRoaXMuY29udGFjdERhbWFnZSA9IGtDb250YWN0RGFtYWdlO1xuICB9XG4gIHByb3RvdHlwZS5nZXRTcHJpdGVTdGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIFNwcml0ZVN0YXRlKHRoaXMuaG9yaXpvbnRhbEZhY2luZyk7XG4gIH07XG4gIHByb3RvdHlwZS5pbml0aWFsaXNlU3ByaXRlID0gZnVuY3Rpb24oZ3JhcGhpY3MsIGZhY2luZyl7XG4gICAgdmFyIGZhY2luZ09mZnNldDtcbiAgICBmYWNpbmdPZmZzZXQgPSBmYWNpbmcgPT09IFJJR0hUID8gMSA6IDA7XG4gICAgcmV0dXJuIG5ldyBBbmltYXRlZFNwcml0ZShncmFwaGljcywgJ2RhdGEvMTZ4MTYvTnBjL05wY0NlbWV0LmJtcCcsIHRpbGVUb1B4KDIpLCB0aWxlVG9QeCgyICsgZmFjaW5nT2Zmc2V0KSwga1RpbGVQeCwga1RpbGVQeCwga0ZseUZwcywga051bUZseUZyYW1lcyk7XG4gIH07XG4gIHByb3RvdHlwZS5pbml0aWFsaXNlU3ByaXRlcyA9IGZ1bmN0aW9uKGdyYXBoaWNzLCBzcHJpdGVNYXApe1xuICAgIHZhciBpJCwgcmVmJCwgbGVuJCwgZmFjaW5nO1xuICAgIHNwcml0ZU1hcCA9PSBudWxsICYmIChzcHJpdGVNYXAgPSB7fSk7XG4gICAgZm9yIChpJCA9IDAsIGxlbiQgPSAocmVmJCA9IFtMRUZULCBSSUdIVF0pLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgICBmYWNpbmcgPSByZWYkW2kkXTtcbiAgICAgIHNwcml0ZU1hcFtTcHJpdGVTdGF0ZShmYWNpbmcpXSA9IHRoaXMuaW5pdGlhbGlzZVNwcml0ZShncmFwaGljcywgZmFjaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHNwcml0ZU1hcDtcbiAgfTtcbiAgcHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGVsYXBzZWRUaW1lLCBwbGF5ZXJYKXtcbiAgICB0aGlzLmhvcml6b250YWxGYWNpbmcgPSBwbGF5ZXJYIDwgdGhpcy54ID8gTEVGVCA6IFJJR0hUO1xuICAgIHRoaXMuZmxpZ2h0QW5nbGUgKz0gdGhpcy5hbmd1bGFyVmVsb2NpdHkgKiBlbGFwc2VkVGltZTtcbiAgICB0aGlzLnkgPSB0aGlzLmNlbnRlclkgKyB1bml0cy50aWxlVG9HYW1lKDUpIC8gMiAqIHN0ZC5zaW4odW5pdHMuZGVnVG9SYWQodGhpcy5mbGlnaHRBbmdsZSkpO1xuICAgIHJldHVybiB0aGlzLnNwcml0ZXNbdGhpcy5nZXRTcHJpdGVTdGF0ZSgpXS51cGRhdGUoZWxhcHNlZFRpbWUpO1xuICB9O1xuICBwcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGdyYXBoaWNzKXtcbiAgICByZXR1cm4gdGhpcy5zcHJpdGVzW3RoaXMuZ2V0U3ByaXRlU3RhdGUoKV0uZHJhdyhncmFwaGljcywgdGhpcy54LCB0aGlzLnkpO1xuICB9O1xuICBwcm90b3R5cGUuZGFtYWdlQ29sbGlzaW9uID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmV3IFJlY3QodGhpcy54ICsga0hhbGZUaWxlLCB0aGlzLnkgKyBrSGFsZlRpbGUsIDEsIDEpO1xuICB9O1xuICByZXR1cm4gRmlyc3RDYXZlQmF0O1xufSgpKTsiLCJ2YXIgc3RkLCBTREwsIGlucHV0LCB1bml0cywgY29uZmlnLCByZWFkb3V0LCBncmFwaGljcywgTWFwLCB0aWxlVG9HYW1lLCBUaW1lciwgUGxheWVyLCBSZWN0YW5nbGUsIEZpcnN0Q2F2ZUJhdCwgRml4ZWRCYWNrZHJvcCwga1NjcmVlbldpZHRoLCBrU2NyZWVuSGVpZ2h0LCBrRnBzLCBrTWF4RnJhbWVUaW1lLCBrRGVidWdNb2RlLCBydW5uaW5nLCBwbGF5ZXIsIGJhdCwgbWFwLCBsYXN0RnJhbWVUaW1lLCBhbnlLZXlzUHJlc3NlZCwgZXZlbnRMb29wLCB1cGRhdGUsIGRyYXcsIGNyZWF0ZVRlc3RXb3JsZCwgc3RhcnQsIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5zdGQgPSByZXF1aXJlKCdzdGQnKTtcblNETCA9IHJlcXVpcmUoJ1NETCcpO1xuaW5wdXQgPSByZXF1aXJlKCcuL2lucHV0Jyk7XG51bml0cyA9IHJlcXVpcmUoJy4vdW5pdHMnKTtcbmNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5yZWFkb3V0ID0gcmVxdWlyZSgnLi9yZWFkb3V0Jyk7XG5ncmFwaGljcyA9IHJlcXVpcmUoJy4vZ3JhcGhpY3MnKTtcbk1hcCA9IHJlcXVpcmUoJy4vbWFwJyk7XG50aWxlVG9HYW1lID0gdW5pdHMudGlsZVRvR2FtZTtcblRpbWVyID0gcmVxdWlyZSgnLi90aW1lcicpLlRpbWVyO1xuUGxheWVyID0gcmVxdWlyZSgnLi9wbGF5ZXInKS5QbGF5ZXI7XG5SZWN0YW5nbGUgPSByZXF1aXJlKCcuL3JlY3RhbmdsZScpLlJlY3RhbmdsZTtcbkZpcnN0Q2F2ZUJhdCA9IHJlcXVpcmUoJy4vZmlyc3QtY2F2ZS1iYXQnKS5GaXJzdENhdmVCYXQ7XG5GaXhlZEJhY2tkcm9wID0gcmVxdWlyZSgnLi9iYWNrZHJvcCcpLkZpeGVkQmFja2Ryb3A7XG5rU2NyZWVuV2lkdGggPSBjb25maWcua1NjcmVlbldpZHRoLCBrU2NyZWVuSGVpZ2h0ID0gY29uZmlnLmtTY3JlZW5IZWlnaHQsIGtGcHMgPSBjb25maWcua0Zwcywga01heEZyYW1lVGltZSA9IGNvbmZpZy5rTWF4RnJhbWVUaW1lLCBrRGVidWdNb2RlID0gY29uZmlnLmtEZWJ1Z01vZGU7XG5ydW5uaW5nID0gdHJ1ZTtcbnBsYXllciA9IG51bGw7XG5iYXQgPSBudWxsO1xubWFwID0gbnVsbDtcbmxhc3RGcmFtZVRpbWUgPSAwO1xuYW55S2V5c1ByZXNzZWQgPSBmYWxzZTtcbmV2ZW50TG9vcCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBzdGFydFRpbWUsIGV2ZW50LCDOlHQsIGVsYXBzZWRUaW1lO1xuICBzdGFydFRpbWUgPSBTREwuZ2V0VGlja3MoKTtcbiAgaW5wdXQuYmVnaW5OZXdGcmFtZSgpO1xuICB3aGlsZSAoZXZlbnQgPSBTREwucG9sbEV2ZW50KCkpIHtcbiAgICBhbnlLZXlzUHJlc3NlZCA9IHRydWU7XG4gICAgcmVhZG91dC51cGRhdGUoJ3dpbGxzdG9wJywgZmFsc2UpO1xuICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgIGNhc2UgU0RMLktFWURPV046XG4gICAgICBpbnB1dC5rZXlEb3duRXZlbnQoZXZlbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTREwuS0VZVVA6XG4gICAgICBpbnB1dC5rZXlVcEV2ZW50KGV2ZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBcIlVua25vd24gZXZlbnQgdHlwZTogXCIgKyBldmVudFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChpbnB1dC53YXNLZXlQcmVzc2VkKFNETC5LRVkuRVNDQVBFKSkge1xuICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgfVxuICBpZiAoaW5wdXQuaXNLZXlIZWxkKFNETC5LRVkuTEVGVCkgJiYgaW5wdXQuaXNLZXlIZWxkKFNETC5LRVkuUklHSFQpKSB7XG4gICAgcGxheWVyLnN0b3BNb3ZpbmcoKTtcbiAgfSBlbHNlIGlmIChpbnB1dC5pc0tleUhlbGQoU0RMLktFWS5MRUZUKSkge1xuICAgIHBsYXllci5zdGFydE1vdmluZ0xlZnQoKTtcbiAgfSBlbHNlIGlmIChpbnB1dC5pc0tleUhlbGQoU0RMLktFWS5SSUdIVCkpIHtcbiAgICBwbGF5ZXIuc3RhcnRNb3ZpbmdSaWdodCgpO1xuICB9IGVsc2Uge1xuICAgIHBsYXllci5zdG9wTW92aW5nKCk7XG4gIH1cbiAgaWYgKGlucHV0Lndhc0tleVByZXNzZWQoU0RMLktFWS5aKSkge1xuICAgIHBsYXllci5zdGFydEp1bXAoKTtcbiAgfSBlbHNlIGlmIChpbnB1dC53YXNLZXlSZWxlYXNlZChTREwuS0VZLlopKSB7XG4gICAgcGxheWVyLnN0b3BKdW1wKCk7XG4gIH1cbiAgaWYgKGlucHV0LmlzS2V5SGVsZChTREwuS0VZLlVQKSAmJiBpbnB1dC5pc0tleUhlbGQoU0RMLktFWS5ET1dOKSkge1xuICAgIHBsYXllci5sb29rSG9yaXpvbnRhbCgpO1xuICB9IGVsc2UgaWYgKGlucHV0LmlzS2V5SGVsZChTREwuS0VZLlVQKSkge1xuICAgIHBsYXllci5sb29rVXAoKTtcbiAgfSBlbHNlIGlmIChpbnB1dC5pc0tleUhlbGQoU0RMLktFWS5ET1dOKSkge1xuICAgIHBsYXllci5sb29rRG93bigpO1xuICB9IGVsc2Uge1xuICAgIHBsYXllci5sb29rSG9yaXpvbnRhbCgpO1xuICB9XG4gIM6UdCA9IHN0ZC5taW4oU0RMLmdldFRpY2tzKCkgLSBsYXN0RnJhbWVUaW1lLCBrTWF4RnJhbWVUaW1lKTtcbiAgdXBkYXRlKM6UdCk7XG4gIGRyYXcoKTtcbiAgaWYgKHJ1bm5pbmcpIHtcbiAgICBsYXN0RnJhbWVUaW1lID0gU0RMLmdldFRpY2tzKCk7XG4gICAgZWxhcHNlZFRpbWUgPSBsYXN0RnJhbWVUaW1lIC0gc3RhcnRUaW1lO1xuICAgIHJlYWRvdXQudXBkYXRlKCdmcmFtZXRpbWUnLCBzdGQuZmxvb3IoMTAwMCAvIM6UdCkpO1xuICAgIHJlYWRvdXQudXBkYXRlKCdkcmF3dGltZScsIGVsYXBzZWRUaW1lKTtcbiAgICByZXR1cm4gU0RMLmRlbGF5KDEwMDAgLyBrRnBzIC0gZWxhcHNlZFRpbWUsIGV2ZW50TG9vcCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0ZC5sb2coJ0dhbWUgc3RvcHBlZC4nKTtcbiAgfVxufTtcbnVwZGF0ZSA9IGZ1bmN0aW9uKGVsYXBzZWRUaW1lKXtcbiAgVGltZXIudXBkYXRlQWxsKGVsYXBzZWRUaW1lKTtcbiAgcGxheWVyLnVwZGF0ZShlbGFwc2VkVGltZSwgbWFwKTtcbiAgYmF0LnVwZGF0ZShlbGFwc2VkVGltZSwgcGxheWVyLngpO1xuICBpZiAoYmF0LmRhbWFnZUNvbGxpc2lvbigpLmNvbGxpZGVzV2l0aChwbGF5ZXIuZGFtYWdlQ29sbGlzaW9uKCkpKSB7XG4gICAgcmVhZG91dC51cGRhdGUoJ2NvbGxpZGVkJywgdHJ1ZSk7XG4gICAgcmV0dXJuIHBsYXllci50YWtlRGFtYWdlKGJhdC5jb250YWN0RGFtYWdlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVhZG91dC51cGRhdGUoJ2NvbGxpZGVkJywgZmFsc2UpO1xuICB9XG59O1xuZHJhdyA9IGZ1bmN0aW9uKCl7XG4gIGdyYXBoaWNzLmNsZWFyKCk7XG4gIG1hcC5kcmF3QmFja2dyb3VuZChncmFwaGljcyk7XG4gIGJhdC5kcmF3KGdyYXBoaWNzKTtcbiAgcGxheWVyLmRyYXcoZ3JhcGhpY3MpO1xuICBtYXAuZHJhdyhncmFwaGljcyk7XG4gIHJldHVybiBwbGF5ZXIuZHJhd0h1ZChncmFwaGljcyk7XG59O1xuY3JlYXRlVGVzdFdvcmxkID0gZnVuY3Rpb24oKXtcbiAgbWFwID0gTWFwLmNyZWF0ZVRlc3RNYXAoZ3JhcGhpY3MpO1xuICBwbGF5ZXIgPSBuZXcgUGxheWVyKGdyYXBoaWNzLCB1bml0cy50aWxlVG9HYW1lKGtTY3JlZW5XaWR0aCAvIDIpLCB1bml0cy50aWxlVG9HYW1lKDEwKSk7XG4gIHJldHVybiBiYXQgPSBuZXcgRmlyc3RDYXZlQmF0KGdyYXBoaWNzLCB1bml0cy50aWxlVG9HYW1lKDcpLCB1bml0cy50aWxlVG9HYW1lKDgpKTtcbn07XG5vdXQkLnN0YXJ0ID0gc3RhcnQgPSBmdW5jdGlvbigpe1xuICBTREwuaW5pdChTREwuSU5JVF9FVkVSWVRISU5HKTtcbiAgcmVhZG91dC5hZGRSZWFkZXIoJ2ZyYW1ldGltZScsICdGcmFtZSB0aW1lJyk7XG4gIHJlYWRvdXQuYWRkUmVhZGVyKCdkcmF3dGltZScsICdEcmF3IHRpbWUnKTtcbiAgcmVhZG91dC5hZGRSZWFkZXIoJ3dpbGxzdG9wJywgJ1dpbGwgc3RvcCcsIHRydWUpO1xuICByZWFkb3V0LmFkZFJlYWRlcignY29sbGlkZWQnLCAnQ29sbGlzaW9uPycsIGZhbHNlKTtcbiAgY3JlYXRlVGVzdFdvcmxkKCk7XG4gIGV2ZW50TG9vcCgpO1xuICBwbGF5ZXIuc3RhcnRNb3ZpbmdMZWZ0KCk7XG4gIHJldHVybiBzdGQuZGVsYXkoNTAwMCwgZnVuY3Rpb24oKXtcbiAgICBpZiAoIWFueUtleXNQcmVzc2VkKSB7XG4gICAgICByZXR1cm4gcnVubmluZyA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3RkLmxvZyhcIkdhbWUgYmVpbmcgaW50ZXJhY3RlZCB3aXRoLiBEb24ndCBzaHV0IGRvd25cIik7XG4gICAgfVxuICB9KTtcbn07IiwidmFyIHN0ZCwgU0RMLCBjb25maWcsIHVuaXRzLCBrU2NyZWVuV2lkdGgsIGtTY3JlZW5IZWlnaHQsIGtUcmFuc3BhcmVudENvbG9yLCBrU2NyZWVuU2NhbGVGYWN0b3IsIHNwcml0ZXNoZWV0cywgc2NyZWVuLCBsb2FkSW1hZ2UsIGJsaXRTdXJmYWNlLCB2aXN1YWxpc2VSZWN0LCBjbGVhciwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcbnN0ZCA9IHJlcXVpcmUoJ3N0ZCcpO1xuU0RMID0gcmVxdWlyZSgnU0RMJyk7XG5jb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xudW5pdHMgPSByZXF1aXJlKCcuL3VuaXRzJyk7XG5rU2NyZWVuV2lkdGggPSBjb25maWcua1NjcmVlbldpZHRoLCBrU2NyZWVuSGVpZ2h0ID0gY29uZmlnLmtTY3JlZW5IZWlnaHQ7XG5rVHJhbnNwYXJlbnRDb2xvciA9IFswLCAwLCAwXTtcbmtTY3JlZW5TY2FsZUZhY3RvciA9IDI7XG5zcHJpdGVzaGVldHMgPSB7fTtcbnNjcmVlbiA9IFNETC5zZXRWaWRlb01vZGUodW5pdHMudGlsZVRvUHgoa1NjcmVlbldpZHRoKSwgdW5pdHMudGlsZVRvUHgoa1NjcmVlbkhlaWdodCksIGtTY3JlZW5TY2FsZUZhY3Rvcik7XG5vdXQkLmxvYWRJbWFnZSA9IGxvYWRJbWFnZSA9IGZ1bmN0aW9uKHBhdGgsIHVzZVRyYW5zcGFyZW5jeSl7XG4gIHVzZVRyYW5zcGFyZW5jeSA9PSBudWxsICYmICh1c2VUcmFuc3BhcmVuY3kgPSBmYWxzZSk7XG4gIGlmIChzcHJpdGVzaGVldHNbcGF0aF0gPT0gbnVsbCkge1xuICAgIHNwcml0ZXNoZWV0c1twYXRoXSA9IFNETC5sb2FkSW1hZ2UocGF0aCk7XG4gICAgaWYgKHVzZVRyYW5zcGFyZW5jeSkge1xuICAgICAgU0RMLnNldENvbG9yS2V5KHNwcml0ZXNoZWV0c1twYXRoXSwga1RyYW5zcGFyZW50Q29sb3IpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmtEZWJ1Z01vZGUpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3ByaXRlc2hlZXRzW3BhdGhdLmNhbnZhcyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzcHJpdGVzaGVldHNbcGF0aF07XG59O1xub3V0JC5ibGl0U3VyZmFjZSA9IGJsaXRTdXJmYWNlID0gZnVuY3Rpb24oc291cmNlLCBzcmNSZWN0LCBkZXN0UmVjdCl7XG4gIHJldHVybiBTREwuYmxpdFN1cmZhY2Uoc291cmNlLCBzcmNSZWN0LCBzY3JlZW4sIGRlc3RSZWN0KTtcbn07XG5vdXQkLnZpc3VhbGlzZVJlY3QgPSB2aXN1YWxpc2VSZWN0ID0gZnVuY3Rpb24ocmVjdCwgZmlsbCl7XG4gIHZhciBwYWludFJlY3Q7XG4gIHBhaW50UmVjdCA9IG5ldyBTREwuUmVjdCh1bml0cy5nYW1lVG9QeChyZWN0LmxlZnQpLCB1bml0cy5nYW1lVG9QeChyZWN0LnRvcCksIHVuaXRzLmdhbWVUb1B4KHJlY3QudyksIHVuaXRzLmdhbWVUb1B4KHJlY3QuaCkpO1xuICBpZiAoZmlsbCkge1xuICAgIHJldHVybiBzY3JlZW4uZHJhd1JlY3QocGFpbnRSZWN0LCAncmVkJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHNjcmVlbi5kcmF3Qm94KHBhaW50UmVjdCwgJ3JlZCcpO1xuICB9XG59O1xub3V0JC5jbGVhciA9IGNsZWFyID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHNjcmVlbi5jbGVhcigpO1xufTsiLCJ2YXIgc3RkLCB1bml0cywgZGl2LCBrSGFsZlRpbGUsIHRpbGVUb1B4LCBweFRvR2FtZSwgdGlsZVRvR2FtZSwgVGltZXIsIHJlZiQsIFNwcml0ZSwgTnVtYmVyU3ByaXRlLCBWYXJ5aW5nV2lkdGhTcHJpdGUsIGtIZWFsdGhCYXJYLCBrSGVhbHRoQmFyWSwga0hlYWx0aEZpbGxYLCBrSGVhbHRoRmlsbFksIGtIZWFsdGhOdW1YLCBrSGVhbHRoTnVtWSwga01heEZpbGxQeCwga0RhbWFnZURlbGF5LCBrU3ByaXRlUGF0aCwgSGVhbHRoLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG51bml0cyA9IHJlcXVpcmUoJy4vdW5pdHMnKTtcbmRpdiA9IHN0ZC5kaXY7XG5rSGFsZlRpbGUgPSB1bml0cy5rSGFsZlRpbGUsIHRpbGVUb1B4ID0gdW5pdHMudGlsZVRvUHgsIHB4VG9HYW1lID0gdW5pdHMucHhUb0dhbWUsIHRpbGVUb0dhbWUgPSB1bml0cy50aWxlVG9HYW1lO1xuVGltZXIgPSByZXF1aXJlKCcuL3RpbWVyJykuVGltZXI7XG5yZWYkID0gcmVxdWlyZSgnLi9zcHJpdGUnKSwgU3ByaXRlID0gcmVmJC5TcHJpdGUsIE51bWJlclNwcml0ZSA9IHJlZiQuTnVtYmVyU3ByaXRlLCBWYXJ5aW5nV2lkdGhTcHJpdGUgPSByZWYkLlZhcnlpbmdXaWR0aFNwcml0ZTtcbmtIZWFsdGhCYXJYID0gdGlsZVRvR2FtZSgxKTtcbmtIZWFsdGhCYXJZID0gdGlsZVRvR2FtZSgyKTtcbmtIZWFsdGhGaWxsWCA9IHRpbGVUb0dhbWUoMi41KTtcbmtIZWFsdGhGaWxsWSA9IHRpbGVUb0dhbWUoMik7XG5rSGVhbHRoTnVtWCA9IHRpbGVUb0dhbWUoMS41KTtcbmtIZWFsdGhOdW1ZID0gdGlsZVRvR2FtZSgyKTtcbmtNYXhGaWxsUHggPSB0aWxlVG9QeCgyLjUpIC0gMTtcbmtEYW1hZ2VEZWxheSA9IDE1MDA7XG5rU3ByaXRlUGF0aCA9ICdkYXRhLzE2eDE2L1RleHRCb3guYm1wJztcbm91dCQuSGVhbHRoID0gSGVhbHRoID0gKGZ1bmN0aW9uKCl7XG4gIEhlYWx0aC5kaXNwbGF5TmFtZSA9ICdIZWFsdGgnO1xuICB2YXIgcHJvdG90eXBlID0gSGVhbHRoLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBIZWFsdGg7XG4gIGZ1bmN0aW9uIEhlYWx0aChncmFwaGljcywgbWF4SGVhbHRoKXtcbiAgICB0aGlzLm1heEhlYWx0aCA9IG1heEhlYWx0aCAhPSBudWxsID8gbWF4SGVhbHRoIDogNjtcbiAgICB0aGlzLmN1cnJlbnRIZWFsdGggPSB0aGlzLm1heEhlYWx0aDtcbiAgICB0aGlzLmRhbWFnZSA9IDA7XG4gICAgdGhpcy5kYW1hZ2VUaW1lciA9IG5ldyBUaW1lcihrRGFtYWdlRGVsYXkpO1xuICAgIHRoaXMuaGVhbHRoQmFyU3ByaXRlID0gbmV3IFNwcml0ZShncmFwaGljcywga1Nwcml0ZVBhdGgsIDAsIHRpbGVUb1B4KDIuNSksIHRpbGVUb1B4KDQpLCB0aWxlVG9QeCgwLjUpKTtcbiAgICB0aGlzLmhlYWx0aEZpbGxTcHJpdGUgPSBuZXcgVmFyeWluZ1dpZHRoU3ByaXRlKGdyYXBoaWNzLCBrU3ByaXRlUGF0aCwgMCwgdGlsZVRvUHgoMS41KSwga01heEZpbGxQeCwgdGlsZVRvUHgoMC41KSk7XG4gICAgdGhpcy5kYW1hZ2VGaWxsU3ByaXRlID0gbmV3IFZhcnlpbmdXaWR0aFNwcml0ZShncmFwaGljcywga1Nwcml0ZVBhdGgsIDAsIHRpbGVUb1B4KDIuMCksIGtNYXhGaWxsUHgsIHRpbGVUb1B4KDAuNSkpO1xuICB9XG4gIHByb3RvdHlwZS50YWtlRGFtYWdlID0gZnVuY3Rpb24oZGFtYWdlKXtcbiAgICBpZiAodGhpcy5jdXJyZW50SGVhbHRoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGFtYWdlVGltZXIucmVzZXQoKTtcbiAgICB0aGlzLmhlYWx0aEZpbGxTcHJpdGUuc2V0V2lkdGgodGhpcy5maWxsT2Zmc2V0KHRoaXMuY3VycmVudEhlYWx0aCAtIGRhbWFnZSkpO1xuICAgIHRoaXMuZGFtYWdlRmlsbFNwcml0ZS5zZXRXaWR0aCh0aGlzLmZpbGxPZmZzZXQoZGFtYWdlKSk7XG4gICAgdGhpcy5kYW1hZ2UgPSBkYW1hZ2U7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudEhlYWx0aCAtIGRhbWFnZSA8PSAwO1xuICB9O1xuICBwcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oZWxhcHNlZFRpbWUpe1xuICAgIGlmICh0aGlzLmRhbWFnZSA+IDAgJiYgdGhpcy5kYW1hZ2VUaW1lci5pc0V4cGlyZWQoKSkge1xuICAgICAgdGhpcy5jdXJyZW50SGVhbHRoID0gc3RkLm1heCgwLCB0aGlzLmN1cnJlbnRIZWFsdGggLSB0aGlzLmRhbWFnZSk7XG4gICAgICByZXR1cm4gdGhpcy5kYW1hZ2UgPSAwO1xuICAgIH1cbiAgfTtcbiAgcHJvdG90eXBlLmZpbGxPZmZzZXQgPSBmdW5jdGlvbihoZWFsdGgpe1xuICAgIHJldHVybiBrTWF4RmlsbFB4ICogKGhlYWx0aCAvIHRoaXMubWF4SGVhbHRoKTtcbiAgfTtcbiAgcHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihncmFwaGljcyl7XG4gICAgdmFyIHg7XG4gICAgdGhpcy5oZWFsdGhCYXJTcHJpdGUuZHJhdyhncmFwaGljcywga0hlYWx0aEJhclgsIGtIZWFsdGhCYXJZKTtcbiAgICBpZiAodGhpcy5jdXJyZW50SGVhbHRoICE9PSAwKSB7XG4gICAgICB0aGlzLmhlYWx0aEZpbGxTcHJpdGUuZHJhdyhncmFwaGljcywga0hlYWx0aEZpbGxYLCBrSGVhbHRoRmlsbFkpO1xuICAgICAgaWYgKHRoaXMuZGFtYWdlKSB7XG4gICAgICAgIHggPSBrSGVhbHRoRmlsbFggKyBweFRvR2FtZSh0aGlzLmZpbGxPZmZzZXQodGhpcy5jdXJyZW50SGVhbHRoIC0gdGhpcy5kYW1hZ2UpKTtcbiAgICAgICAgdGhpcy5kYW1hZ2VGaWxsU3ByaXRlLmRyYXcoZ3JhcGhpY3MsIHgsIGtIZWFsdGhGaWxsWSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgTnVtYmVyU3ByaXRlLkhVRE51bWJlcihncmFwaGljcywgdGhpcy5jdXJyZW50SGVhbHRoLCAyKS5kcmF3KGdyYXBoaWNzLCBrSGVhbHRoTnVtWCwga0hlYWx0aE51bVkpO1xuICB9O1xuICByZXR1cm4gSGVhbHRoO1xufSgpKTsiLCJ2YXIgc3RkLCBJbnB1dDtcbnN0ZCA9IHJlcXVpcmUoJ3N0ZCcpO1xuSW5wdXQgPSAoZnVuY3Rpb24oKXtcbiAgSW5wdXQuZGlzcGxheU5hbWUgPSAnSW5wdXQnO1xuICB2YXIgcHJvdG90eXBlID0gSW5wdXQucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IElucHV0O1xuICBmdW5jdGlvbiBJbnB1dCgpe1xuICAgIHRoaXMuaGVsZEtleXMgPSB7fTtcbiAgICB0aGlzLnByZXNzZWRLZXlzID0ge307XG4gICAgdGhpcy5yZWxlYXNlZEtleXMgPSB7fTtcbiAgfVxuICBwcm90b3R5cGUuYmVnaW5OZXdGcmFtZSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5wcmVzc2VkS2V5cyA9IHt9O1xuICAgIHJldHVybiB0aGlzLnJlbGVhc2VkS2V5cyA9IHt9O1xuICB9O1xuICBwcm90b3R5cGUua2V5RG93bkV2ZW50ID0gZnVuY3Rpb24oZXZlbnQpe1xuICAgIHRoaXMucHJlc3NlZEtleXNbZXZlbnQua2V5XSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMuaGVsZEtleXNbZXZlbnQua2V5XSA9IHRydWU7XG4gIH07XG4gIHByb3RvdHlwZS5rZXlVcEV2ZW50ID0gZnVuY3Rpb24oZXZlbnQpe1xuICAgIHRoaXMucmVsZWFzZWRLZXlzW2V2ZW50LmtleV0gPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLmhlbGRLZXlzW2V2ZW50LmtleV0gPSBmYWxzZTtcbiAgfTtcbiAgcHJvdG90eXBlLndhc0tleVByZXNzZWQgPSBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiB0aGlzLnByZXNzZWRLZXlzW2tleV07XG4gIH07XG4gIHByb3RvdHlwZS53YXNLZXlSZWxlYXNlZCA9IGZ1bmN0aW9uKGtleSl7XG4gICAgcmV0dXJuIHRoaXMucmVsZWFzZWRLZXlzW2tleV07XG4gIH07XG4gIHByb3RvdHlwZS5pc0tleUhlbGQgPSBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiB0aGlzLmhlbGRLZXlzW2tleV07XG4gIH07XG4gIHJldHVybiBJbnB1dDtcbn0oKSk7XG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBJbnB1dDsiLCJ2YXIgc3RkLCB1bml0cywgZGl2LCB0aWxlVG9QeCwgU3ByaXRlLCBGaXhlZEJhY2tkcm9wLCBSZWN0LCByZWYkLCBBSVJfVElMRSwgV0FMTF9USUxFLCBUaWxlLCBDb2xsaXNpb25UaWxlLCBNYXA7XG5zdGQgPSByZXF1aXJlKCdzdGQnKTtcbnVuaXRzID0gcmVxdWlyZSgnLi91bml0cycpO1xuZGl2ID0gc3RkLmRpdjtcbnRpbGVUb1B4ID0gdW5pdHMudGlsZVRvUHg7XG5TcHJpdGUgPSByZXF1aXJlKCcuL3Nwcml0ZScpLlNwcml0ZTtcbkZpeGVkQmFja2Ryb3AgPSByZXF1aXJlKCcuL2JhY2tkcm9wJykuRml4ZWRCYWNrZHJvcDtcblJlY3QgPSByZXF1aXJlKCcuL3JlY3RhbmdsZScpLlJlY3RhbmdsZTtcbnJlZiQgPSBzdGRbJ2VudW0nXSwgQUlSX1RJTEUgPSByZWYkWzBdLCBXQUxMX1RJTEUgPSByZWYkWzFdO1xuVGlsZSA9IChmdW5jdGlvbigpe1xuICBUaWxlLmRpc3BsYXlOYW1lID0gJ1RpbGUnO1xuICB2YXIgcHJvdG90eXBlID0gVGlsZS5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gVGlsZTtcbiAgZnVuY3Rpb24gVGlsZSh0eXBlLCBzcHJpdGUpe1xuICAgIHRoaXMudHlwZSA9IHR5cGUgIT0gbnVsbCA/IHR5cGUgOiBBSVJfVElMRTtcbiAgICB0aGlzLnNwcml0ZSA9IHNwcml0ZTtcbiAgfVxuICByZXR1cm4gVGlsZTtcbn0oKSk7XG5Db2xsaXNpb25UaWxlID0gKGZ1bmN0aW9uKCl7XG4gIENvbGxpc2lvblRpbGUuZGlzcGxheU5hbWUgPSAnQ29sbGlzaW9uVGlsZSc7XG4gIHZhciBwcm90b3R5cGUgPSBDb2xsaXNpb25UaWxlLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBDb2xsaXNpb25UaWxlO1xuICBmdW5jdGlvbiBDb2xsaXNpb25UaWxlKHJvdywgY29sLCB0eXBlKXtcbiAgICB0aGlzLnJvdyA9IHJvdztcbiAgICB0aGlzLmNvbCA9IGNvbDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG4gIHJldHVybiBDb2xsaXNpb25UaWxlO1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gTWFwID0gKGZ1bmN0aW9uKCl7XG4gIE1hcC5kaXNwbGF5TmFtZSA9ICdNYXAnO1xuICB2YXIgcHJvdG90eXBlID0gTWFwLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBNYXA7XG4gIGZ1bmN0aW9uIE1hcCgpe1xuICAgIHRoaXMuYmFja2Ryb3AgPSBudWxsO1xuICAgIHRoaXMudGlsZXMgPSBNYXAuY3JlYXRlTWF0cml4KG5ldyBUaWxlLCAyMCwgMTUpO1xuICAgIHRoaXMuYmdUaWxlcyA9IE1hcC5jcmVhdGVNYXRyaXgobnVsbCwgMjAsIDE1KTtcbiAgfVxuICBwcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oZWxhcHNlZFRpbWUpe1xuICAgIHZhciBpJCwgcmVmJCwgbGVuJCwgcm93LCBscmVzdWx0JCwgaiQsIGxlbjEkLCB0aWxlLCByZWYxJCwgcmVzdWx0cyQgPSBbXTtcbiAgICBmb3IgKGkkID0gMCwgbGVuJCA9IChyZWYkID0gdGhpcy50aWxlcykubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICAgIHJvdyA9IHJlZiRbaSRdO1xuICAgICAgbHJlc3VsdCQgPSBbXTtcbiAgICAgIGZvciAoaiQgPSAwLCBsZW4xJCA9IHJvdy5sZW5ndGg7IGokIDwgbGVuMSQ7ICsraiQpIHtcbiAgICAgICAgdGlsZSA9IHJvd1tqJF07XG4gICAgICAgIGxyZXN1bHQkLnB1c2goKHJlZjEkID0gdGlsZS5zcHJpdGUpICE9IG51bGwgPyByZWYxJC51cGRhdGUoZWxhcHNlZFRpbWUpIDogdm9pZCA4KTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdHMkLnB1c2gobHJlc3VsdCQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cyQ7XG4gIH07XG4gIHByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZ3JhcGhpY3Mpe1xuICAgIHZhciBpJCwgcmVmJCwgbGVuJCwgeSwgcm93LCBscmVzdWx0JCwgaiQsIGxlbjEkLCB4LCB0aWxlLCByZWYxJCwgcmVzdWx0cyQgPSBbXTtcbiAgICBmb3IgKGkkID0gMCwgbGVuJCA9IChyZWYkID0gdGhpcy50aWxlcykubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICAgIHkgPSBpJDtcbiAgICAgIHJvdyA9IHJlZiRbaSRdO1xuICAgICAgbHJlc3VsdCQgPSBbXTtcbiAgICAgIGZvciAoaiQgPSAwLCBsZW4xJCA9IHJvdy5sZW5ndGg7IGokIDwgbGVuMSQ7ICsraiQpIHtcbiAgICAgICAgeCA9IGokO1xuICAgICAgICB0aWxlID0gcm93W2okXTtcbiAgICAgICAgbHJlc3VsdCQucHVzaCgocmVmMSQgPSB0aWxlLnNwcml0ZSkgIT0gbnVsbCA/IHJlZjEkLmRyYXcoZ3JhcGhpY3MsIHVuaXRzLnRpbGVUb0dhbWUoeCksIHVuaXRzLnRpbGVUb0dhbWUoeSkpIDogdm9pZCA4KTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdHMkLnB1c2gobHJlc3VsdCQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cyQ7XG4gIH07XG4gIHByb3RvdHlwZS5kcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uKGdyYXBoaWNzKXtcbiAgICB2YXIgaSQsIHJlZiQsIGxlbiQsIHksIHJvdywgbHJlc3VsdCQsIGokLCBsZW4xJCwgeCwgc3ByaXRlLCByZXN1bHRzJCA9IFtdO1xuICAgIHRoaXMuYmFja2Ryb3AuZHJhdyhncmFwaGljcyk7XG4gICAgZm9yIChpJCA9IDAsIGxlbiQgPSAocmVmJCA9IHRoaXMuYmdUaWxlcykubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICAgIHkgPSBpJDtcbiAgICAgIHJvdyA9IHJlZiRbaSRdO1xuICAgICAgbHJlc3VsdCQgPSBbXTtcbiAgICAgIGZvciAoaiQgPSAwLCBsZW4xJCA9IHJvdy5sZW5ndGg7IGokIDwgbGVuMSQ7ICsraiQpIHtcbiAgICAgICAgeCA9IGokO1xuICAgICAgICBzcHJpdGUgPSByb3dbaiRdO1xuICAgICAgICBscmVzdWx0JC5wdXNoKHNwcml0ZSAhPSBudWxsID8gc3ByaXRlLmRyYXcoZ3JhcGhpY3MsIHVuaXRzLnRpbGVUb0dhbWUoeCksIHVuaXRzLnRpbGVUb0dhbWUoeSkpIDogdm9pZCA4KTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdHMkLnB1c2gobHJlc3VsdCQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cyQ7XG4gIH07XG4gIHByb3RvdHlwZS5nZXRDb2xsaWRpbmdUaWxlcyA9IGZ1bmN0aW9uKHJlY3Qpe1xuICAgIHZhciBmaXJzdFJvdywgbGFzdFJvdywgZmlyc3RDb2wsIGxhc3RDb2wsIGNvbGxpc2lvblRpbGVzLCBpJCwgcm93LCBqJCwgY29sO1xuICAgIGZpcnN0Um93ID0gZGl2KHVuaXRzLmdhbWVUb1B4KHJlY3QudG9wKSwgdW5pdHMudGlsZVRvUHgoMSkpO1xuICAgIGxhc3RSb3cgPSBkaXYodW5pdHMuZ2FtZVRvUHgocmVjdC5ib3R0b20pLCB1bml0cy50aWxlVG9QeCgxKSk7XG4gICAgZmlyc3RDb2wgPSBkaXYodW5pdHMuZ2FtZVRvUHgocmVjdC5sZWZ0KSwgdW5pdHMudGlsZVRvUHgoMSkpO1xuICAgIGxhc3RDb2wgPSBkaXYodW5pdHMuZ2FtZVRvUHgocmVjdC5yaWdodCksIHVuaXRzLnRpbGVUb1B4KDEpKTtcbiAgICBjb2xsaXNpb25UaWxlcyA9IFtdO1xuICAgIGZvciAoaSQgPSBmaXJzdFJvdzsgaSQgPD0gbGFzdFJvdzsgKytpJCkge1xuICAgICAgcm93ID0gaSQ7XG4gICAgICBmb3IgKGokID0gZmlyc3RDb2w7IGokIDw9IGxhc3RDb2w7ICsraiQpIHtcbiAgICAgICAgY29sID0gaiQ7XG4gICAgICAgIGNvbGxpc2lvblRpbGVzLnB1c2gobmV3IENvbGxpc2lvblRpbGUocm93LCBjb2wsIHRoaXMudGlsZXNbcm93XVtjb2xdLnR5cGUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxpc2lvblRpbGVzO1xuICB9O1xuICBNYXAuY3JlYXRlVGVzdE1hcCA9IGZ1bmN0aW9uKGdyYXBoaWNzKXtcbiAgICB2YXIgbWFwLCBiZ1BhdGgsIGZnUGF0aCwgbnVtUm93cywgbnVtQ29scywgcm93LCB0aWxlLCBpJCwgY29sLCBjaGFpblRvcCwgY2hhaW5NaWQsIGNoYWluQnRtLCBnYXRlQSwgZ2F0ZUIsIGdhdGVDLCBnYXRlRDtcbiAgICBtYXAgPSBuZXcgTWFwO1xuICAgIGJnUGF0aCA9ICdkYXRhLzE2eDE2L2JrQmx1ZS5ibXAnO1xuICAgIGZnUGF0aCA9ICdkYXRhLzE2eDE2L1N0YWdlL1BydENhdmUuYm1wJztcbiAgICBtYXAuYmFja2Ryb3AgPSBuZXcgRml4ZWRCYWNrZHJvcChiZ1BhdGgsIGdyYXBoaWNzKTtcbiAgICBudW1Sb3dzID0gMTU7XG4gICAgbnVtQ29scyA9IDIwO1xuICAgIHJvdyA9IDExO1xuICAgIHRpbGUgPSBuZXcgVGlsZShXQUxMX1RJTEUsIG5ldyBTcHJpdGUoZ3JhcGhpY3MsIGZnUGF0aCwgdW5pdHMudGlsZVRvUHgoMSksIDAsIHVuaXRzLnRpbGVUb1B4KDEpLCB1bml0cy50aWxlVG9QeCgxKSkpO1xuICAgIGZvciAoaSQgPSAwOyBpJCA8PSBudW1Db2xzOyArK2kkKSB7XG4gICAgICBjb2wgPSBpJDtcbiAgICAgIG1hcC50aWxlc1tyb3ddW2NvbF0gPSB0aWxlO1xuICAgIH1cbiAgICBtYXAudGlsZXNbMTBdWzVdID0gdGlsZTtcbiAgICBtYXAudGlsZXNbOV1bNF0gPSB0aWxlO1xuICAgIG1hcC50aWxlc1s4XVszXSA9IHRpbGU7XG4gICAgbWFwLnRpbGVzWzddWzJdID0gdGlsZTtcbiAgICBtYXAudGlsZXNbMTBdWzNdID0gdGlsZTtcbiAgICBjaGFpblRvcCA9IG5ldyBTcHJpdGUoZ3JhcGhpY3MsIGZnUGF0aCwgdGlsZVRvUHgoMTApLCB0aWxlVG9QeCg0KSwgdGlsZVRvUHgoMSksIHRpbGVUb1B4KDEpKTtcbiAgICBjaGFpbk1pZCA9IG5ldyBTcHJpdGUoZ3JhcGhpY3MsIGZnUGF0aCwgdGlsZVRvUHgoMTApLCB0aWxlVG9QeCg1KSwgdGlsZVRvUHgoMSksIHRpbGVUb1B4KDEpKTtcbiAgICBjaGFpbkJ0bSA9IG5ldyBTcHJpdGUoZ3JhcGhpY3MsIGZnUGF0aCwgdGlsZVRvUHgoMTApLCB0aWxlVG9QeCg2KSwgdGlsZVRvUHgoMSksIHRpbGVUb1B4KDEpKTtcbiAgICBtYXAuYmdUaWxlc1s4XVsyXSA9IGNoYWluVG9wO1xuICAgIG1hcC5iZ1RpbGVzWzldWzJdID0gY2hhaW5NaWQ7XG4gICAgbWFwLmJnVGlsZXNbMTBdWzJdID0gY2hhaW5CdG07XG4gICAgZ2F0ZUEgPSBuZXcgU3ByaXRlKGdyYXBoaWNzLCBmZ1BhdGgsIHRpbGVUb1B4KDgpLCB0aWxlVG9QeCg5KSwgdGlsZVRvUHgoMSksIHRpbGVUb1B4KDEpKTtcbiAgICBnYXRlQiA9IG5ldyBTcHJpdGUoZ3JhcGhpY3MsIGZnUGF0aCwgdGlsZVRvUHgoOSksIHRpbGVUb1B4KDkpLCB0aWxlVG9QeCgxKSwgdGlsZVRvUHgoMSkpO1xuICAgIGdhdGVDID0gbmV3IFNwcml0ZShncmFwaGljcywgZmdQYXRoLCB0aWxlVG9QeCg4KSwgdGlsZVRvUHgoMTApLCB0aWxlVG9QeCgxKSwgdGlsZVRvUHgoMSkpO1xuICAgIGdhdGVEID0gbmV3IFNwcml0ZShncmFwaGljcywgZmdQYXRoLCB0aWxlVG9QeCg5KSwgdGlsZVRvUHgoMTApLCB0aWxlVG9QeCgxKSwgdGlsZVRvUHgoMSkpO1xuICAgIG1hcC5iZ1RpbGVzWzldWzE1XSA9IGdhdGVBO1xuICAgIG1hcC5iZ1RpbGVzWzldWzE2XSA9IGdhdGVCO1xuICAgIG1hcC5iZ1RpbGVzWzEwXVsxNV0gPSBnYXRlQztcbiAgICBtYXAuYmdUaWxlc1sxMF1bMTZdID0gZ2F0ZUQ7XG4gICAgcmV0dXJuIG1hcDtcbiAgfTtcbiAgTWFwLmNyZWF0ZU1hdHJpeCA9IGZ1bmN0aW9uKHZhbHVlLCBjb2xzLCByb3dzKXtcbiAgICB2YXIgaSQsIHksIGxyZXN1bHQkLCBqJCwgeiwgcmVzdWx0cyQgPSBbXTtcbiAgICBmb3IgKGkkID0gMDsgaSQgPD0gcm93czsgKytpJCkge1xuICAgICAgeSA9IGkkO1xuICAgICAgbHJlc3VsdCQgPSBbXTtcbiAgICAgIGZvciAoaiQgPSAwOyBqJCA8PSBjb2xzOyArK2okKSB7XG4gICAgICAgIHogPSBqJDtcbiAgICAgICAgbHJlc3VsdCQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXN1bHRzJC5wdXNoKGxyZXN1bHQkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHMkO1xuICB9O1xuICBNYXAuV0FMTF9USUxFID0gV0FMTF9USUxFO1xuICBNYXAuQUlSX1RJTEUgPSBBSVJfVElMRTtcbiAgcmV0dXJuIE1hcDtcbn0oKSk7IiwidmFyIHN0ZCwgdW5pdHMsIGNvbmZpZywgcmVhZG91dCwga0hhbGZUaWxlLCB0aWxlVG9HYW1lLCB0aWxlVG9QeCwgU3ByaXRlU3RhdGUsIFNUQU5ESU5HLCBXQUxLSU5HLCBKVU1QSU5HLCBGQUxMSU5HLCBJTlRFUkFDVElORywgTEVGVCwgUklHSFQsIFVQLCBET1dOLCBIT1JJWk9OVEFMLCBXQUxMX1RJTEUsIFJlY3QsIFRpbWVyLCBIZWFsdGgsIERhbWFnZVRleHQsIFBvbGFyU3RhciwgcmVmJCwgU3ByaXRlLCBBbmltYXRlZFNwcml0ZSwgTnVtYmVyU3ByaXRlLCBrQ2hhcmFjdGVyRnJhbWUsIGtXYWxrRnJhbWUsIGtTdGFuZEZyYW1lLCBrSnVtcEZyYW1lLCBrRmFsbEZyYW1lLCBrVXBGcmFtZU9mZnNldCwga0Rvd25GcmFtZSwga0JhY2tGcmFtZSwga1dhbGtGcHMsIGtGcmljdGlvbiwga0dyYXZpdHksIGtXYWxraW5nQWNjZWxlcmF0aW9uLCBrQWlyQWNjZWxlcmF0aW9uLCBrTWF4U3BlZWRYLCBrTWF4U3BlZWRZLCBrSnVtcFNwZWVkLCBrU2hvcnRKdW1wU3BlZWQsIGtKdW1wR3Jhdml0eSwga0ludmluY2libGVUaW1lLCBrSW52aW5jaWJsZUZsYXNoVGltZSwga0NvbGxpc2lvblgsIGtDb2xsaXNpb25ZLCBQbGF5ZXIsIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5zdGQgPSByZXF1aXJlKCdzdGQnKTtcbnVuaXRzID0gcmVxdWlyZSgnLi91bml0cycpO1xuY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcbnJlYWRvdXQgPSByZXF1aXJlKCcuL3JlYWRvdXQnKTtcbmtIYWxmVGlsZSA9IHVuaXRzLmtIYWxmVGlsZSwgdGlsZVRvR2FtZSA9IHVuaXRzLnRpbGVUb0dhbWUsIHRpbGVUb1B4ID0gdW5pdHMudGlsZVRvUHg7XG5TcHJpdGVTdGF0ZSA9IHJlcXVpcmUoJy4vc3ByaXRlc3RhdGUnKSwgU1RBTkRJTkcgPSBTcHJpdGVTdGF0ZS5TVEFORElORywgV0FMS0lORyA9IFNwcml0ZVN0YXRlLldBTEtJTkcsIEpVTVBJTkcgPSBTcHJpdGVTdGF0ZS5KVU1QSU5HLCBGQUxMSU5HID0gU3ByaXRlU3RhdGUuRkFMTElORywgSU5URVJBQ1RJTkcgPSBTcHJpdGVTdGF0ZS5JTlRFUkFDVElORywgTEVGVCA9IFNwcml0ZVN0YXRlLkxFRlQsIFJJR0hUID0gU3ByaXRlU3RhdGUuUklHSFQsIFVQID0gU3ByaXRlU3RhdGUuVVAsIERPV04gPSBTcHJpdGVTdGF0ZS5ET1dOLCBIT1JJWk9OVEFMID0gU3ByaXRlU3RhdGUuSE9SSVpPTlRBTDtcbldBTExfVElMRSA9IHJlcXVpcmUoJy4vbWFwJykuV0FMTF9USUxFO1xuUmVjdCA9IHJlcXVpcmUoJy4vcmVjdGFuZ2xlJykuUmVjdGFuZ2xlO1xuVGltZXIgPSByZXF1aXJlKCcuL3RpbWVyJykuVGltZXI7XG5IZWFsdGggPSByZXF1aXJlKCcuL2hlYWx0aCcpLkhlYWx0aDtcbkRhbWFnZVRleHQgPSByZXF1aXJlKCcuL2RhbWFnZS10ZXh0JykuRGFtYWdlVGV4dDtcblBvbGFyU3RhciA9IHJlcXVpcmUoJy4vYXJtcycpLlBvbGFyU3RhcjtcbnJlZiQgPSByZXF1aXJlKCcuL3Nwcml0ZScpLCBTcHJpdGUgPSByZWYkLlNwcml0ZSwgQW5pbWF0ZWRTcHJpdGUgPSByZWYkLkFuaW1hdGVkU3ByaXRlLCBOdW1iZXJTcHJpdGUgPSByZWYkLk51bWJlclNwcml0ZTtcbmtDaGFyYWN0ZXJGcmFtZSA9IDA7XG5rV2Fsa0ZyYW1lID0gMDtcbmtTdGFuZEZyYW1lID0gMDtcbmtKdW1wRnJhbWUgPSAxO1xua0ZhbGxGcmFtZSA9IDI7XG5rVXBGcmFtZU9mZnNldCA9IDM7XG5rRG93bkZyYW1lID0gNjtcbmtCYWNrRnJhbWUgPSA3O1xua1dhbGtGcHMgPSAxNTtcbmtGcmljdGlvbiA9IDAuMDAwNDk4MDQ2ODc7XG5rR3Jhdml0eSA9IDAuMDAwNzgxMjU7XG5rV2Fsa2luZ0FjY2VsZXJhdGlvbiA9IDAuMDAwODMwMDc4MTI7XG5rQWlyQWNjZWxlcmF0aW9uID0gMC4wMDAzMTI1O1xua01heFNwZWVkWCA9IDAuMTU4NTkzNzU7XG5rTWF4U3BlZWRZID0gMC4yOTk4MDQ2ODc1O1xua0p1bXBTcGVlZCA9IDAuMjU7XG5rU2hvcnRKdW1wU3BlZWQgPSAwLjI1IC8gMS41O1xua0p1bXBHcmF2aXR5ID0gMC4wMDAzMTI1O1xua0ludmluY2libGVUaW1lID0gMzAwMDtcbmtJbnZpbmNpYmxlRmxhc2hUaW1lID0gNTA7XG5rQ29sbGlzaW9uWCA9IG5ldyBSZWN0KDYsIDEwLCAyMCwgMTIpO1xua0NvbGxpc2lvblkgPSBuZXcgUmVjdCgxMCwgMiwgMTIsIDMwKTtcbm91dCQuUGxheWVyID0gUGxheWVyID0gKGZ1bmN0aW9uKCl7XG4gIFBsYXllci5kaXNwbGF5TmFtZSA9ICdQbGF5ZXInO1xuICB2YXIgcHJvdG90eXBlID0gUGxheWVyLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBQbGF5ZXI7XG4gIGZ1bmN0aW9uIFBsYXllcihncmFwaGljcywgeCwgeSl7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMudmVsb2NpdHlZID0gMDtcbiAgICB0aGlzLnZlbG9jaXR5WCA9IDA7XG4gICAgdGhpcy5hY2NlbGVyYXRpb25YID0gMDtcbiAgICB0aGlzLmhvcml6b250YWxGYWNpbmcgPSBMRUZUO1xuICAgIHRoaXMudmVydGljYWxGYWNpbmcgPSBIT1JJWk9OVEFMO1xuICAgIHRoaXMub25Hcm91bmQgPSBmYWxzZTtcbiAgICB0aGlzLmp1bXBBY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmludGVyYWN0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5pbnZpbmNpYmxlVGltZXIgPSBuZXcgVGltZXIoa0ludmluY2libGVUaW1lKTtcbiAgICB0aGlzLmhlYWx0aCA9IG5ldyBIZWFsdGgoZ3JhcGhpY3MpO1xuICAgIHRoaXMuc3ByaXRlcyA9IHRoaXMuaW5pdGlhbGlzZVNwcml0ZXMoZ3JhcGhpY3MpO1xuICAgIHRoaXMuZGFtYWdlVGV4dCA9IG5ldyBEYW1hZ2VUZXh0KGdyYXBoaWNzKTtcbiAgICB0aGlzLmd1biA9IG5ldyBQb2xhclN0YXIoZ3JhcGhpY3MpO1xuICAgIGlmIChjb25maWcua0RlYnVnTW9kZSkge1xuICAgICAgcmVhZG91dC5hZGRSZWFkZXIoJ3Nwcml0ZXN0YXRlJywgJ1Nwcml0ZVN0YXRlJyk7XG4gICAgfVxuICB9XG4gIHByb3RvdHlwZS5pbml0aWFsaXNlU3ByaXRlID0gZnVuY3Rpb24oZ3JhcGhpY3MsIG1vdGlvbiwgaGZhY2luZywgdmZhY2luZyl7XG4gICAgdmFyIHRpbGVYLCB0aWxlWSwgc291cmNlWDtcbiAgICB0aWxlWCA9IChmdW5jdGlvbigpe1xuICAgICAgc3dpdGNoIChtb3Rpb24pIHtcbiAgICAgIGNhc2UgV0FMS0lORzpcbiAgICAgICAgcmV0dXJuIGtXYWxrRnJhbWU7XG4gICAgICBjYXNlIFNUQU5ESU5HOlxuICAgICAgICByZXR1cm4ga1N0YW5kRnJhbWU7XG4gICAgICBjYXNlIEpVTVBJTkc6XG4gICAgICAgIHJldHVybiBrSnVtcEZyYW1lO1xuICAgICAgY2FzZSBGQUxMSU5HOlxuICAgICAgICByZXR1cm4ga0ZhbGxGcmFtZTtcbiAgICAgIGNhc2UgSU5URVJBQ1RJTkc6XG4gICAgICAgIHJldHVybiBrQmFja0ZyYW1lO1xuICAgICAgfVxuICAgIH0oKSk7XG4gICAgdGlsZVggKz0gdmZhY2luZyA9PT0gVVAgPyBrVXBGcmFtZU9mZnNldCA6IDA7XG4gICAgdGlsZVkgPSBrQ2hhcmFjdGVyRnJhbWUgKyAoaGZhY2luZyA9PT0gTEVGVCA/IDAgOiAxKTtcbiAgICBpZiAobW90aW9uID09PSBXQUxLSU5HKSB7XG4gICAgICByZXR1cm4gbmV3IEFuaW1hdGVkU3ByaXRlKGdyYXBoaWNzLCAnZGF0YS8xNngxNi9NeUNoYXIuYm1wJywgdW5pdHMudGlsZVRvUHgodGlsZVgpLCB1bml0cy50aWxlVG9QeCh0aWxlWSksIHVuaXRzLnRpbGVUb1B4KDEpLCB1bml0cy50aWxlVG9QeCgxKSwga1dhbGtGcHMsIDMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmZhY2luZyA9PT0gRE9XTiAmJiAobW90aW9uID09PSBKVU1QSU5HIHx8IG1vdGlvbiA9PT0gRkFMTElORykpIHtcbiAgICAgICAgc291cmNlWCA9IGtEb3duRnJhbWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFNwcml0ZShncmFwaGljcywgJ2RhdGEvMTZ4MTYvTXlDaGFyLmJtcCcsIHVuaXRzLnRpbGVUb1B4KHRpbGVYKSwgdW5pdHMudGlsZVRvUHgodGlsZVkpLCB1bml0cy50aWxlVG9QeCgxKSwgdW5pdHMudGlsZVRvUHgoMSkpO1xuICAgIH1cbiAgfTtcbiAgcHJvdG90eXBlLmluaXRpYWxpc2VTcHJpdGVzID0gZnVuY3Rpb24oZ3JhcGhpY3MsIHNwcml0ZU1hcCl7XG4gICAgdmFyIGkkLCByZWYkLCBsZW4kLCBtb3Rpb24sIGokLCByZWYxJCwgbGVuMSQsIGhmYWNpbmcsIGskLCByZWYyJCwgbGVuMiQsIHZmYWNpbmc7XG4gICAgc3ByaXRlTWFwID09IG51bGwgJiYgKHNwcml0ZU1hcCA9IHt9KTtcbiAgICBmb3IgKGkkID0gMCwgbGVuJCA9IChyZWYkID0gW1NUQU5ESU5HLCBXQUxLSU5HLCBKVU1QSU5HLCBGQUxMSU5HLCBJTlRFUkFDVElOR10pLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgICBtb3Rpb24gPSByZWYkW2kkXTtcbiAgICAgIGZvciAoaiQgPSAwLCBsZW4xJCA9IChyZWYxJCA9IFtMRUZULCBSSUdIVF0pLmxlbmd0aDsgaiQgPCBsZW4xJDsgKytqJCkge1xuICAgICAgICBoZmFjaW5nID0gcmVmMSRbaiRdO1xuICAgICAgICBmb3IgKGskID0gMCwgbGVuMiQgPSAocmVmMiQgPSBbVVAsIERPV04sIEhPUklaT05UQUxdKS5sZW5ndGg7IGskIDwgbGVuMiQ7ICsrayQpIHtcbiAgICAgICAgICB2ZmFjaW5nID0gcmVmMiRbayRdO1xuICAgICAgICAgIHNwcml0ZU1hcFtTcHJpdGVTdGF0ZS5rZXkobW90aW9uLCBoZmFjaW5nLCB2ZmFjaW5nKV0gPSB0aGlzLmluaXRpYWxpc2VTcHJpdGUoZ3JhcGhpY3MsIG1vdGlvbiwgaGZhY2luZywgdmZhY2luZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNwcml0ZU1hcDtcbiAgfTtcbiAgcHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGVsYXBzZWRUaW1lLCBtYXApe1xuICAgIHRoaXMuc3ByaXRlc1t0aGlzLmdldFNwcml0ZVN0YXRlKCldLnVwZGF0ZShlbGFwc2VkVGltZSk7XG4gICAgdGhpcy5oZWFsdGgudXBkYXRlKGVsYXBzZWRUaW1lKTtcbiAgICB0aGlzLnVwZGF0ZVgoZWxhcHNlZFRpbWUsIG1hcCk7XG4gICAgdGhpcy51cGRhdGVZKGVsYXBzZWRUaW1lLCBtYXApO1xuICAgIHJldHVybiB0aGlzLmRhbWFnZVRleHQudXBkYXRlKGVsYXBzZWRUaW1lKTtcbiAgfTtcbiAgcHJvdG90eXBlLnVwZGF0ZVggPSBmdW5jdGlvbihlbGFwc2VkVGltZSwgbWFwKXtcbiAgICB2YXIgYWNjWCwgzpR4O1xuICAgIGFjY1ggPSB0aGlzLm9uR3JvdW5kID8ga1dhbGtpbmdBY2NlbGVyYXRpb24gOiBrQWlyQWNjZWxlcmF0aW9uO1xuICAgIHRoaXMudmVsb2NpdHlYICs9IHRoaXMuYWNjZWxlcmF0aW9uWCAqIGFjY1ggKiBlbGFwc2VkVGltZTtcbiAgICBpZiAodGhpcy5hY2NlbGVyYXRpb25YIDwgMCkge1xuICAgICAgdGhpcy52ZWxvY2l0eVggPSBzdGQubWF4KHRoaXMudmVsb2NpdHlYLCAta01heFNwZWVkWCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmFjY2VsZXJhdGlvblggPiAwKSB7XG4gICAgICB0aGlzLnZlbG9jaXR5WCA9IHN0ZC5taW4odGhpcy52ZWxvY2l0eVgsIGtNYXhTcGVlZFgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vbkdyb3VuZCkge1xuICAgICAgdGhpcy52ZWxvY2l0eVggPSB0aGlzLnZlbG9jaXR5WCA+IDBcbiAgICAgICAgPyBzdGQubWF4KDAsIHRoaXMudmVsb2NpdHlYIC0ga0ZyaWN0aW9uICogZWxhcHNlZFRpbWUpXG4gICAgICAgIDogc3RkLm1pbigwLCB0aGlzLnZlbG9jaXR5WCArIGtGcmljdGlvbiAqIGVsYXBzZWRUaW1lKTtcbiAgICB9XG4gICAgzpR4ID0gdGhpcy52ZWxvY2l0eVggKiBlbGFwc2VkVGltZTtcbiAgICBpZiAozpR4ID4gMCkge1xuICAgICAgdGhpcy5vbldhbGxDb2xsaXNpb24obWFwLCB0aGlzLnJpZ2h0Q29sbGlzaW9uKM6UeCksIGZ1bmN0aW9uKHRpbGUpe1xuICAgICAgICBpZiAodGlsZSkge1xuICAgICAgICAgIHRoaXMueCA9IHVuaXRzLnRpbGVUb0dhbWUodGlsZS5jb2wpIC0ga0NvbGxpc2lvblgucmlnaHQ7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudmVsb2NpdHlYID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy54ICs9IM6UeDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5vbldhbGxDb2xsaXNpb24obWFwLCB0aGlzLmxlZnRDb2xsaXNpb24oMCksIGZ1bmN0aW9uKHRpbGUpe1xuICAgICAgICBpZiAodGlsZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnggPSB1bml0cy50aWxlVG9HYW1lKHRpbGUuY29sKSArIGtDb2xsaXNpb25YLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbldhbGxDb2xsaXNpb24obWFwLCB0aGlzLmxlZnRDb2xsaXNpb24ozpR4KSwgZnVuY3Rpb24odGlsZSl7XG4gICAgICAgIGlmICh0aWxlKSB7XG4gICAgICAgICAgdGhpcy54ID0gdW5pdHMudGlsZVRvR2FtZSh0aWxlLmNvbCkgKyBrQ29sbGlzaW9uWC5yaWdodDtcbiAgICAgICAgICByZXR1cm4gdGhpcy52ZWxvY2l0eVggPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLnggKz0gzpR4O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLm9uV2FsbENvbGxpc2lvbihtYXAsIHRoaXMucmlnaHRDb2xsaXNpb24oMCksIGZ1bmN0aW9uKHRpbGUpe1xuICAgICAgICBpZiAodGlsZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnggPSB1bml0cy50aWxlVG9HYW1lKHRpbGUuY29sKSAtIGtDb2xsaXNpb25YLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIHByb3RvdHlwZS51cGRhdGVZID0gZnVuY3Rpb24oZWxhcHNlZFRpbWUsIG1hcCl7XG4gICAgdmFyIGdyYXZpdHksIM6UeTtcbiAgICBncmF2aXR5ID0gdGhpcy5qdW1wQWN0aXZlICYmIHRoaXMudmVsb2NpdHlZIDwgMCA/IGtKdW1wR3Jhdml0eSA6IGtHcmF2aXR5O1xuICAgIHRoaXMudmVsb2NpdHlZID0gc3RkLm1pbih0aGlzLnZlbG9jaXR5WSArIGdyYXZpdHkgKiBlbGFwc2VkVGltZSwga01heFNwZWVkWSk7XG4gICAgzpR5ID0gdGhpcy52ZWxvY2l0eVkgKiBlbGFwc2VkVGltZTtcbiAgICBpZiAozpR5ID4gMCkge1xuICAgICAgdGhpcy5vbldhbGxDb2xsaXNpb24obWFwLCB0aGlzLmJvdHRvbUNvbGxpc2lvbijOlHkpLCBmdW5jdGlvbih0aWxlKXtcbiAgICAgICAgaWYgKHRpbGUpIHtcbiAgICAgICAgICB0aGlzLnkgPSB1bml0cy50aWxlVG9HYW1lKHRpbGUucm93KSAtIGtDb2xsaXNpb25ZLmJvdHRvbTtcbiAgICAgICAgICB0aGlzLnZlbG9jaXR5WSA9IDA7XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25Hcm91bmQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMueSArPSDOlHk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25Hcm91bmQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5vbldhbGxDb2xsaXNpb24obWFwLCB0aGlzLnRvcENvbGxpc2lvbigwKSwgZnVuY3Rpb24odGlsZSl7XG4gICAgICAgIGlmICh0aWxlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMueSA9IHVuaXRzLnRpbGVUb0dhbWUodGlsZS5yb3cpICsga0NvbGxpc2lvblkuaDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub25XYWxsQ29sbGlzaW9uKG1hcCwgdGhpcy50b3BDb2xsaXNpb24ozpR5KSwgZnVuY3Rpb24odGlsZSl7XG4gICAgICAgIGlmICh0aWxlKSB7XG4gICAgICAgICAgdGhpcy55ID0gdW5pdHMudGlsZVRvR2FtZSh0aWxlLnJvdykgKyBrQ29sbGlzaW9uWS5oO1xuICAgICAgICAgIHJldHVybiB0aGlzLnZlbG9jaXR5WSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy55ICs9IM6UeTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vbkdyb3VuZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLm9uV2FsbENvbGxpc2lvbihtYXAsIHRoaXMuYm90dG9tQ29sbGlzaW9uKDApLCBmdW5jdGlvbih0aWxlKXtcbiAgICAgICAgaWYgKHRpbGUpIHtcbiAgICAgICAgICB0aGlzLnkgPSB1bml0cy50aWxlVG9HYW1lKHRpbGUucm93KSAtIGtDb2xsaXNpb25ZLmJvdHRvbTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vbkdyb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgcHJvdG90eXBlLnRha2VEYW1hZ2UgPSBmdW5jdGlvbihkYW1hZ2Upe1xuICAgIGRhbWFnZSA9PSBudWxsICYmIChkYW1hZ2UgPSAxKTtcbiAgICBpZiAoIXRoaXMuaW52aW5jaWJsZVRpbWVyLmlzQWN0aXZlKCkpIHtcbiAgICAgIHRoaXMuaGVhbHRoLnRha2VEYW1hZ2UoZGFtYWdlKTtcbiAgICAgIHRoaXMudmVsb2NpdHlZID0gc3RkLm1pbigta1Nob3J0SnVtcFNwZWVkLCB0aGlzLnZlbG9jaXR5WSk7XG4gICAgICB0aGlzLmludmluY2libGUgPSB0cnVlO1xuICAgICAgdGhpcy5pbnZpbmNpYmxlVGltZXIucmVzZXQoKTtcbiAgICAgIHJldHVybiB0aGlzLmRhbWFnZVRleHQuc2V0RGFtYWdlKGRhbWFnZSk7XG4gICAgfVxuICB9O1xuICBwcm90b3R5cGUuc3ByaXRlSXNWaXNpYmxlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZHV0eTtcbiAgICBkdXR5ID0gc3RkLmRpdih0aGlzLmludmluY2libGVUaW1lci5jdXJyZW50VGltZSwga0ludmluY2libGVGbGFzaFRpbWUpICUgMiA9PT0gMDtcbiAgICByZXR1cm4gISh0aGlzLmludmluY2libGVUaW1lci5pc0FjdGl2ZSgpICYmIGR1dHkpO1xuICB9O1xuICBwcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGdyYXBoaWNzKXtcbiAgICBpZiAodGhpcy5zcHJpdGVJc1Zpc2libGUoKSkge1xuICAgICAgdGhpcy5zcHJpdGVzW3RoaXMuZ2V0U3ByaXRlU3RhdGUoKV0uZHJhdyhncmFwaGljcywgdGhpcy54LCB0aGlzLnkpO1xuICAgICAgdGhpcy5ndW4uZHJhdyhncmFwaGljcywgdGhpcy54LCB0aGlzLnksIHRoaXMuaG9yaXpvbnRhbEZhY2luZywgdGhpcy52ZXJ0aWNhbEZhY2luZyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRhbWFnZVRleHQuZHJhdyhncmFwaGljcywgdGhpcy5jZW50ZXJYKCksIHRoaXMuY2VudGVyWSgpKTtcbiAgfTtcbiAgcHJvdG90eXBlLmRyYXdIdWQgPSBmdW5jdGlvbihncmFwaGljcyl7XG4gICAgaWYgKCF0aGlzLnNwcml0ZUlzVmlzaWJsZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmhlYWx0aC5kcmF3KGdyYXBoaWNzKTtcbiAgfTtcbiAgcHJvdG90eXBlLmdldFNwcml0ZVN0YXRlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgbW90aW9uVHlwZSwga2V5O1xuICAgIG1vdGlvblR5cGUgPSB0aGlzLmludGVyYWN0aW5nXG4gICAgICA/IElOVEVSQUNUSU5HXG4gICAgICA6IHRoaXMub25Hcm91bmRcbiAgICAgICAgPyB0aGlzLmFjY2VsZXJhdGlvblggPT09IDAgPyBTVEFORElORyA6IFdBTEtJTkdcbiAgICAgICAgOiB0aGlzLnZlbG9jaXR5WSA8IDAgPyBKVU1QSU5HIDogRkFMTElORztcbiAgICBrZXkgPSBTcHJpdGVTdGF0ZS5rZXkobW90aW9uVHlwZSwgdGhpcy5ob3Jpem9udGFsRmFjaW5nLCB0aGlzLnZlcnRpY2FsRmFjaW5nKTtcbiAgICByZWFkb3V0LnVwZGF0ZSgnc3ByaXRlc3RhdGUnLCBrZXkpO1xuICAgIHJldHVybiBrZXk7XG4gIH07XG4gIHByb3RvdHlwZS5sZWZ0Q29sbGlzaW9uID0gZnVuY3Rpb24ozpQpe1xuICAgIHJldHVybiBuZXcgUmVjdCh0aGlzLnggKyBrQ29sbGlzaW9uWC5sZWZ0ICsgzpQsIHRoaXMueSArIGtDb2xsaXNpb25YLnRvcCwga0NvbGxpc2lvblgudyAvIDIgLSDOlCwga0NvbGxpc2lvblguaCk7XG4gIH07XG4gIHByb3RvdHlwZS5yaWdodENvbGxpc2lvbiA9IGZ1bmN0aW9uKM6UKXtcbiAgICByZXR1cm4gbmV3IFJlY3QodGhpcy54ICsga0NvbGxpc2lvblgubGVmdCArIGtDb2xsaXNpb25YLncgLyAyLCB0aGlzLnkgKyBrQ29sbGlzaW9uWC50b3AsIGtDb2xsaXNpb25YLncgLyAyICsgzpQsIGtDb2xsaXNpb25YLmgpO1xuICB9O1xuICBwcm90b3R5cGUudG9wQ29sbGlzaW9uID0gZnVuY3Rpb24ozpQpe1xuICAgIHJldHVybiBuZXcgUmVjdCh0aGlzLnggKyBrQ29sbGlzaW9uWS5sZWZ0LCB0aGlzLnkgKyBrQ29sbGlzaW9uWS50b3AgKyDOlCwga0NvbGxpc2lvblkudywga0NvbGxpc2lvblkuaCAvIDIgLSDOlCk7XG4gIH07XG4gIHByb3RvdHlwZS5ib3R0b21Db2xsaXNpb24gPSBmdW5jdGlvbijOlCl7XG4gICAgcmV0dXJuIG5ldyBSZWN0KHRoaXMueCArIGtDb2xsaXNpb25ZLmxlZnQsIHRoaXMueSArIGtDb2xsaXNpb25ZLnRvcCArIGtDb2xsaXNpb25ZLmggLyAyICsgzpQsIGtDb2xsaXNpb25ZLncsIGtDb2xsaXNpb25ZLmggLyAyICsgzpQpO1xuICB9O1xuICBwcm90b3R5cGUuZGFtYWdlQ29sbGlzaW9uID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmV3IFJlY3QodGhpcy54ICsga0NvbGxpc2lvblgubGVmdCwgdGhpcy55ICsga0NvbGxpc2lvblkudG9wLCBrQ29sbGlzaW9uWC53LCBrQ29sbGlzaW9uWS5oKTtcbiAgfTtcbiAgcHJvdG90eXBlLm9uV2FsbENvbGxpc2lvbiA9IGZ1bmN0aW9uKG1hcCwgcmVjdCwgzrspe1xuICAgIHZhciBpJCwgcmVmJCwgbGVuJCwgdGlsZTtcbiAgICBmb3IgKGkkID0gMCwgbGVuJCA9IChyZWYkID0gbWFwLmdldENvbGxpZGluZ1RpbGVzKHJlY3QpKS5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgICAgdGlsZSA9IHJlZiRbaSRdO1xuICAgICAgaWYgKHRpbGUudHlwZSA9PT0gV0FMTF9USUxFKSB7XG4gICAgICAgIHJldHVybiDOuy5jYWxsKHRoaXMsIHRpbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gzrsuY2FsbCh0aGlzKTtcbiAgfTtcbiAgcHJvdG90eXBlLnN0YXJ0TW92aW5nTGVmdCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5ob3Jpem9udGFsRmFjaW5nID0gTEVGVDtcbiAgICB0aGlzLmFjY2VsZXJhdGlvblggPSAtMTtcbiAgICByZXR1cm4gdGhpcy5pbnRlcmFjdGluZyA9IGZhbHNlO1xuICB9O1xuICBwcm90b3R5cGUuc3RhcnRNb3ZpbmdSaWdodCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5ob3Jpem9udGFsRmFjaW5nID0gUklHSFQ7XG4gICAgdGhpcy5hY2NlbGVyYXRpb25YID0gMTtcbiAgICByZXR1cm4gdGhpcy5pbnRlcmFjdGluZyA9IGZhbHNlO1xuICB9O1xuICBwcm90b3R5cGUuc3RvcE1vdmluZyA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuYWNjZWxlcmF0aW9uWCA9IDA7XG4gIH07XG4gIHByb3RvdHlwZS5zdGFydEp1bXAgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuanVtcEFjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5pbnRlcmFjdGluZyA9IGZhbHNlO1xuICAgIGlmICh0aGlzLm9uR3JvdW5kKSB7XG4gICAgICByZXR1cm4gdGhpcy52ZWxvY2l0eVkgPSAta0p1bXBTcGVlZDtcbiAgICB9XG4gIH07XG4gIHByb3RvdHlwZS5zdG9wSnVtcCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuanVtcEFjdGl2ZSA9IGZhbHNlO1xuICB9O1xuICBwcm90b3R5cGUubG9va1VwID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLnZlcnRpY2FsRmFjaW5nID0gVVA7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJhY3RpbmcgPSBmYWxzZTtcbiAgfTtcbiAgcHJvdG90eXBlLmxvb2tEb3duID0gZnVuY3Rpb24oKXtcbiAgICBpZiAodGhpcy52ZXJ0aWNhbEZhY2luZyA9PT0gRE9XTikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnZlcnRpY2FsRmFjaW5nID0gRE9XTjtcbiAgICByZXR1cm4gdGhpcy5pbnRlcmFjdGluZyA9IHRoaXMub25Hcm91bmQ7XG4gIH07XG4gIHByb3RvdHlwZS5sb29rSG9yaXpvbnRhbCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMudmVydGljYWxGYWNpbmcgPSBIT1JJWk9OVEFMO1xuICB9O1xuICBwcm90b3R5cGUuY2VudGVyWCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMueCArIGtIYWxmVGlsZTtcbiAgfTtcbiAgcHJvdG90eXBlLmNlbnRlclkgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLnkgKyBrSGFsZlRpbGU7XG4gIH07XG4gIHJldHVybiBQbGF5ZXI7XG59KCkpOyIsInZhciBlbG0sIGFwcGx5U3R5bGVzLCBSZWFkZXIsIGhvc3QsIHJlYWRlcnMsIGluc3RhbGwsIGFkZFJlYWRlciwgdXBkYXRlLCByZW1vdmVSZWFkZXIsIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5lbG0gPSBiaW5kJChkb2N1bWVudCwgJ2NyZWF0ZUVsZW1lbnQnKTtcbmFwcGx5U3R5bGVzID0gZnVuY3Rpb24oZWwsIHN0eWxlcyl7XG4gIHZhciBrLCB2LCByZXN1bHRzJCA9IFtdO1xuICBmb3IgKGsgaW4gc3R5bGVzKSB7XG4gICAgdiA9IHN0eWxlc1trXTtcbiAgICByZXN1bHRzJC5wdXNoKGVsLnN0eWxlW2tdID0gdik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHMkO1xufTtcblJlYWRlciA9IChmdW5jdGlvbigpe1xuICBSZWFkZXIuZGlzcGxheU5hbWUgPSAnUmVhZGVyJztcbiAgdmFyIHByb3RvdHlwZSA9IFJlYWRlci5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gUmVhZGVyO1xuICBmdW5jdGlvbiBSZWFkZXIobmFtZSwgbGFiZWxUZXh0LCB2YWx1ZSl7XG4gICAgdmFyIHRoYXQ7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmxhYmVsVGV4dCA9IGxhYmVsVGV4dDtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5kb20gPSBlbG0oJ3RyJyk7XG4gICAgdGhpcy5sYWJlbCA9IGVsbSgndGQnKTtcbiAgICB0aGlzLm91dHB1dCA9IGVsbSgndGQnKTtcbiAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLmxhYmVsKTtcbiAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLm91dHB1dCk7XG4gICAgdGhpcy5sYWJlbC5pbm5lckhUTUwgPSB0aGlzLmxhYmVsVGV4dDtcbiAgICBpZiAodGhhdCA9IHRoaXMudmFsdWUpIHtcbiAgICAgIHRoaXMub3V0cHV0LmlubmVySFRNTCA9IHRoYXQ7XG4gICAgfVxuICB9XG4gIHByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbih2YWx1ZSl7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzLm91dHB1dC5pbm5lckhUTUwgPSB0aGlzLnZhbHVlO1xuICB9O1xuICBwcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuZG9tLnN0eWxlcy5kaXNwbGF5ID0gJ25vbmUnO1xuICB9O1xuICBwcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuZG9tLnN0eWxlcy5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgfTtcbiAgcHJvdG90eXBlLmluc3RhbGwgPSBmdW5jdGlvbihob3N0KXtcbiAgICByZXR1cm4gaG9zdC5hcHBlbmRDaGlsZCh0aGlzLmRvbSk7XG4gIH07XG4gIHByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tKTtcbiAgfTtcbiAgcmV0dXJuIFJlYWRlcjtcbn0oKSk7XG5ob3N0ID0gZWxtKCd0YWJsZScpO1xucmVhZGVycyA9IHt9O1xuYXBwbHlTdHlsZXMoaG9zdCwge1xuICBmb250RmFtaWx5OiAnbW9ub3NwYWNlJyxcbiAgd2lkdGg6ICcxMDAlJyxcbiAgcGFkZGluZ0xlZnQ6ICcxMHB4JyxcbiAgY29sb3I6ICdsaWdodGdyZXknLFxuICBib3JkZXJXaWR0aDogXCIzcHggMXB4XCJcbn0pO1xub3V0JC5pbnN0YWxsID0gaW5zdGFsbCA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGhvc3QpO1xufTtcbm91dCQuYWRkUmVhZGVyID0gYWRkUmVhZGVyID0gZnVuY3Rpb24obmFtZSwgbGFiZWwsIHZhbHVlKXtcbiAgcmVhZGVyc1tuYW1lXSA9IG5ldyBSZWFkZXIobmFtZSwgbGFiZWwsIHZhbHVlKTtcbiAgcmV0dXJuIHJlYWRlcnNbbmFtZV0uaW5zdGFsbChob3N0KTtcbn07XG5vdXQkLnVwZGF0ZSA9IHVwZGF0ZSA9IGZ1bmN0aW9uKHJlYWRlck5hbWUsIHZhbHVlKXtcbiAgdmFyIHJlZiQ7XG4gIHJldHVybiAocmVmJCA9IHJlYWRlcnNbcmVhZGVyTmFtZV0pICE9IG51bGwgPyByZWYkLnVwZGF0ZSh2YWx1ZSkgOiB2b2lkIDg7XG59O1xub3V0JC5yZW1vdmVSZWFkZXIgPSByZW1vdmVSZWFkZXIgPSBmdW5jdGlvbihuYW1lKXtcbiAgdmFyIHJlZiQ7XG4gIHJlYWRlcnNbbmFtZV1bJ2RlbGV0ZSddKCk7XG4gIHJldHVybiByZWYkID0gcmVhZGVyc1tuYW1lXSwgZGVsZXRlIHJlYWRlcnNbbmFtZV0sIHJlZiQ7XG59O1xuZnVuY3Rpb24gYmluZCQob2JqLCBrZXksIHRhcmdldCl7XG4gIHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gKHRhcmdldCB8fCBvYmopW2tleV0uYXBwbHkob2JqLCBhcmd1bWVudHMpIH07XG59IiwidmFyIFJlY3RhbmdsZSwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcbm91dCQuUmVjdGFuZ2xlID0gUmVjdGFuZ2xlID0gKGZ1bmN0aW9uKCl7XG4gIFJlY3RhbmdsZS5kaXNwbGF5TmFtZSA9ICdSZWN0YW5nbGUnO1xuICB2YXIgcHJvdG90eXBlID0gUmVjdGFuZ2xlLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBSZWN0YW5nbGU7XG4gIGZ1bmN0aW9uIFJlY3RhbmdsZSh4LCB5LCB3LCBoLCBtKXtcbiAgICBtID09IG51bGwgJiYgKG0gPSAxKTtcbiAgICB0aGlzLnggPSB4ICogbTtcbiAgICB0aGlzLnkgPSB5ICogbTtcbiAgICB0aGlzLncgPSB3ICogbTtcbiAgICB0aGlzLmggPSBoICogbTtcbiAgICB0aGlzLnRvcCA9IHRoaXMueTtcbiAgICB0aGlzLmxlZnQgPSB0aGlzLng7XG4gICAgdGhpcy5yaWdodCA9IHRoaXMueCArIHRoaXMudztcbiAgICB0aGlzLmJvdHRvbSA9IHRoaXMueSArIHRoaXMuaDtcbiAgfVxuICBwcm90b3R5cGUuY29sbGlkZXNXaXRoID0gZnVuY3Rpb24ob3RoZXIpe1xuICAgIHJldHVybiB0aGlzLnJpZ2h0ID49IG90aGVyLmxlZnQgJiYgdGhpcy5sZWZ0IDw9IG90aGVyLnJpZ2h0ICYmIHRoaXMudG9wIDw9IG90aGVyLmJvdHRvbSAmJiB0aGlzLmJvdHRvbSA+PSBvdGhlci50b3A7XG4gIH07XG4gIHJldHVybiBSZWN0YW5nbGU7XG59KCkpOyIsInZhciByYWYsIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5yYWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5pbXBvcnQkKG91dCQsIHtcbiAgZGVsYXk6IGZ1bmN0aW9uKHRpbWUsIM67KXtcbiAgICByZXR1cm4gcmFmKM67KTtcbiAgfVxufSk7XG5mdW5jdGlvbiBpbXBvcnQkKG9iaiwgc3JjKXtcbiAgdmFyIG93biA9IHt9Lmhhc093blByb3BlcnR5O1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSBpZiAob3duLmNhbGwoc3JjLCBrZXkpKSBvYmpba2V5XSA9IHNyY1trZXldO1xuICByZXR1cm4gb2JqO1xufSIsInZhciBzdGQsIHF1ZXVlLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG5xdWV1ZSA9IFtdO1xuaW1wb3J0JChvdXQkLCB7XG4gIHB1c2hFdmVudDogZnVuY3Rpb24oZXZlbnQpe1xuICAgIHJldHVybiBxdWV1ZS5wdXNoKGV2ZW50KTtcbiAgfSxcbiAgcG9sbEV2ZW50OiBmdW5jdGlvbigpe1xuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBxdWV1ZS5zaGlmdCgpO1xuICAgIH1cbiAgfVxufSk7XG5mdW5jdGlvbiBpbXBvcnQkKG9iaiwgc3JjKXtcbiAgdmFyIG93biA9IHt9Lmhhc093blByb3BlcnR5O1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSBpZiAob3duLmNhbGwoc3JjLCBrZXkpKSBvYmpba2V5XSA9IHNyY1trZXldO1xuICByZXR1cm4gb2JqO1xufSIsInZhciBzdGQsIGRlbGF5LCB0aW1lciwgc2NyZWVuLCBrZXlib2FyZCwgZXZlbnRRdWV1ZSwgUmVjdCwgU3VyZmFjZSwgcmVmJCwgSU5JVF9FVkVSWVRISU5HLCBGVUxMU0NSRUVOLCBpbml0LCBLRVksIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5zdGQgPSByZXF1aXJlKCdzdGQnKTtcbmRlbGF5ID0gcmVxdWlyZSgnLi9kZWxheScpO1xudGltZXIgPSByZXF1aXJlKCcuL3RpbWVyJyk7XG5zY3JlZW4gPSByZXF1aXJlKCcuL3NjcmVlbicpO1xua2V5Ym9hcmQgPSByZXF1aXJlKCcuL2tleWJvYXJkJyk7XG5ldmVudFF1ZXVlID0gcmVxdWlyZSgnLi9ldmVudC1xdWV1ZScpO1xub3V0JC5SZWN0ID0gUmVjdCA9IHJlcXVpcmUoJy4vcmVjdCcpO1xub3V0JC5TdXJmYWNlID0gU3VyZmFjZSA9IHJlcXVpcmUoJy4vc3VyZmFjZScpO1xucmVmJCA9IHN0ZFsnZW51bSddLCBJTklUX0VWRVJZVEhJTkcgPSByZWYkWzBdLCBGVUxMU0NSRUVOID0gcmVmJFsxXTtcbm91dCQuaW5pdCA9IGluaXQgPSBmdW5jdGlvbihtb2RlKXtcbiAgc3RkLmxvZyhcIlNETDo6SW5pdCAtIHdpdGggbW9kZTpcIiwgbW9kZSk7XG4gIHRpbWVyLmluaXQoKTtcbiAgcmV0dXJuIGtleWJvYXJkLmluaXQoKTtcbn07XG5vdXQkLklOSVRfRVZFUllUSElORyA9IElOSVRfRVZFUllUSElORztcbm91dCQuRlVMTFNDUkVFTiA9IEZVTExTQ1JFRU47XG5vdXQkLktFWURPV04gPSBrZXlib2FyZC5LRVlET1dOO1xub3V0JC5LRVlVUCA9IGtleWJvYXJkLktFWVVQO1xub3V0JC5LRVkgPSBLRVkgPSBrZXlib2FyZC5LRVlDT0RFUztcbm91dCQuZGVsYXkgPSBkZWxheS5kZWxheTtcbm91dCQuZ2V0VGlja3MgPSB0aW1lci5nZXRUaWNrcztcbm91dCQucG9sbEV2ZW50ID0gZXZlbnRRdWV1ZS5wb2xsRXZlbnQ7XG5vdXQkLnNldFZpZGVvTW9kZSA9IHNjcmVlbi5zZXRWaWRlb01vZGU7XG5vdXQkLmJsaXRTdXJmYWNlID0gU3VyZmFjZS5ibGl0U3VyZmFjZTtcbm91dCQuc2V0Q29sb3JLZXkgPSBTdXJmYWNlLnNldENvbG9yS2V5O1xub3V0JC5sb2FkSW1hZ2UgPSBTdXJmYWNlLmxvYWRJbWFnZTsiLCJ2YXIgc3RkLCBxdWV1ZSwgcmVmJCwgS0VZRE9XTiwgS0VZVVAsIEtFWUNPREVTLCBtb25pdG9yS2V5cywgaW5pdCwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcbnN0ZCA9IHJlcXVpcmUoJ3N0ZCcpO1xucXVldWUgPSByZXF1aXJlKCcuL2V2ZW50LXF1ZXVlJyk7XG5yZWYkID0gc3RkWydlbnVtJ10sIEtFWURPV04gPSByZWYkWzBdLCBLRVlVUCA9IHJlZiRbMV07XG5vdXQkLktFWUNPREVTID0gS0VZQ09ERVMgPSB7XG4gIEVTQ0FQRTogMjcsXG4gIExFRlQ6IDM3LFxuICBVUDogMzgsXG4gIFJJR0hUOiAzOSxcbiAgRE9XTjogNDAsXG4gIEE6IDY1LFxuICBROiA4MSxcbiAgUzogODMsXG4gIFc6IDg3LFxuICBYOiA4OCxcbiAgWjogOTBcbn07XG5tb25pdG9yS2V5cyA9IGZ1bmN0aW9uKCl7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbihldmVudCl7XG4gICAgdmFyIHdoaWNoO1xuICAgIHdoaWNoID0gZXZlbnQud2hpY2g7XG4gICAgcXVldWUucHVzaEV2ZW50KHtcbiAgICAgIHR5cGU6IEtFWURPV04sXG4gICAgICBrZXk6IHdoaWNoXG4gICAgfSk7XG4gICAgcmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuICByZXR1cm4gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBmdW5jdGlvbihldmVudCl7XG4gICAgdmFyIHdoaWNoO1xuICAgIHdoaWNoID0gZXZlbnQud2hpY2g7XG4gICAgcXVldWUucHVzaEV2ZW50KHtcbiAgICAgIHR5cGU6IEtFWVVQLFxuICAgICAga2V5OiB3aGljaFxuICAgIH0pO1xuICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcbn07XG5vdXQkLmluaXQgPSBpbml0ID0gZnVuY3Rpb24oKXtcbiAgc3RkLmxvZyhcIlNETDo6S2V5Ym9hcmQgLSBNb25pdG9yaW5nIGtleSBpbnB1dFwiKTtcbiAgcmV0dXJuIG1vbml0b3JLZXlzKCk7XG59O1xub3V0JC5LRVlET1dOID0gS0VZRE9XTjtcbm91dCQuS0VZVVAgPSBLRVlVUDsiLCJ2YXIgUmVjdDtcbm1vZHVsZS5leHBvcnRzID0gUmVjdCA9IChmdW5jdGlvbigpe1xuICBSZWN0LmRpc3BsYXlOYW1lID0gJ1JlY3QnO1xuICB2YXIgcHJvdG90eXBlID0gUmVjdC5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gUmVjdDtcbiAgZnVuY3Rpb24gUmVjdCh4LCB5LCB3LCBoKXtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy53ID0gdztcbiAgICB0aGlzLmggPSBoO1xuICB9XG4gIHJldHVybiBSZWN0O1xufSgpKTsiLCJ2YXIgc3RkLCBTdXJmYWNlLCBhcHBseVNjYWxlU3R5bGVzLCBjcmVhdGVOZXdTY3JlZW4sIHNldFZpZGVvTW9kZSwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcbnN0ZCA9IHJlcXVpcmUoJ3N0ZCcpO1xuU3VyZmFjZSA9IHJlcXVpcmUoJy4vc3VyZmFjZScpO1xuYXBwbHlTY2FsZVN0eWxlcyA9IGZ1bmN0aW9uKGNhbnZhcywgc2NhbGVGYWN0b3Ipe1xuICBpZiAoc2NhbGVGYWN0b3IgIT09IDApIHtcbiAgICByZXR1cm4gY2FudmFzLnN0eWxlLndpZHRoID0gY2FudmFzLndpZHRoICogc2NhbGVGYWN0b3IgKyAncHgnO1xuICB9XG59O1xuY3JlYXRlTmV3U2NyZWVuID0gZnVuY3Rpb24odywgaCwgc2NhbGVGYWN0b3Ipe1xuICB2YXIgc2NyZWVuO1xuICBzY3JlZW4gPSBuZXcgU3VyZmFjZShudWxsLCB3LCBoKTtcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JlZW4uY2FudmFzKTtcbiAgYXBwbHlTY2FsZVN0eWxlcyhzY3JlZW4uY2FudmFzLCBzY2FsZUZhY3Rvcik7XG4gIHJldHVybiBzY3JlZW47XG59O1xub3V0JC5zZXRWaWRlb01vZGUgPSBzZXRWaWRlb01vZGUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBzY2FsZUZhY3Rvcil7XG4gIHNjYWxlRmFjdG9yID09IG51bGwgJiYgKHNjYWxlRmFjdG9yID0gMSk7XG4gIHJldHVybiBjcmVhdGVOZXdTY3JlZW4od2lkdGgsIGhlaWdodCwgc2NhbGVGYWN0b3IpO1xufTsiLCJ2YXIgc3RkLCBSZWN0LCBtYWtlVHJhbnNwYXJlbnQsIFN1cmZhY2U7XG5zdGQgPSByZXF1aXJlKCdzdGQnKTtcblJlY3QgPSByZXF1aXJlKCcuL3JlY3QnKTtcbm1ha2VUcmFuc3BhcmVudCA9IGZ1bmN0aW9uKGRhdGEsIGNvbG9yKXtcbiAgdmFyIGNhbnZhcywgY29udGV4dCwgcGl4ZWxzLCBpJCwgdG8kLCBpO1xuICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgY2FudmFzLndpZHRoID0gZGF0YS53aWR0aDtcbiAgY2FudmFzLmhlaWdodCA9IGRhdGEuaGVpZ2h0O1xuICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIGNvbnRleHQuZHJhd0ltYWdlKGRhdGEsIDAsIDApO1xuICBwaXhlbHMgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICBmb3IgKGkkID0gMCwgdG8kID0gcGl4ZWxzLmRhdGEubGVuZ3RoOyBpJCA8PSB0byQ7IGkkICs9IDQpIHtcbiAgICBpID0gaSQ7XG4gICAgaWYgKHBpeGVscy5kYXRhW2kgKyAwXSA9PT0gY29sb3JbMF0gJiYgcGl4ZWxzLmRhdGFbaSArIDFdID09PSBjb2xvclsxXSAmJiBwaXhlbHMuZGF0YVtpICsgMl0gPT09IGNvbG9yWzJdKSB7XG4gICAgICBwaXhlbHMuZGF0YVtpICsgM10gPSAwO1xuICAgIH1cbiAgfVxuICBjb250ZXh0LnB1dEltYWdlRGF0YShwaXhlbHMsIDAsIDApO1xuICByZXR1cm4gY2FudmFzO1xufTtcbm1vZHVsZS5leHBvcnRzID0gU3VyZmFjZSA9IChmdW5jdGlvbigpe1xuICBTdXJmYWNlLmRpc3BsYXlOYW1lID0gJ1N1cmZhY2UnO1xuICB2YXIgcHJvdG90eXBlID0gU3VyZmFjZS5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gU3VyZmFjZTtcbiAgZnVuY3Rpb24gU3VyZmFjZShzcmMsIHdpZHRoLCBoZWlnaHQpe1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHRoaXMuY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgdGhpcy5jb2xvcktleSA9IG51bGw7XG4gICAgdGhpcy5yZXNldENhbnZhc1NpemUoKTtcbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSAncmVkJztcbiAgICB0aGlzLmN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmxvYWRJbWFnZURhdGEoc3JjKTtcbiAgICB9IGVsc2UgaWYgKHNyYyAhPSBudWxsKSB7XG4gICAgICB0aGlzLnNhdmVJbWFnZURhdGEoc3JjKTtcbiAgICB9IGVsc2Uge31cbiAgfVxuICBwcm90b3R5cGUucmVzZXRDYW52YXNTaXplID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICB9O1xuICBwcm90b3R5cGUuaW5oZXJpdFNpemVGcm9tSW1hZ2UgPSBmdW5jdGlvbihkYXRhKXtcbiAgICBpZiAodGhpcy53aWR0aCA9PSBudWxsICYmIHRoaXMuaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgIHRoaXMud2lkdGggPSBkYXRhLm5hdHVyYWxXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gZGF0YS5uYXR1cmFsSGVpZ2h0O1xuICAgICAgcmV0dXJuIHRoaXMucmVzZXRDYW52YXNTaXplKCk7XG4gICAgfVxuICB9O1xuICBwcm90b3R5cGUubG9hZEltYWdlRGF0YSA9IGZ1bmN0aW9uKHBhdGgpe1xuICAgIHZhciBkYXRhLCB0aGlzJCA9IHRoaXM7XG4gICAgZGF0YSA9IG5ldyBJbWFnZTtcbiAgICBkYXRhLm9ubG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICB0aGlzJC5pbmhlcml0U2l6ZUZyb21JbWFnZShkYXRhKTtcbiAgICAgIHJldHVybiB0aGlzJC5zYXZlSW1hZ2VEYXRhKGRhdGEpO1xuICAgIH07XG4gICAgZGF0YS5vbmVycm9yID0gZnVuY3Rpb24oKXtcbiAgICAgIHN0ZC5sb2coXCJDYW50IGxvYWQ6XCIsIHBhdGgpO1xuICAgICAgcmV0dXJuIHRoaXMkLmN0eC5maWxsUmVjdCgwLCAwLCB0aGlzJC53aWR0aCwgdGhpcyQuaGVpZ2h0KTtcbiAgICB9O1xuICAgIHJldHVybiBkYXRhLnNyYyA9IHBhdGg7XG4gIH07XG4gIHByb3RvdHlwZS5zYXZlSW1hZ2VEYXRhID0gZnVuY3Rpb24oZGF0YSl7XG4gICAgdGhpcy5kYXRhID0gdGhpcy5jb2xvcktleSA/IG1ha2VUcmFuc3BhcmVudChkYXRhLCB0aGlzLmNvbG9yS2V5KSA6IGRhdGE7XG4gICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICByZXR1cm4gdGhpcy5jdHguZHJhd0ltYWdlKHRoaXMuZGF0YSwgMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICB9O1xuICBwcm90b3R5cGUuc2V0Q29sb3JLZXkgPSBmdW5jdGlvbihjb2xvcil7XG4gICAgdGhpcy5jb2xvcktleSA9IGNvbG9yO1xuICAgIGlmICh0aGlzLnJlYWR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zYXZlSW1hZ2VEYXRhKHRoaXMuZGF0YSk7XG4gICAgfVxuICB9O1xuICBwcm90b3R5cGUuZHJhd1JlY3QgPSBmdW5jdGlvbihyZWN0LCBjb2xvcil7XG4gICAgY29sb3IgPT0gbnVsbCAmJiAoY29sb3IgPSAnYmxhY2snKTtcbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICByZXR1cm4gdGhpcy5jdHguZmlsbFJlY3QocmVjdC54LCByZWN0LnksIHJlY3QudywgcmVjdC5oKTtcbiAgfTtcbiAgcHJvdG90eXBlLmRyYXdCb3ggPSBmdW5jdGlvbihyZWN0LCBjb2xvcil7XG4gICAgY29sb3IgPT0gbnVsbCAmJiAoY29sb3IgPSAnYmxhY2snKTtcbiAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgIHRoaXMuY3R4Lm1vdmVUbygwLjUgKyByZWN0LngsIDAuNSArIHJlY3QueSk7XG4gICAgdGhpcy5jdHgubGluZVRvKDAuNSArIHJlY3QueCwgLTAuNSArIHJlY3QueSArIHJlY3QuaCk7XG4gICAgdGhpcy5jdHgubGluZVRvKC0wLjUgKyByZWN0LnggKyByZWN0LncsIC0wLjUgKyByZWN0LnkgKyByZWN0LmgpO1xuICAgIHRoaXMuY3R4LmxpbmVUbygtMC41ICsgcmVjdC54ICsgcmVjdC53LCAwLjUgKyByZWN0LnkpO1xuICAgIHRoaXMuY3R4LmxpbmVUbygwLjUgKyByZWN0LngsIDAuNSArIHJlY3QueSk7XG4gICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gICAgcmV0dXJuIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xuICB9O1xuICBwcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICB9O1xuICBTdXJmYWNlLnNldENvbG9yS2V5ID0gZnVuY3Rpb24oc3VyZmFjZSwgY29sb3Ipe1xuICAgIHJldHVybiBzdXJmYWNlLnNldENvbG9yS2V5KGNvbG9yKTtcbiAgfTtcbiAgU3VyZmFjZS5ibGl0U3VyZmFjZSA9IGZ1bmN0aW9uKHNvdXJjZSwgc3JjUmVjdCwgZGVzdCwgZGVzdFJlY3Qpe1xuICAgIGlmIChzcmNSZWN0KSB7XG4gICAgICByZXR1cm4gZGVzdC5jdHguZHJhd0ltYWdlKHNvdXJjZS5jYW52YXMsIHNyY1JlY3QueCwgc3JjUmVjdC55LCBzcmNSZWN0LncsIHNyY1JlY3QuaCwgZGVzdFJlY3QueCwgZGVzdFJlY3QueSwgZGVzdFJlY3QudywgZGVzdFJlY3QuaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkZXN0LmN0eC5kcmF3SW1hZ2Uoc291cmNlLmNhbnZhcywgZGVzdFJlY3QueCwgZGVzdFJlY3QueSwgZGVzdFJlY3QudywgZGVzdFJlY3QuaCk7XG4gICAgfVxuICB9O1xuICBTdXJmYWNlLmxvYWRJbWFnZSA9IGZ1bmN0aW9uKHBhdGgpe1xuICAgIHJldHVybiBuZXcgU3VyZmFjZShwYXRoKTtcbiAgfTtcbiAgcmV0dXJuIFN1cmZhY2U7XG59KCkpOyIsInZhciBzdGFydFRpbWUsIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5zdGFydFRpbWUgPSAwO1xuaW1wb3J0JChvdXQkLCB7XG4gIGluaXQ6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gIH0sXG4gIGdldFRpY2tzOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICB9XG59KTtcbmZ1bmN0aW9uIGltcG9ydCQob2JqLCBzcmMpe1xuICB2YXIgb3duID0ge30uaGFzT3duUHJvcGVydHk7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIGlmIChvd24uY2FsbChzcmMsIGtleSkpIG9ialtrZXldID0gc3JjW2tleV07XG4gIHJldHVybiBvYmo7XG59IiwidmFyIFNETCwgc3RkLCB1bml0cywgZGl2LCBrSGFsZlRpbGUsIHRpbGVUb1B4LCBnYW1lVG9QeCwgUmVjdCwgU3ByaXRlLCBBbmltYXRlZFNwcml0ZSwgTnVtYmVyU3ByaXRlLCBWYXJ5aW5nV2lkdGhTcHJpdGUsIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5TREwgPSByZXF1aXJlKCdTREwnKTtcbnN0ZCA9IHJlcXVpcmUoJ3N0ZCcpO1xudW5pdHMgPSByZXF1aXJlKCcuL3VuaXRzJyk7XG5kaXYgPSBzdGQuZGl2O1xua0hhbGZUaWxlID0gdW5pdHMua0hhbGZUaWxlLCB0aWxlVG9QeCA9IHVuaXRzLnRpbGVUb1B4LCBnYW1lVG9QeCA9IHVuaXRzLmdhbWVUb1B4O1xuUmVjdCA9IHJlcXVpcmUoJy4vcmVjdGFuZ2xlJykuUmVjdGFuZ2xlO1xub3V0JC5TcHJpdGUgPSBTcHJpdGUgPSAoZnVuY3Rpb24oKXtcbiAgU3ByaXRlLmRpc3BsYXlOYW1lID0gJ1Nwcml0ZSc7XG4gIHZhciBwcm90b3R5cGUgPSBTcHJpdGUucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IFNwcml0ZTtcbiAgZnVuY3Rpb24gU3ByaXRlKGdyYXBoaWNzLCBwYXRoLCBzb3VyY2VYLCBzb3VyY2VZLCB3aWR0aCwgaGVpZ2h0KXtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5zb3VyY2VSZWN0ID0gbmV3IFNETC5SZWN0KHNvdXJjZVgsIHNvdXJjZVksIHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuc3ByaXRlU2hlZXQgPSBncmFwaGljcy5sb2FkSW1hZ2UocGF0aCwgdHJ1ZSk7XG4gIH1cbiAgcHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7fTtcbiAgcHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihncmFwaGljcywgeCwgeSl7XG4gICAgdmFyIGRlc3RSZWN0O1xuICAgIGRlc3RSZWN0ID0gbmV3IFNETC5SZWN0KHVuaXRzLmdhbWVUb1B4KHgpLCB1bml0cy5nYW1lVG9QeCh5KSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIHJldHVybiBncmFwaGljcy5ibGl0U3VyZmFjZSh0aGlzLnNwcml0ZVNoZWV0LCB0aGlzLnNvdXJjZVJlY3QsIGRlc3RSZWN0KTtcbiAgfTtcbiAgcmV0dXJuIFNwcml0ZTtcbn0oKSk7XG5vdXQkLkFuaW1hdGVkU3ByaXRlID0gQW5pbWF0ZWRTcHJpdGUgPSAoZnVuY3Rpb24oc3VwZXJjbGFzcyl7XG4gIHZhciBwcm90b3R5cGUgPSBleHRlbmQkKChpbXBvcnQkKEFuaW1hdGVkU3ByaXRlLCBzdXBlcmNsYXNzKS5kaXNwbGF5TmFtZSA9ICdBbmltYXRlZFNwcml0ZScsIEFuaW1hdGVkU3ByaXRlKSwgc3VwZXJjbGFzcykucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IEFuaW1hdGVkU3ByaXRlO1xuICBmdW5jdGlvbiBBbmltYXRlZFNwcml0ZShncmFwaGljcywgcGF0aCwgc291cmNlWCwgc291cmNlWSwgd2lkdGgsIGhlaWdodCwgZnBzLCBudW1GcmFtZXMpe1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLmZwcyA9IGZwcztcbiAgICB0aGlzLm51bUZyYW1lcyA9IG51bUZyYW1lcztcbiAgICBBbmltYXRlZFNwcml0ZS5zdXBlcmNsYXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5mcmFtZVRpbWUgPSAxMDAwIC8gdGhpcy5mcHM7XG4gICAgdGhpcy5jdXJyZW50RnJhbWUgPSAwO1xuICAgIHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuICB9XG4gIHByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihlbGFwc2VkVGltZSl7XG4gICAgdGhpcy5lbGFwc2VkVGltZSArPSBlbGFwc2VkVGltZTtcbiAgICBpZiAodGhpcy5lbGFwc2VkVGltZSA+IHRoaXMuZnJhbWVUaW1lKSB7XG4gICAgICB0aGlzLmN1cnJlbnRGcmFtZSArPSAxO1xuICAgICAgdGhpcy5lbGFwc2VkVGltZSA9IDA7XG4gICAgICBpZiAodGhpcy5jdXJyZW50RnJhbWUgPCB0aGlzLm51bUZyYW1lcykge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VSZWN0LnggKz0gdGhpcy5zb3VyY2VSZWN0Lnc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNvdXJjZVJlY3QueCAtPSB0aGlzLnNvdXJjZVJlY3QudyAqICh0aGlzLm51bUZyYW1lcyAtIDEpO1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50RnJhbWUgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIEFuaW1hdGVkU3ByaXRlO1xufShTcHJpdGUpKTtcbm91dCQuTnVtYmVyU3ByaXRlID0gTnVtYmVyU3ByaXRlID0gKGZ1bmN0aW9uKCl7XG4gIE51bWJlclNwcml0ZS5kaXNwbGF5TmFtZSA9ICdOdW1iZXJTcHJpdGUnO1xuICB2YXIga0RpZ2l0U3JjWSwga0RpZ2l0U3JjV2lkdGgsIGtEaWdpdFNyY0hlaWdodCwga09wUGx1c1NyY1gsIGtPcE1pbnVzU3JjWCwga09wU3JjWSwga0RpZ2l0U2l6ZSwga1JhZGl4LCByZWYkLCBXSElURSwgUkVELCBQTFVTLCBNSU5VUywgTk9ORSwgcHJvdG90eXBlID0gTnVtYmVyU3ByaXRlLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBOdW1iZXJTcHJpdGU7XG4gIGtEaWdpdFNyY1kgPSB0aWxlVG9QeCgzLjUpO1xuICBrRGlnaXRTcmNXaWR0aCA9IHRpbGVUb1B4KDAuNSk7XG4gIGtEaWdpdFNyY0hlaWdodCA9IHRpbGVUb1B4KDAuNSk7XG4gIGtPcFBsdXNTcmNYID0gdGlsZVRvUHgoMik7XG4gIGtPcE1pbnVzU3JjWCA9IHRpbGVUb1B4KDIuNSk7XG4gIGtPcFNyY1kgPSB0aWxlVG9QeCgzKTtcbiAga0RpZ2l0U2l6ZSA9IHVuaXRzLmtIYWxmVGlsZTtcbiAga1JhZGl4ID0gMTA7XG4gIHJlZiQgPSBzdGRbJ2VudW0nXSwgV0hJVEUgPSByZWYkWzBdLCBSRUQgPSByZWYkWzFdO1xuICByZWYkID0gc3RkWydlbnVtJ10sIFBMVVMgPSByZWYkWzBdLCBNSU5VUyA9IHJlZiRbMV0sIE5PTkUgPSByZWYkWzJdO1xuICBmdW5jdGlvbiBOdW1iZXJTcHJpdGUoZ3JhcGhpY3MsIG51bSwgbGVuLCBjb2xvciwgb3Ape1xuICAgIHZhciBzcmNZO1xuICAgIHRoaXMubnVtID0gbnVtO1xuICAgIHRoaXMubGVuID0gbGVuO1xuICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLm9wID0gb3A7XG4gICAgdGhpcy5kaWdpdHMgPSBOdW1iZXJTcHJpdGUuc2VwZXJhdGVEaWdpdHModGhpcy5udW0pO1xuICAgIHRoaXMubnVtRGlnaXRzID0gdGhpcy5kaWdpdHMubGVuZ3RoO1xuICAgIHRoaXMucGFkZGluZyA9IHRoaXMubGVuID09PSAwXG4gICAgICA/IDBcbiAgICAgIDoga0RpZ2l0U2l6ZSAqICh0aGlzLmxlbiAtIHRoaXMubnVtRGlnaXRzKTtcbiAgICBzcmNZID0gdGhpcy5jb2xvciA9PT0gV0hJVEVcbiAgICAgID8ga0RpZ2l0U3JjWVxuICAgICAgOiBrRGlnaXRTcmNZICsgZ2FtZVRvUHgoa0hhbGZUaWxlKTtcbiAgICB0aGlzLmdseXBocyA9IHRoaXMuZGlnaXRzLm1hcChmdW5jdGlvbihpdCl7XG4gICAgICByZXR1cm4gbmV3IFNwcml0ZShncmFwaGljcywgJ2RhdGEvMTZ4MTYvVGV4dEJveC5ibXAnLCB0aWxlVG9QeCgwLjUgKiBpdCksIHNyY1ksIGtEaWdpdFNyY1dpZHRoLCBrRGlnaXRTcmNIZWlnaHQpO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLm9wID09PSBQTFVTKSB7XG4gICAgICB0aGlzLmdseXBocy5wdXNoKG5ldyBTcHJpdGUoZ3JhcGhpY3MsICdkYXRhLzE2eDE2L1RleHRCb3guYm1wJywga09wUGx1c1NyY1gsIGtPcFNyY1ksIGtEaWdpdFNyY1dpZHRoLCBrRGlnaXRTcmNIZWlnaHQpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3AgPT09IE1JTlVTKSB7XG4gICAgICB0aGlzLmdseXBocy5wdXNoKG5ldyBTcHJpdGUoZ3JhcGhpY3MsICdkYXRhLzE2eDE2L1RleHRCb3guYm1wJywga09wTWludXNTcmNYLCBrT3BTcmNZLCBrRGlnaXRTcmNXaWR0aCwga0RpZ2l0U3JjSGVpZ2h0KSk7XG4gICAgfVxuICAgIHRoaXMud2lkdGggPSBrSGFsZlRpbGUgKiB0aGlzLmdseXBocy5sZW5ndGg7XG4gICAgdGhpcy5oZWlnaHQgPSBrSGFsZlRpbGU7XG4gIH1cbiAgcHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihncmFwaGljcywgeCwgeSl7XG4gICAgdmFyIGkkLCByZWYkLCBsZW4kLCBpLCBnbHlwaCwgb2Zmc2V0LCByZXN1bHRzJCA9IFtdO1xuICAgIGZvciAoaSQgPSAwLCBsZW4kID0gKHJlZiQgPSB0aGlzLmdseXBocykubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICAgIGkgPSBpJDtcbiAgICAgIGdseXBoID0gcmVmJFtpJF07XG4gICAgICBvZmZzZXQgPSBrRGlnaXRTaXplICogKHRoaXMuZ2x5cGhzLmxlbmd0aCAtIDEgLSBpKTtcbiAgICAgIHJlc3VsdHMkLnB1c2goZ2x5cGguZHJhdyhncmFwaGljcywgeCArIHRoaXMucGFkZGluZyArIG9mZnNldCwgeSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cyQ7XG4gIH07XG4gIHByb3RvdHlwZS5kcmF3Q2VudGVyZWQgPSBmdW5jdGlvbihncmFwaGljcywgeCwgeSl7XG4gICAgcmV0dXJuIHRoaXMuZHJhdyhncmFwaGljcywgeCAtIHRoaXMud2lkdGggLyAyLCB5IC0gdGhpcy5oZWlnaHQgLyAyKTtcbiAgfTtcbiAgTnVtYmVyU3ByaXRlLnNlcGVyYXRlRGlnaXRzID0gZnVuY3Rpb24obnVtKXtcbiAgICB2YXIgZGlnaXQsIHJlc3VsdHMkID0gW107XG4gICAgaWYgKG51bSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKG51bSAhPT0gMCkge1xuICAgICAgICBkaWdpdCA9IG51bSAlIGtSYWRpeDtcbiAgICAgICAgbnVtID0gZGl2KG51bSwga1JhZGl4KTtcbiAgICAgICAgcmVzdWx0cyQucHVzaChkaWdpdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cyQ7XG4gICAgfVxuICB9O1xuICBOdW1iZXJTcHJpdGUuSFVETnVtYmVyID0gZnVuY3Rpb24oZ3JhcGhpY3MsIG51bSwgbGVuKXtcbiAgICB0aGlzLm51bSA9IG51bTtcbiAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICByZXR1cm4gbmV3IE51bWJlclNwcml0ZShncmFwaGljcywgdGhpcy5udW0sIHRoaXMubGVuLCBXSElURSwgTk9ORSk7XG4gIH07XG4gIE51bWJlclNwcml0ZS5EYW1hZ2VOdW1iZXIgPSBmdW5jdGlvbihncmFwaGljcywgbnVtKXtcbiAgICB0aGlzLm51bSA9IG51bTtcbiAgICByZXR1cm4gbmV3IE51bWJlclNwcml0ZShncmFwaGljcywgdGhpcy5udW0sIDAsIFJFRCwgTUlOVVMpO1xuICB9O1xuICBOdW1iZXJTcHJpdGUuRXhwZXJpZW5jZU51bWJlciA9IGZ1bmN0aW9uKGdyYXBoaWNzLCBudW0pe1xuICAgIHRoaXMubnVtID0gbnVtO1xuICAgIHJldHVybiBuZXcgTnVtYmVyU3ByaXRlKGdyYXBoaWNzLCB0aGlzLm51bSwgMCwgV0hJVEUsIFBMVVMpO1xuICB9O1xuICByZXR1cm4gTnVtYmVyU3ByaXRlO1xufSgpKTtcbm91dCQuVmFyeWluZ1dpZHRoU3ByaXRlID0gVmFyeWluZ1dpZHRoU3ByaXRlID0gKGZ1bmN0aW9uKHN1cGVyY2xhc3Mpe1xuICB2YXIgcHJvdG90eXBlID0gZXh0ZW5kJCgoaW1wb3J0JChWYXJ5aW5nV2lkdGhTcHJpdGUsIHN1cGVyY2xhc3MpLmRpc3BsYXlOYW1lID0gJ1ZhcnlpbmdXaWR0aFNwcml0ZScsIFZhcnlpbmdXaWR0aFNwcml0ZSksIHN1cGVyY2xhc3MpLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBWYXJ5aW5nV2lkdGhTcHJpdGU7XG4gIGZ1bmN0aW9uIFZhcnlpbmdXaWR0aFNwcml0ZShncmFwaGljcywgcGF0aCwgc291cmNlWCwgc291cmNlWSwgaW5pdGlhbFdpZHRoLCBoZWlnaHQpe1xuICAgIHRoaXMuaW5pdGlhbFdpZHRoID0gaW5pdGlhbFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIFZhcnlpbmdXaWR0aFNwcml0ZS5zdXBlcmNsYXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy53aWR0aCA9IHRoaXMuaW5pdGlhbFdpZHRoO1xuICB9XG4gIHByb3RvdHlwZS5zZXRXaWR0aCA9IGZ1bmN0aW9uKHdpZHRoKXtcbiAgICByZXR1cm4gdGhpcy53aWR0aCA9IHdpZHRoO1xuICB9O1xuICByZXR1cm4gVmFyeWluZ1dpZHRoU3ByaXRlO1xufShTcHJpdGUpKTtcbmZ1bmN0aW9uIGV4dGVuZCQoc3ViLCBzdXApe1xuICBmdW5jdGlvbiBmdW4oKXt9IGZ1bi5wcm90b3R5cGUgPSAoc3ViLnN1cGVyY2xhc3MgPSBzdXApLnByb3RvdHlwZTtcbiAgKHN1Yi5wcm90b3R5cGUgPSBuZXcgZnVuKS5jb25zdHJ1Y3RvciA9IHN1YjtcbiAgaWYgKHR5cGVvZiBzdXAuZXh0ZW5kZWQgPT0gJ2Z1bmN0aW9uJykgc3VwLmV4dGVuZGVkKHN1Yik7XG4gIHJldHVybiBzdWI7XG59XG5mdW5jdGlvbiBpbXBvcnQkKG9iaiwgc3JjKXtcbiAgdmFyIG93biA9IHt9Lmhhc093blByb3BlcnR5O1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSBpZiAob3duLmNhbGwoc3JjLCBrZXkpKSBvYmpba2V5XSA9IHNyY1trZXldO1xuICByZXR1cm4gb2JqO1xufSIsInZhciBzdGQsIHVuaXRzLCByZWYkLCBTVEFORElORywgV0FMS0lORywgSlVNUElORywgRkFMTElORywgSU5URVJBQ1RJTkcsIExFRlQsIFJJR0hULCBVUCwgRE9XTiwgSE9SSVpPTlRBTCwga2V5LCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzLCBzbGljZSQgPSBbXS5zbGljZTtcbnN0ZCA9IHJlcXVpcmUoJ3N0ZCcpO1xudW5pdHMgPSByZXF1aXJlKCcuL3VuaXRzJyk7XG5yZWYkID0gWydTJywgJ1cnLCAnSicsICdGJywgJ0knXSwgU1RBTkRJTkcgPSByZWYkWzBdLCBXQUxLSU5HID0gcmVmJFsxXSwgSlVNUElORyA9IHJlZiRbMl0sIEZBTExJTkcgPSByZWYkWzNdLCBJTlRFUkFDVElORyA9IHJlZiRbNF07XG5yZWYkID0gWydMJywgJ1InXSwgTEVGVCA9IHJlZiRbMF0sIFJJR0hUID0gcmVmJFsxXTtcbnJlZiQgPSBbJ1UnLCAnRCcsICdIJ10sIFVQID0gcmVmJFswXSwgRE9XTiA9IHJlZiRbMV0sIEhPUklaT05UQUwgPSByZWYkWzJdO1xub3V0JC5rZXkgPSBrZXkgPSBmdW5jdGlvbigpe1xuICB2YXIgYXJncztcbiAgYXJncyA9IHNsaWNlJC5jYWxsKGFyZ3VtZW50cyk7XG4gIHJldHVybiBhcmdzLmpvaW4oJy0nKTtcbn07XG5yZWYkID0gb3V0JDtcbnJlZiQuU1RBTkRJTkcgPSBTVEFORElORztcbnJlZiQuV0FMS0lORyA9IFdBTEtJTkc7XG5yZWYkLkpVTVBJTkcgPSBKVU1QSU5HO1xucmVmJC5GQUxMSU5HID0gRkFMTElORztcbnJlZiQuSU5URVJBQ1RJTkcgPSBJTlRFUkFDVElORztcbnJlZiQuTEVGVCA9IExFRlQ7XG5yZWYkLlJJR0hUID0gUklHSFQ7XG5yZWYkLlVQID0gVVA7XG5yZWYkLkRPV04gPSBET1dOO1xucmVmJC5IT1JJWk9OVEFMID0gSE9SSVpPTlRBTDsiLCJ2YXIgcmVmJCwgaWQsIG1hcCwgZmlsdGVyLCBhbnksIGRpdiwgbG9nLCBpbmZvLCBvYmpNYXAsIGZsaXAsIGRlbGF5LCByb3VuZCwgZmxvb3IsIGFicywgbWF4LCBtaW4sIHNpbiwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcbnJlZiQgPSByZXF1aXJlKCdwcmVsdWRlLWxzJyksIGlkID0gcmVmJC5pZCwgbWFwID0gcmVmJC5tYXAsIGZpbHRlciA9IHJlZiQuZmlsdGVyLCBhbnkgPSByZWYkLmFueSwgZGl2ID0gcmVmJC5kaXY7XG5vdXQkLmxvZyA9IGxvZyA9IGZ1bmN0aW9uKCl7XG4gIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gIHJldHVybiBhcmd1bWVudHNbMF07XG59O1xub3V0JC5pbmZvID0gaW5mbyA9IGZ1bmN0aW9uKCl7XG4gIGNvbnNvbGUuaW5mby5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICByZXR1cm4gYXJndW1lbnRzWzBdO1xufTtcbm91dCQub2JqTWFwID0gb2JqTWFwID0gY3VycnkkKGZ1bmN0aW9uKM67LCBvKXtcbiAgdmFyIGssIHYsIHJlc3VsdHMkID0gW107XG4gIGZvciAoayBpbiBvKSB7XG4gICAgdiA9IG9ba107XG4gICAgcmVzdWx0cyQucHVzaCjOuyhrLCB2KSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHMkO1xufSk7XG5vdXQkLmZsaXAgPSBmbGlwID0gZnVuY3Rpb24ozrspe1xuICByZXR1cm4gY3VycnkkKGZ1bmN0aW9uKGEsIGIpe1xuICAgIHJldHVybiDOuyhiLCBhKTtcbiAgfSk7XG59O1xub3V0JC5kZWxheSA9IGRlbGF5ID0gZmxpcChzZXRUaW1lb3V0KTtcbm91dCQucm91bmQgPSByb3VuZCA9IE1hdGgucm91bmQ7XG5vdXQkLmZsb29yID0gZmxvb3IgPSBNYXRoLmZsb29yO1xub3V0JC5hYnMgPSBhYnMgPSBNYXRoLmFicztcbm91dCQubWF4ID0gbWF4ID0gTWF0aC5tYXg7XG5vdXQkLm1pbiA9IG1pbiA9IE1hdGgubWluO1xub3V0JC5zaW4gPSBzaW4gPSBNYXRoLnNpbjtcbnJlZiQgPSBvdXQkO1xucmVmJC5pZCA9IGlkO1xucmVmJC5hbnkgPSBhbnk7XG5yZWYkLm1hcCA9IG1hcDtcbnJlZiQuZmlsdGVyID0gZmlsdGVyO1xucmVmJC5kaXYgPSBkaXY7XG5yZWYkWydlbnVtJ10gPSBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwXTtcbmZ1bmN0aW9uIGN1cnJ5JChmLCBib3VuZCl7XG4gIHZhciBjb250ZXh0LFxuICBfY3VycnkgPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgcmV0dXJuIGYubGVuZ3RoID4gMSA/IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgcGFyYW1zID0gYXJncyA/IGFyZ3MuY29uY2F0KCkgOiBbXTtcbiAgICAgIGNvbnRleHQgPSBib3VuZCA/IGNvbnRleHQgfHwgdGhpcyA6IHRoaXM7XG4gICAgICByZXR1cm4gcGFyYW1zLnB1c2guYXBwbHkocGFyYW1zLCBhcmd1bWVudHMpIDxcbiAgICAgICAgICBmLmxlbmd0aCAmJiBhcmd1bWVudHMubGVuZ3RoID9cbiAgICAgICAgX2N1cnJ5LmNhbGwoY29udGV4dCwgcGFyYW1zKSA6IGYuYXBwbHkoY29udGV4dCwgcGFyYW1zKTtcbiAgICB9IDogZjtcbiAgfTtcbiAgcmV0dXJuIF9jdXJyeSgpO1xufSIsInZhciBzdGQsIHVuaXRzLCBUaW1lciwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcbnN0ZCA9IHJlcXVpcmUoJ3N0ZCcpO1xudW5pdHMgPSByZXF1aXJlKCcuL3VuaXRzJyk7XG5vdXQkLlRpbWVyID0gVGltZXIgPSAoZnVuY3Rpb24oKXtcbiAgVGltZXIuZGlzcGxheU5hbWUgPSAnVGltZXInO1xuICB2YXIgYWxsVGltZXJzLCBwcm90b3R5cGUgPSBUaW1lci5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gVGltZXI7XG4gIGFsbFRpbWVycyA9IFtdO1xuICBmdW5jdGlvbiBUaW1lcihleHBpcmF0aW9uVGltZSl7XG4gICAgdGhpcy5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgIHRoaXMuY3VycmVudFRpbWUgPSB0aGlzLmV4cGlyYXRpb25UaW1lO1xuICAgIGFsbFRpbWVycy5wdXNoKHRoaXMpO1xuICB9XG4gIHByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihlbGFwc2VkVGltZSl7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFRpbWUgKz0gZWxhcHNlZFRpbWU7XG4gIH07XG4gIHByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFRpbWUgPSAwO1xuICB9O1xuICBwcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRUaW1lIDwgdGhpcy5leHBpcmF0aW9uVGltZTtcbiAgfTtcbiAgcHJvdG90eXBlLmlzRXhwaXJlZCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuICF0aGlzLmlzQWN0aXZlKCk7XG4gIH07XG4gIFRpbWVyLnVwZGF0ZUFsbCA9IGZ1bmN0aW9uKGVsYXBzZWRUaW1lKXtcbiAgICByZXR1cm4gYWxsVGltZXJzLm1hcChmdW5jdGlvbihpdCl7XG4gICAgICByZXR1cm4gaXQudXBkYXRlKGVsYXBzZWRUaW1lKTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIFRpbWVyO1xufSgpKTsiLCJ2YXIgc3RkLCBjb25maWcsIGtQaSwga0dhbWVVbml0c1BlclRpbGUsIGtQaXhlbFNjYWxlRmFjdG9yLCBHYW1lLCBQaXhlbCwgVGlsZSwgRGVncmVlcywgRlBTLCBNUywgVmVsb2NpdHksIEFjY2VsZXJhdGlvbiwgSFAsIGdhbWVUb1B4LCBnYW1lVG9UaWxlLCB0aWxlVG9HYW1lLCB0aWxlVG9QeCwgZGVnVG9SYWQsIHB4VG9HYW1lLCBrT25lVGlsZSwga0hhbGZUaWxlLCBrVGlsZVB4LCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG5jb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xua1BpID0gTWF0aC5QSTtcbmtHYW1lVW5pdHNQZXJUaWxlID0gMzI7XG5rUGl4ZWxTY2FsZUZhY3RvciA9IGtHYW1lVW5pdHNQZXJUaWxlIC8gY29uZmlnLmtHcmFwaGljc1F1YWxpdHk7XG5vdXQkLkdhbWUgPSBHYW1lID0gc3RkLmlkO1xub3V0JC5QaXhlbCA9IFBpeGVsID0gc3RkLmZsb29yO1xub3V0JC5UaWxlID0gVGlsZSA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiBzdGQuYWJzKHN0ZC5mbG9vci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbn07XG5vdXQkLkRlZ3JlZXMgPSBEZWdyZWVzID0gc3RkLmlkO1xub3V0JC5GUFMgPSBGUFMgPSBzdGQuaWQ7XG5vdXQkLk1TID0gTVMgPSBzdGQuaWQ7XG5vdXQkLlZlbG9jaXR5ID0gVmVsb2NpdHkgPSBzdGQuaWQ7XG5vdXQkLkFjY2VsZXJhdGlvbiA9IEFjY2VsZXJhdGlvbiA9IHN0ZC5pZDtcbm91dCQuSFAgPSBIUCA9IHN0ZC5mbG9vcjtcbm91dCQuZ2FtZVRvUHggPSBnYW1lVG9QeCA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiBQaXhlbCgoZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiBpdCAvIGtQaXhlbFNjYWxlRmFjdG9yO1xuICB9KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbn07XG5vdXQkLmdhbWVUb1RpbGUgPSBnYW1lVG9UaWxlID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIFRpbGUoKGZ1bmN0aW9uKGl0KXtcbiAgICByZXR1cm4gaXQgLyBrR2FtZVVuaXRzUGVyVGlsZTtcbiAgfSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG59O1xub3V0JC50aWxlVG9HYW1lID0gdGlsZVRvR2FtZSA9IChmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCAqIGtHYW1lVW5pdHNQZXJUaWxlO1xufSk7XG5vdXQkLnRpbGVUb1B4ID0gdGlsZVRvUHggPSBmdW5jdGlvbigpe1xuICByZXR1cm4gZ2FtZVRvUHgodGlsZVRvR2FtZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbn07XG5vdXQkLmRlZ1RvUmFkID0gZGVnVG9SYWQgPSAoZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgKiBrUGkgLyAxODA7XG59KTtcbm91dCQucHhUb0dhbWUgPSBweFRvR2FtZSA9IChmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCAqIGtQaXhlbFNjYWxlRmFjdG9yO1xufSk7XG5vdXQkLmtPbmVUaWxlID0ga09uZVRpbGUgPSB0aWxlVG9HYW1lKDEpO1xub3V0JC5rSGFsZlRpbGUgPSBrSGFsZlRpbGUgPSB0aWxlVG9HYW1lKDAuNSk7XG5vdXQkLmtUaWxlUHggPSBrVGlsZVB4ID0gdGlsZVRvUHgoMSk7Il19
