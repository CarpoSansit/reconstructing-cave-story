(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var readout, Game;
readout = require('./readout');
Game = require('./game');
readout.install();
Game.start();
},{"./game":18,"./readout":35}],2:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var apply, curry, flip, fix, over;
apply = curry$(function(f, list){
  return f.apply(null, list);
});
curry = function(f){
  return curry$(f);
};
flip = curry$(function(f, x, y){
  return f(y, x);
});
fix = function(f){
  return function(g){
    return function(){
      return f(g(g)).apply(null, arguments);
    };
  }(function(g){
    return function(){
      return f(g(g)).apply(null, arguments);
    };
  });
};
over = curry$(function(f, g, x, y){
  return f(g(x), g(y));
});
module.exports = {
  curry: curry,
  flip: flip,
  fix: fix,
  apply: apply,
  over: over
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{}],3:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var each, map, compact, filter, reject, partition, find, head, first, tail, last, initial, empty, reverse, unique, uniqueBy, fold, foldl, fold1, foldl1, foldr, foldr1, unfoldr, concat, concatMap, flatten, difference, intersection, union, countBy, groupBy, andList, orList, any, all, sort, sortWith, sortBy, sum, product, mean, average, maximum, minimum, maximumBy, minimumBy, scan, scanl, scan1, scanl1, scanr, scanr1, slice, take, drop, splitAt, takeWhile, dropWhile, span, breakList, zip, zipWith, zipAll, zipAllWith, at, elemIndex, elemIndices, findIndex, findIndices, toString$ = {}.toString, slice$ = [].slice;
each = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    f(x);
  }
  return xs;
});
map = curry$(function(f, xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    results$.push(f(x));
  }
  return results$;
});
compact = function(xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (x) {
      results$.push(x);
    }
  }
  return results$;
};
filter = curry$(function(f, xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      results$.push(x);
    }
  }
  return results$;
});
reject = curry$(function(f, xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!f(x)) {
      results$.push(x);
    }
  }
  return results$;
});
partition = curry$(function(f, xs){
  var passed, failed, i$, len$, x;
  passed = [];
  failed = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    (f(x) ? passed : failed).push(x);
  }
  return [passed, failed];
});
find = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      return x;
    }
  }
});
head = first = function(xs){
  return xs[0];
};
tail = function(xs){
  if (!xs.length) {
    return;
  }
  return xs.slice(1);
};
last = function(xs){
  return xs[xs.length - 1];
};
initial = function(xs){
  if (!xs.length) {
    return;
  }
  return xs.slice(0, -1);
};
empty = function(xs){
  return !xs.length;
};
reverse = function(xs){
  return xs.concat().reverse();
};
unique = function(xs){
  var result, i$, len$, x;
  result = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!in$(x, result)) {
      result.push(x);
    }
  }
  return result;
};
uniqueBy = curry$(function(f, xs){
  var seen, i$, len$, x, val, results$ = [];
  seen = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    val = f(x);
    if (in$(val, seen)) {
      continue;
    }
    seen.push(val);
    results$.push(x);
  }
  return results$;
});
fold = foldl = curry$(function(f, memo, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    memo = f(memo, x);
  }
  return memo;
});
fold1 = foldl1 = curry$(function(f, xs){
  return fold(f, xs[0], xs.slice(1));
});
foldr = curry$(function(f, memo, xs){
  var i$, x;
  for (i$ = xs.length - 1; i$ >= 0; --i$) {
    x = xs[i$];
    memo = f(x, memo);
  }
  return memo;
});
foldr1 = curry$(function(f, xs){
  return foldr(f, xs[xs.length - 1], xs.slice(0, -1));
});
unfoldr = curry$(function(f, b){
  var result, x, that;
  result = [];
  x = b;
  while ((that = f(x)) != null) {
    result.push(that[0]);
    x = that[1];
  }
  return result;
});
concat = function(xss){
  return [].concat.apply([], xss);
};
concatMap = curry$(function(f, xs){
  var x;
  return [].concat.apply([], (function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      results$.push(f(x));
    }
    return results$;
  }()));
});
flatten = function(xs){
  var x;
  return [].concat.apply([], (function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      if (toString$.call(x).slice(8, -1) === 'Array') {
        results$.push(flatten(x));
      } else {
        results$.push(x);
      }
    }
    return results$;
  }()));
};
difference = function(xs){
  var yss, results, i$, len$, x, j$, len1$, ys;
  yss = slice$.call(arguments, 1);
  results = [];
  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
      ys = yss[j$];
      if (in$(x, ys)) {
        continue outer;
      }
    }
    results.push(x);
  }
  return results;
};
intersection = function(xs){
  var yss, results, i$, len$, x, j$, len1$, ys;
  yss = slice$.call(arguments, 1);
  results = [];
  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
      ys = yss[j$];
      if (!in$(x, ys)) {
        continue outer;
      }
    }
    results.push(x);
  }
  return results;
};
union = function(){
  var xss, results, i$, len$, xs, j$, len1$, x;
  xss = slice$.call(arguments);
  results = [];
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    for (j$ = 0, len1$ = xs.length; j$ < len1$; ++j$) {
      x = xs[j$];
      if (!in$(x, results)) {
        results.push(x);
      }
    }
  }
  return results;
};
countBy = curry$(function(f, xs){
  var results, i$, len$, x, key;
  results = {};
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    key = f(x);
    if (key in results) {
      results[key] += 1;
    } else {
      results[key] = 1;
    }
  }
  return results;
});
groupBy = curry$(function(f, xs){
  var results, i$, len$, x, key;
  results = {};
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    key = f(x);
    if (key in results) {
      results[key].push(x);
    } else {
      results[key] = [x];
    }
  }
  return results;
});
andList = function(xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!x) {
      return false;
    }
  }
  return true;
};
orList = function(xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (x) {
      return true;
    }
  }
  return false;
};
any = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      return true;
    }
  }
  return false;
});
all = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!f(x)) {
      return false;
    }
  }
  return true;
});
sort = function(xs){
  return xs.concat().sort(function(x, y){
    if (x > y) {
      return 1;
    } else if (x < y) {
      return -1;
    } else {
      return 0;
    }
  });
};
sortWith = curry$(function(f, xs){
  return xs.concat().sort(f);
});
sortBy = curry$(function(f, xs){
  return xs.concat().sort(function(x, y){
    if (f(x) > f(y)) {
      return 1;
    } else if (f(x) < f(y)) {
      return -1;
    } else {
      return 0;
    }
  });
});
sum = function(xs){
  var result, i$, len$, x;
  result = 0;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    result += x;
  }
  return result;
};
product = function(xs){
  var result, i$, len$, x;
  result = 1;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    result *= x;
  }
  return result;
};
mean = average = function(xs){
  var sum, i$, len$, x;
  sum = 0;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    sum += x;
  }
  return sum / xs.length;
};
maximum = function(xs){
  var max, i$, ref$, len$, x;
  max = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (x > max) {
      max = x;
    }
  }
  return max;
};
minimum = function(xs){
  var min, i$, ref$, len$, x;
  min = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (x < min) {
      min = x;
    }
  }
  return min;
};
maximumBy = curry$(function(f, xs){
  var max, i$, ref$, len$, x;
  max = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (f(x) > f(max)) {
      max = x;
    }
  }
  return max;
});
minimumBy = curry$(function(f, xs){
  var min, i$, ref$, len$, x;
  min = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (f(x) < f(min)) {
      min = x;
    }
  }
  return min;
});
scan = scanl = curry$(function(f, memo, xs){
  var last, x;
  last = memo;
  return [memo].concat((function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      results$.push(last = f(last, x));
    }
    return results$;
  }()));
});
scan1 = scanl1 = curry$(function(f, xs){
  if (!xs.length) {
    return;
  }
  return scan(f, xs[0], xs.slice(1));
});
scanr = curry$(function(f, memo, xs){
  xs = xs.concat().reverse();
  return scan(f, memo, xs).reverse();
});
scanr1 = curry$(function(f, xs){
  if (!xs.length) {
    return;
  }
  xs = xs.concat().reverse();
  return scan(f, xs[0], xs.slice(1)).reverse();
});
slice = curry$(function(x, y, xs){
  return xs.slice(x, y);
});
take = curry$(function(n, xs){
  if (n <= 0) {
    return xs.slice(0, 0);
  } else {
    return xs.slice(0, n);
  }
});
drop = curry$(function(n, xs){
  if (n <= 0) {
    return xs;
  } else {
    return xs.slice(n);
  }
});
splitAt = curry$(function(n, xs){
  return [take(n, xs), drop(n, xs)];
});
takeWhile = curry$(function(p, xs){
  var len, i;
  len = xs.length;
  if (!len) {
    return xs;
  }
  i = 0;
  while (i < len && p(xs[i])) {
    i += 1;
  }
  return xs.slice(0, i);
});
dropWhile = curry$(function(p, xs){
  var len, i;
  len = xs.length;
  if (!len) {
    return xs;
  }
  i = 0;
  while (i < len && p(xs[i])) {
    i += 1;
  }
  return xs.slice(i);
});
span = curry$(function(p, xs){
  return [takeWhile(p, xs), dropWhile(p, xs)];
});
breakList = curry$(function(p, xs){
  return span(function(){
    return not$(p.apply(this, arguments));
  }, xs);
});
zip = curry$(function(xs, ys){
  var result, len, i$, len$, i, x;
  result = [];
  len = ys.length;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (i === len) {
      break;
    }
    result.push([x, ys[i]]);
  }
  return result;
});
zipWith = curry$(function(f, xs, ys){
  var result, len, i$, len$, i, x;
  result = [];
  len = ys.length;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (i === len) {
      break;
    }
    result.push(f(x, ys[i]));
  }
  return result;
});
zipAll = function(){
  var xss, minLength, i$, len$, xs, ref$, i, lresult$, j$, results$ = [];
  xss = slice$.call(arguments);
  minLength = 9e9;
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    minLength <= (ref$ = xs.length) || (minLength = ref$);
  }
  for (i$ = 0; i$ < minLength; ++i$) {
    i = i$;
    lresult$ = [];
    for (j$ = 0, len$ = xss.length; j$ < len$; ++j$) {
      xs = xss[j$];
      lresult$.push(xs[i]);
    }
    results$.push(lresult$);
  }
  return results$;
};
zipAllWith = function(f){
  var xss, minLength, i$, len$, xs, ref$, i, results$ = [];
  xss = slice$.call(arguments, 1);
  minLength = 9e9;
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    minLength <= (ref$ = xs.length) || (minLength = ref$);
  }
  for (i$ = 0; i$ < minLength; ++i$) {
    i = i$;
    results$.push(f.apply(null, (fn$())));
  }
  return results$;
  function fn$(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xss).length; i$ < len$; ++i$) {
      xs = ref$[i$];
      results$.push(xs[i]);
    }
    return results$;
  }
};
at = curry$(function(n, xs){
  if (n < 0) {
    return xs[xs.length + n];
  } else {
    return xs[n];
  }
});
elemIndex = curry$(function(el, xs){
  var i$, len$, i, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (x === el) {
      return i;
    }
  }
});
elemIndices = curry$(function(el, xs){
  var i$, len$, i, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (x === el) {
      results$.push(i);
    }
  }
  return results$;
});
findIndex = curry$(function(f, xs){
  var i$, len$, i, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (f(x)) {
      return i;
    }
  }
});
findIndices = curry$(function(f, xs){
  var i$, len$, i, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (f(x)) {
      results$.push(i);
    }
  }
  return results$;
});
module.exports = {
  each: each,
  map: map,
  filter: filter,
  compact: compact,
  reject: reject,
  partition: partition,
  find: find,
  head: head,
  first: first,
  tail: tail,
  last: last,
  initial: initial,
  empty: empty,
  reverse: reverse,
  difference: difference,
  intersection: intersection,
  union: union,
  countBy: countBy,
  groupBy: groupBy,
  fold: fold,
  fold1: fold1,
  foldl: foldl,
  foldl1: foldl1,
  foldr: foldr,
  foldr1: foldr1,
  unfoldr: unfoldr,
  andList: andList,
  orList: orList,
  any: any,
  all: all,
  unique: unique,
  uniqueBy: uniqueBy,
  sort: sort,
  sortWith: sortWith,
  sortBy: sortBy,
  sum: sum,
  product: product,
  mean: mean,
  average: average,
  concat: concat,
  concatMap: concatMap,
  flatten: flatten,
  maximum: maximum,
  minimum: minimum,
  maximumBy: maximumBy,
  minimumBy: minimumBy,
  scan: scan,
  scan1: scan1,
  scanl: scanl,
  scanl1: scanl1,
  scanr: scanr,
  scanr1: scanr1,
  slice: slice,
  take: take,
  drop: drop,
  splitAt: splitAt,
  takeWhile: takeWhile,
  dropWhile: dropWhile,
  span: span,
  breakList: breakList,
  zip: zip,
  zipWith: zipWith,
  zipAll: zipAll,
  zipAllWith: zipAllWith,
  at: at,
  elemIndex: elemIndex,
  elemIndices: elemIndices,
  findIndex: findIndex,
  findIndices: findIndices
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
function in$(x, xs){
  var i = -1, l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}
function not$(x){ return !x; }
},{}],4:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var max, min, negate, abs, signum, quot, rem, div, mod, recip, pi, tau, exp, sqrt, ln, pow, sin, tan, cos, asin, acos, atan, atan2, truncate, round, ceiling, floor, isItNaN, even, odd, gcd, lcm;
max = curry$(function(x$, y$){
  return x$ > y$ ? x$ : y$;
});
min = curry$(function(x$, y$){
  return x$ < y$ ? x$ : y$;
});
negate = function(x){
  return -x;
};
abs = Math.abs;
signum = function(x){
  if (x < 0) {
    return -1;
  } else if (x > 0) {
    return 1;
  } else {
    return 0;
  }
};
quot = curry$(function(x, y){
  return ~~(x / y);
});
rem = curry$(function(x$, y$){
  return x$ % y$;
});
div = curry$(function(x, y){
  return Math.floor(x / y);
});
mod = curry$(function(x$, y$){
  var ref$;
  return ((x$) % (ref$ = y$) + ref$) % ref$;
});
recip = (function(it){
  return 1 / it;
});
pi = Math.PI;
tau = pi * 2;
exp = Math.exp;
sqrt = Math.sqrt;
ln = Math.log;
pow = curry$(function(x$, y$){
  return Math.pow(x$, y$);
});
sin = Math.sin;
tan = Math.tan;
cos = Math.cos;
asin = Math.asin;
acos = Math.acos;
atan = Math.atan;
atan2 = curry$(function(x, y){
  return Math.atan2(x, y);
});
truncate = function(x){
  return ~~x;
};
round = Math.round;
ceiling = Math.ceil;
floor = Math.floor;
isItNaN = function(x){
  return x !== x;
};
even = function(x){
  return x % 2 === 0;
};
odd = function(x){
  return x % 2 !== 0;
};
gcd = curry$(function(x, y){
  var z;
  x = Math.abs(x);
  y = Math.abs(y);
  while (y !== 0) {
    z = x % y;
    x = y;
    y = z;
  }
  return x;
});
lcm = curry$(function(x, y){
  return Math.abs(Math.floor(x / gcd(x, y) * y));
});
module.exports = {
  max: max,
  min: min,
  negate: negate,
  abs: abs,
  signum: signum,
  quot: quot,
  rem: rem,
  div: div,
  mod: mod,
  recip: recip,
  pi: pi,
  tau: tau,
  exp: exp,
  sqrt: sqrt,
  ln: ln,
  pow: pow,
  sin: sin,
  tan: tan,
  cos: cos,
  acos: acos,
  asin: asin,
  atan: atan,
  atan2: atan2,
  truncate: truncate,
  round: round,
  ceiling: ceiling,
  floor: floor,
  isItNaN: isItNaN,
  even: even,
  odd: odd,
  gcd: gcd,
  lcm: lcm
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{}],5:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var values, keys, pairsToObj, objToPairs, listsToObj, objToLists, empty, each, map, compact, filter, reject, partition, find;
values = function(object){
  var i$, x, results$ = [];
  for (i$ in object) {
    x = object[i$];
    results$.push(x);
  }
  return results$;
};
keys = function(object){
  var x, results$ = [];
  for (x in object) {
    results$.push(x);
  }
  return results$;
};
pairsToObj = function(object){
  var i$, len$, x, results$ = {};
  for (i$ = 0, len$ = object.length; i$ < len$; ++i$) {
    x = object[i$];
    results$[x[0]] = x[1];
  }
  return results$;
};
objToPairs = function(object){
  var key, value, results$ = [];
  for (key in object) {
    value = object[key];
    results$.push([key, value]);
  }
  return results$;
};
listsToObj = curry$(function(keys, values){
  var i$, len$, i, key, results$ = {};
  for (i$ = 0, len$ = keys.length; i$ < len$; ++i$) {
    i = i$;
    key = keys[i$];
    results$[key] = values[i];
  }
  return results$;
});
objToLists = function(object){
  var keys, values, key, value;
  keys = [];
  values = [];
  for (key in object) {
    value = object[key];
    keys.push(key);
    values.push(value);
  }
  return [keys, values];
};
empty = function(object){
  var x;
  for (x in object) {
    return false;
  }
  return true;
};
each = curry$(function(f, object){
  var i$, x;
  for (i$ in object) {
    x = object[i$];
    f(x);
  }
  return object;
});
map = curry$(function(f, object){
  var k, x, results$ = {};
  for (k in object) {
    x = object[k];
    results$[k] = f(x);
  }
  return results$;
});
compact = function(object){
  var k, x, results$ = {};
  for (k in object) {
    x = object[k];
if (x) {
      results$[k] = x;
    }
  }
  return results$;
};
filter = curry$(function(f, object){
  var k, x, results$ = {};
  for (k in object) {
    x = object[k];
if (f(x)) {
      results$[k] = x;
    }
  }
  return results$;
});
reject = curry$(function(f, object){
  var k, x, results$ = {};
  for (k in object) {
    x = object[k];
if (!f(x)) {
      results$[k] = x;
    }
  }
  return results$;
});
partition = curry$(function(f, object){
  var passed, failed, k, x;
  passed = {};
  failed = {};
  for (k in object) {
    x = object[k];
    (f(x) ? passed : failed)[k] = x;
  }
  return [passed, failed];
});
find = curry$(function(f, object){
  var i$, x;
  for (i$ in object) {
    x = object[i$];
    if (f(x)) {
      return x;
    }
  }
});
module.exports = {
  values: values,
  keys: keys,
  pairsToObj: pairsToObj,
  objToPairs: objToPairs,
  listsToObj: listsToObj,
  objToLists: objToLists,
  empty: empty,
  each: each,
  map: map,
  filter: filter,
  compact: compact,
  reject: reject,
  partition: partition,
  find: find
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{}],6:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var split, join, lines, unlines, words, unwords, chars, unchars, reverse, repeat, capitalize, camelize, dasherize;
split = curry$(function(sep, str){
  return str.split(sep);
});
join = curry$(function(sep, xs){
  return xs.join(sep);
});
lines = function(str){
  if (!str.length) {
    return [];
  }
  return str.split('\n');
};
unlines = function(it){
  return it.join('\n');
};
words = function(str){
  if (!str.length) {
    return [];
  }
  return str.split(/[ ]+/);
};
unwords = function(it){
  return it.join(' ');
};
chars = function(it){
  return it.split('');
};
unchars = function(it){
  return it.join('');
};
reverse = function(str){
  return str.split('').reverse().join('');
};
repeat = curry$(function(n, str){
  var result, i$;
  result = '';
  for (i$ = 0; i$ < n; ++i$) {
    result += str;
  }
  return result;
});
capitalize = function(str){
  return str.charAt(0).toUpperCase() + str.slice(1);
};
camelize = function(it){
  return it.replace(/[-_]+(.)?/g, function(arg$, c){
    return (c != null ? c : '').toUpperCase();
  });
};
dasherize = function(str){
  return str.replace(/([^-A-Z])([A-Z]+)/g, function(arg$, lower, upper){
    return lower + "-" + (upper.length > 1
      ? upper
      : upper.toLowerCase());
  }).replace(/^([A-Z]+)/, function(arg$, upper){
    if (upper.length > 1) {
      return upper + "-";
    } else {
      return upper.toLowerCase();
    }
  });
};
module.exports = {
  split: split,
  join: join,
  lines: lines,
  unlines: unlines,
  words: words,
  unwords: unwords,
  chars: chars,
  unchars: unchars,
  reverse: reverse,
  repeat: repeat,
  capitalize: capitalize,
  camelize: camelize,
  dasherize: dasherize
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{}],7:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var Func, List, Obj, Str, Num, id, isType, replicate, prelude, toString$ = {}.toString;
Func = require('./Func.js');
List = require('./List.js');
Obj = require('./Obj.js');
Str = require('./Str.js');
Num = require('./Num.js');
id = function(x){
  return x;
};
isType = curry$(function(type, x){
  return toString$.call(x).slice(8, -1) === type;
});
replicate = curry$(function(n, x){
  var i$, results$ = [];
  for (i$ = 0; i$ < n; ++i$) {
    results$.push(x);
  }
  return results$;
});
Str.empty = List.empty;
Str.slice = List.slice;
Str.take = List.take;
Str.drop = List.drop;
Str.splitAt = List.splitAt;
Str.takeWhile = List.takeWhile;
Str.dropWhile = List.dropWhile;
Str.span = List.span;
Str.breakStr = List.breakList;
prelude = {
  Func: Func,
  List: List,
  Obj: Obj,
  Str: Str,
  Num: Num,
  id: id,
  isType: isType,
  replicate: replicate
};
prelude.each = List.each;
prelude.map = List.map;
prelude.filter = List.filter;
prelude.compact = List.compact;
prelude.reject = List.reject;
prelude.partition = List.partition;
prelude.find = List.find;
prelude.head = List.head;
prelude.first = List.first;
prelude.tail = List.tail;
prelude.last = List.last;
prelude.initial = List.initial;
prelude.empty = List.empty;
prelude.reverse = List.reverse;
prelude.difference = List.difference;
prelude.intersection = List.intersection;
prelude.union = List.union;
prelude.countBy = List.countBy;
prelude.groupBy = List.groupBy;
prelude.fold = List.fold;
prelude.foldl = List.foldl;
prelude.fold1 = List.fold1;
prelude.foldl1 = List.foldl1;
prelude.foldr = List.foldr;
prelude.foldr1 = List.foldr1;
prelude.unfoldr = List.unfoldr;
prelude.andList = List.andList;
prelude.orList = List.orList;
prelude.any = List.any;
prelude.all = List.all;
prelude.unique = List.unique;
prelude.uniqueBy = List.uniqueBy;
prelude.sort = List.sort;
prelude.sortWith = List.sortWith;
prelude.sortBy = List.sortBy;
prelude.sum = List.sum;
prelude.product = List.product;
prelude.mean = List.mean;
prelude.average = List.average;
prelude.concat = List.concat;
prelude.concatMap = List.concatMap;
prelude.flatten = List.flatten;
prelude.maximum = List.maximum;
prelude.minimum = List.minimum;
prelude.maximumBy = List.maximumBy;
prelude.minimumBy = List.minimumBy;
prelude.scan = List.scan;
prelude.scanl = List.scanl;
prelude.scan1 = List.scan1;
prelude.scanl1 = List.scanl1;
prelude.scanr = List.scanr;
prelude.scanr1 = List.scanr1;
prelude.slice = List.slice;
prelude.take = List.take;
prelude.drop = List.drop;
prelude.splitAt = List.splitAt;
prelude.takeWhile = List.takeWhile;
prelude.dropWhile = List.dropWhile;
prelude.span = List.span;
prelude.breakList = List.breakList;
prelude.zip = List.zip;
prelude.zipWith = List.zipWith;
prelude.zipAll = List.zipAll;
prelude.zipAllWith = List.zipAllWith;
prelude.at = List.at;
prelude.elemIndex = List.elemIndex;
prelude.elemIndices = List.elemIndices;
prelude.findIndex = List.findIndex;
prelude.findIndices = List.findIndices;
prelude.apply = Func.apply;
prelude.curry = Func.curry;
prelude.flip = Func.flip;
prelude.fix = Func.fix;
prelude.over = Func.over;
prelude.split = Str.split;
prelude.join = Str.join;
prelude.lines = Str.lines;
prelude.unlines = Str.unlines;
prelude.words = Str.words;
prelude.unwords = Str.unwords;
prelude.chars = Str.chars;
prelude.unchars = Str.unchars;
prelude.repeat = Str.repeat;
prelude.capitalize = Str.capitalize;
prelude.camelize = Str.camelize;
prelude.dasherize = Str.dasherize;
prelude.values = Obj.values;
prelude.keys = Obj.keys;
prelude.pairsToObj = Obj.pairsToObj;
prelude.objToPairs = Obj.objToPairs;
prelude.listsToObj = Obj.listsToObj;
prelude.objToLists = Obj.objToLists;
prelude.max = Num.max;
prelude.min = Num.min;
prelude.negate = Num.negate;
prelude.abs = Num.abs;
prelude.signum = Num.signum;
prelude.quot = Num.quot;
prelude.rem = Num.rem;
prelude.div = Num.div;
prelude.mod = Num.mod;
prelude.recip = Num.recip;
prelude.pi = Num.pi;
prelude.tau = Num.tau;
prelude.exp = Num.exp;
prelude.sqrt = Num.sqrt;
prelude.ln = Num.ln;
prelude.pow = Num.pow;
prelude.sin = Num.sin;
prelude.tan = Num.tan;
prelude.cos = Num.cos;
prelude.acos = Num.acos;
prelude.asin = Num.asin;
prelude.atan = Num.atan;
prelude.atan2 = Num.atan2;
prelude.truncate = Num.truncate;
prelude.round = Num.round;
prelude.ceiling = Num.ceiling;
prelude.floor = Num.floor;
prelude.isItNaN = Num.isItNaN;
prelude.even = Num.even;
prelude.odd = Num.odd;
prelude.gcd = Num.gcd;
prelude.lcm = Num.lcm;
prelude.VERSION = '1.1.1';
module.exports = prelude;
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{"./Func.js":2,"./List.js":3,"./Num.js":4,"./Obj.js":5,"./Str.js":6}],8:[function(require,module,exports){
var std, kGravity, kTerminalSpeed, ZeroAccelerator, ConstantAccelerator, BidirectionalAccelerator, FrictionAccelerator, kZero, kGravityAcc, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
out$.kGravity = kGravity = 0.00078125;
out$.kTerminalSpeed = kTerminalSpeed = 0.2998046875;
out$.ZeroAccelerator = ZeroAccelerator = (function(){
  ZeroAccelerator.displayName = 'ZeroAccelerator';
  var prototype = ZeroAccelerator.prototype, constructor = ZeroAccelerator;
  function ZeroAccelerator(){}
  prototype.updateVelocity = function(){};
  return ZeroAccelerator;
}());
out$.ConstantAccelerator = ConstantAccelerator = (function(){
  ConstantAccelerator.displayName = 'ConstantAccelerator';
  var prototype = ConstantAccelerator.prototype, constructor = ConstantAccelerator;
  function ConstantAccelerator(acc, maxVel){
    this.acc = acc;
    this.maxVel = maxVel;
    this.updateVelocity = this.acc < 0
      ? function(kinematics, elapsedTime){
        return kinematics.velocity = std.max(kinematics.velocity + this.acc * elapsedTime, this.maxVel);
      }
      : function(kinematics, elapsedTime){
        return kinematics.velocity = std.min(kinematics.velocity + this.acc * elapsedTime, this.maxVel);
      };
  }
  return ConstantAccelerator;
}());
out$.BidirectionalAccelerator = BidirectionalAccelerator = (function(){
  BidirectionalAccelerator.displayName = 'BidirectionalAccelerator';
  var prototype = BidirectionalAccelerator.prototype, constructor = BidirectionalAccelerator;
  function BidirectionalAccelerator(acc, maxVel){
    this.acc = acc;
    this.maxVel = maxVel;
    this.positive = new ConstantAccelerator(this.acc, this.maxVel);
    this.negative = new ConstantAccelerator(-this.acc, -this.maxVel);
  }
  return BidirectionalAccelerator;
}());
out$.FrictionAccelerator = FrictionAccelerator = (function(){
  FrictionAccelerator.displayName = 'FrictionAccelerator';
  var prototype = FrictionAccelerator.prototype, constructor = FrictionAccelerator;
  function FrictionAccelerator(friction){
    this.friction = friction;
  }
  prototype.updateVelocity = function(kinematics, elapsedTime){
    return kinematics.velocity = kinematics.velocity > 0
      ? std.max(0, kinematics.velocity - this.friction * elapsedTime)
      : std.min(0, kinematics.velocity + this.friction * elapsedTime);
  };
  return FrictionAccelerator;
}());
out$.kZero = kZero = new ZeroAccelerator;
out$.kGravityAcc = kGravityAcc = new ConstantAccelerator(kGravity, kTerminalSpeed);
},{"std":48}],9:[function(require,module,exports){
var std, units, kHalfTile, tpx, tileToGame, gameToPx, WALL_TILE, Sprite, ref$, SpriteState, State, Projectile, StarParticle, WallParticle, Rect, kArmsSpritePath, kSpriteWidth, kSpriteHeight, kUpOffset, kDownOffset, kHorizontalOffset, kRightOffset, kLeftOffset, UP, DOWN, LEFT, RIGHT, PolarStarProjectile, PolarStar, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
kHalfTile = units.kHalfTile, tpx = units.tileToPx, tileToGame = units.tileToGame, gameToPx = units.gameToPx;
WALL_TILE = require('./map').WALL_TILE;
Sprite = require('./sprite').Sprite;
ref$ = require('./spritestate'), SpriteState = ref$.SpriteState, State = ref$.State;
Projectile = require('./projectile').Projectile;
StarParticle = require('./star-particle').StarParticle;
WallParticle = require('./wall-particle').WallParticle;
Rect = require('./rectangle').Rectangle;
kArmsSpritePath = 'Arms';
kSpriteWidth = 1.5;
kSpriteHeight = 1.0;
kUpOffset = 2;
kDownOffset = 4;
kHorizontalOffset = 0;
kRightOffset = 1;
kLeftOffset = 0;
ref$ = std['enum'], UP = ref$[0], DOWN = ref$[1], LEFT = ref$[2], RIGHT = ref$[3];
PolarStarProjectile = (function(superclass){
  var kLifespans, kSpeeds, kCollisionWidths, kCollisionHeights, kDamages, prototype = extend$((import$(PolarStarProjectile, superclass).displayName = 'PolarStarProjectile', PolarStarProjectile), superclass).prototype, constructor = PolarStarProjectile;
  kLifespans = [tileToGame(3.5), tileToGame(5), tileToGame(7)];
  kSpeeds = [0.6, 0.6, 0.6];
  kCollisionWidths = [32, 32, 32];
  kCollisionHeights = [4, 8, 16];
  kDamages = [1, 2, 4];
  function PolarStarProjectile(sprite, state, x, y, gunLevel){
    this.sprite = sprite;
    this.gunLevel = gunLevel;
    PolarStarProjectile.superclass.call(this, kDamages[this.gunLevel - 1]);
    this.offset = 0;
    this.lifespan = kLifespans[this.gunLevel - 1];
    this.alive = true;
    std.log('SFX: Pew!');
    if (state.HORIZONTAL) {
      this.width = kCollisionWidths[this.gunLevel - 1];
      this.height = kCollisionHeights[this.gunLevel - 1];
      this.vertical = false;
    } else {
      this.width = kCollisionHeights[this.gunLevel - 1];
      this.height = kCollisionWidths[this.gunLevel - 1];
      this.vertical = true;
    }
    this.mode = (function(){
      switch (true) {
      case state.UP:
        return UP;
      case state.DOWN:
        return DOWN;
      case state.LEFT:
        return LEFT;
      case state.RIGHT:
        return RIGHT;
      }
    }());
    Object.defineProperties(this, {
      x: {
        get: !state.HORIZONTAL
          ? function(){
            return x;
          }
          : state.LEFT
            ? function(){
              return x - this.offset;
            }
            : state.RIGHT ? function(){
              return x + this.offset;
            } : void 8
      },
      y: {
        get: state.HORIZONTAL
          ? function(){
            return y;
          }
          : state.UP
            ? function(){
              return y - this.offset;
            }
            : state.DOWN ? function(){
              return y + this.offset;
            } : void 8
      }
    });
  }
  prototype.collisionRectangle = function(){
    return new Rect(this.x + kHalfTile - this.width / 2, this.y + kHalfTile - this.height / 2, this.width, this.height);
  };
  prototype.update = function(elapsedTime, map, ptools){
    var i$, ref$, len$, tile, tileRect, particleX, particleY;
    this.offset += kSpeeds[this.gunLevel - 1] * elapsedTime;
    for (i$ = 0, len$ = (ref$ = map.getCollidingTiles(this.collisionRectangle())).length; i$ < len$; ++i$) {
      tile = ref$[i$];
      if (tile.type === WALL_TILE) {
        tileRect = new Rect(tileToGame(tile.col), tileToGame(tile.row), tileToGame(1), tileToGame(1));
        particleX = this.x;
        particleY = this.y;
        switch (this.mode) {
        case UP:
          particleY = tileRect.bottom - kHalfTile;
          break;
        case DOWN:
          particleY = tileRect.top - kHalfTile;
          break;
        case LEFT:
          particleX = tileRect.right - kHalfTile;
          break;
        case RIGHT:
          particleX = tileRect.left - kHalfTile;
        }
        ptools.frontSystem.addNewParticle(new WallParticle(ptools.graphics, particleX, particleY));
        return false;
      }
    }
    if (!this.alive) {
      return false;
    } else if (this.offset >= this.lifespan) {
      ptools.frontSystem.addNewParticle(new StarParticle(ptools.graphics, this.x, this.y));
      return false;
    } else {
      return true;
    }
  };
  prototype.draw = function(graphics){
    this.sprite.draw(graphics, this.x, this.y);
    return graphics.visualiseRect(this.collisionRectangle());
  };
  prototype.collideWithEnemy = function(){
    return this.alive = false;
  };
  return PolarStarProjectile;
}(Projectile));
out$.PolarStar = PolarStar = (function(){
  PolarStar.displayName = 'PolarStar';
  var kExperiences, kPolarStarIndex, kProjectileSrcYs, kProjectileSrcXs, kNozzleHorizY, kNozzleHorizLeftX, kNozzleHorizRightX, kNozzleUpY, kNozzleUpLeftX, kNozzleUpRightX, kNozzleDownY, kNozzleDownLeftX, kNozzleDownRightX, prototype = PolarStar.prototype, constructor = PolarStar;
  kExperiences = [0, 10, 30, 40];
  kPolarStarIndex = 2;
  kProjectileSrcYs = [2, 2, 3];
  kProjectileSrcXs = [8, 10, 8];
  kNozzleHorizY = 23;
  kNozzleHorizLeftX = 10;
  kNozzleHorizRightX = 38;
  kNozzleUpY = 4;
  kNozzleUpLeftX = 27;
  kNozzleUpRightX = 21;
  kNozzleDownY = 28;
  kNozzleDownLeftX = 29;
  kNozzleDownRightX = 19;
  function PolarStar(graphics){
    var res$, i$, to$, lvl;
    this.projectileA = null;
    this.projectileB = null;
    this.sprites = this.initialiseSprites(graphics);
    this.currentExperience = 0;
    res$ = [];
    for (i$ = 0, to$ = units.kMaxGunLevel; i$ <= to$; ++i$) {
      lvl = i$;
      res$.push(new Sprite(graphics, 'bullet', tpx(kProjectileSrcXs[lvl]), tpx(kProjectileSrcYs[lvl]), tpx(1), tpx(1)));
    }
    this.hpSprites = res$;
    res$ = [];
    for (i$ = 0, to$ = units.kMaxGunLevel; i$ <= to$; ++i$) {
      lvl = i$;
      res$.push(new Sprite(graphics, 'bullet', tpx(kProjectileSrcXs[lvl] + 1), tpx(kProjectileSrcYs[lvl]), tpx(1), tpx(1)));
    }
    this.vpSprites = res$;
  }
  prototype.collectExperience = function(experience){
    return this.currentExperience = std.min(kExperiences[units.kMaxGunLevel], this.currentExperience + experience);
  };
  prototype.currentLevel = function(){
    var i$, ref$, level, exp;
    for (i$ = (ref$ = kExperiences).length - 1; i$ >= 0; --i$) {
      level = i$;
      exp = ref$[i$];
      if (this.currentExperience >= kExperiences[level - 1]) {
        return level;
      }
    }
    return 1;
  };
  prototype.initialiseSprites = function(graphics){
    return SpriteState.generateWith(function(state){
      var tileY;
      tileY = state.LEFT ? kLeftOffset : kRightOffset;
      switch (true) {
      case state.HORIZONTAL:
        tileY += kHorizontalOffset;
        break;
      case state.UP:
        tileY += kUpOffset;
        break;
      case state.DOWN:
        tileY += kDownOffset;
      }
      return new Sprite(graphics, kArmsSpritePath, tpx(kPolarStarIndex * kSpriteWidth), tpx(tileY), tpx(kSpriteWidth), tpx(kSpriteHeight));
    });
  };
  prototype.startFire = function(state, playerX, playerY){
    var bulletX, bulletY, sprite;
    if (this.projectileA && this.projectileB) {
      return;
    }
    bulletX = this.gunX(state, playerX) - kHalfTile;
    bulletY = this.gunY(state, playerY) - kHalfTile;
    switch (true) {
    case state.HORIZONTAL:
      bulletY += kNozzleHorizY;
      bulletX += state.LEFT ? kNozzleHorizLeftX : kNozzleHorizRightX;
      break;
    case state.UP:
      bulletY += kNozzleUpY;
      bulletX += state.LEFT ? kNozzleUpLeftX : kNozzleUpRightX;
      break;
    case state.DOWN:
      bulletY += kNozzleDownY;
      bulletX += state.LEFT ? kNozzleDownLeftX : kNozzleDownRightX;
    }
    sprite = state.HORIZONTAL
      ? this.hpSprites[this.currentLevel() - 1]
      : this.vpSprites[this.currentLevel() - 1];
    if (!this.projectileA) {
      return this.projectileA = new PolarStarProjectile(sprite, state, bulletX, bulletY, this.currentLevel());
    } else if (!this.projectileB) {
      return this.projectileB = new PolarStarProjectile(sprite, state, bulletX, bulletY, this.currentLevel());
    }
  };
  prototype.stopFire = function(){};
  prototype.gunX = function(state, playerX){
    if (state.LEFT) {
      return playerX - kHalfTile;
    } else {
      return playerX;
    }
  };
  prototype.gunY = function(state, playerY){
    if (state.UP) {
      playerY -= kHalfTile / 2;
    }
    if (state.DOWN) {
      playerY += kHalfTile / 2;
    }
    return playerY + this.gunBob(state);
  };
  prototype.gunBob = function(state){
    if (state.WALKING && (state.STRIDE_LEFT || state.STRIDE_RIGHT)) {
      return -2;
    } else {
      return 0;
    }
  };
  prototype.getProjectiles = function(){
    var projectiles, that;
    projectiles = [];
    if (that = this.projectileA) {
      projectiles.push(that);
    }
    if (that = this.projectileB) {
      projectiles.push(that);
    }
    return projectiles;
  };
  prototype.updateProjectiles = function(elapsedTime, map, ptools){
    var ref$;
    if (!((ref$ = this.projectileA) != null && ref$.update(elapsedTime, map, ptools))) {
      this.projectileA = null;
    }
    if (!((ref$ = this.projectileB) != null && ref$.update(elapsedTime, map, ptools))) {
      return this.projectileB = null;
    }
  };
  prototype.draw = function(graphics, playerX, playerY, state){
    var gunX, gunY, ref$;
    gunX = this.gunX(state, playerX);
    gunY = this.gunY(state, playerY);
    this.sprites[state.key].draw(graphics, gunX, gunY);
    if ((ref$ = this.projectileA) != null) {
      ref$.draw(graphics);
    }
    return (ref$ = this.projectileB) != null ? ref$.draw(graphics) : void 8;
  };
  prototype.drawHud = function(graphics, hud){
    var level;
    level = this.currentLevel();
    return hud.draw(graphics, level, this.currentExperience - kExperiences[level - 1], kExperiences[level] - kExperiences[level - 1]);
  };
  return PolarStar;
}());
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{"./map":27,"./projectile":34,"./rectangle":36,"./sprite":45,"./spritestate":46,"./star-particle":47,"./units":50,"./wall-particle":51,"std":48}],10:[function(require,module,exports){
var std, SDL, units, config, kScreenWidth, kScreenHeight, kBackgroundSize, FixedBackdrop, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
SDL = require('SDL');
units = require('./units');
config = require('./config');
kScreenWidth = config.kScreenWidth, kScreenHeight = config.kScreenHeight;
kBackgroundSize = 4;
out$.FixedBackdrop = FixedBackdrop = (function(){
  FixedBackdrop.displayName = 'FixedBackdrop';
  var prototype = FixedBackdrop.prototype, constructor = FixedBackdrop;
  function FixedBackdrop(path, graphics){
    this.surface = graphics.loadImage(path);
  }
  prototype.draw = function(graphics){
    var i$, step$, to$, x, lresult$, j$, step1$, to1$, y, destRect, results$ = [];
    for (i$ = 0, to$ = units.tileToPx(kScreenWidth + kBackgroundSize), step$ = units.tileToPx(kBackgroundSize); step$ < 0 ? i$ >= to$ : i$ <= to$; i$ += step$) {
      x = i$;
      lresult$ = [];
      for (j$ = 0, to1$ = units.tileToPx(kScreenHeight + kBackgroundSize), step1$ = units.tileToPx(kBackgroundSize); step1$ < 0 ? j$ >= to1$ : j$ <= to1$; j$ += step1$) {
        y = j$;
        destRect = new SDL.Rect(x, y, units.tileToPx(kBackgroundSize), units.tileToPx(kBackgroundSize));
        lresult$.push(graphics.blitSurface(this.surface, null, destRect));
      }
      results$.push(lresult$);
    }
    return results$;
  };
  return FixedBackdrop;
}());
},{"./config":12,"./units":50,"SDL":39,"std":48}],11:[function(require,module,exports){
var std, units, Rect, CollisionRectangle, SimpleCollisionRectangle, CompositeCollisionRectangle, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
Rect = require('./rectangle').Rectangle;
CollisionRectangle = (function(){
  CollisionRectangle.displayName = 'CollisionRectangle';
  var prototype = CollisionRectangle.prototype, constructor = CollisionRectangle;
  Object.defineProperty(prototype, 'boundingBox', {
    get: function(){},
    configurable: true,
    enumerable: true
  });
  prototype.topCollision = function(x, y, Δ){};
  prototype.leftCollision = function(x, y, Δ){};
  prototype.rightCollision = function(x, y, Δ){};
  prototype.bottomCollision = function(x, y, Δ){};
  function CollisionRectangle(){}
  return CollisionRectangle;
}());
out$.SimpleCollisionRectangle = SimpleCollisionRectangle = (function(superclass){
  var kExtraOffset, prototype = extend$((import$(SimpleCollisionRectangle, superclass).displayName = 'SimpleCollisionRectangle', SimpleCollisionRectangle), superclass).prototype, constructor = SimpleCollisionRectangle;
  kExtraOffset = 0.001;
  function SimpleCollisionRectangle(rect){
    this.rect = rect;
  }
  prototype.collidesWith = function(rect){
    return this.rect.collidesWith(rect);
  };
  prototype.leftCollision = function(x, y, Δ){
    return new Rect(x + this.rect.left + Δ, y + this.rect.top, this.rect.w - Δ, this.rect.h);
  };
  prototype.rightCollision = function(x, y, Δ){
    return new Rect(x + this.rect.left, y + this.rect.top, this.rect.w + Δ, this.rect.h);
  };
  prototype.topCollision = function(x, y, Δ){
    return new Rect(x + this.rect.left, y + this.rect.top + Δ, this.rect.w, this.rect.h - Δ);
  };
  prototype.bottomCollision = function(x, y, Δ){
    return new Rect(x + this.rect.left, y + this.rect.top, this.rect.w, this.rect.h + Δ);
  };
  Object.defineProperty(prototype, 'boundingBox', {
    get: function(){
      return new Rect(this.rect.left - kExtraOffset, this.rect.top - kExtraOffset, this.rect.w + 2 * kExtraOffset, this.rect.h + 2 * kExtraOffset);
    },
    configurable: true,
    enumerable: true
  });
  return SimpleCollisionRectangle;
}(CollisionRectangle));
out$.CompositeCollisionRectangle = CompositeCollisionRectangle = (function(superclass){
  var prototype = extend$((import$(CompositeCollisionRectangle, superclass).displayName = 'CompositeCollisionRectangle', CompositeCollisionRectangle), superclass).prototype, constructor = CompositeCollisionRectangle;
  function CompositeCollisionRectangle(top, bottom, left, right){
    this.top = top;
    this.bottom = bottom;
    this.left = left;
    this.right = right;
  }
  prototype.leftCollision = function(x, y, Δ){
    return new Rect(x + this.left.left + Δ, y + this.left.top, this.left.w - Δ, this.left.h);
  };
  prototype.rightCollision = function(x, y, Δ){
    return new Rect(x + this.right.left, y + this.right.top, this.right.w + Δ, this.right.h);
  };
  prototype.topCollision = function(x, y, Δ){
    return new Rect(x + this.top.left, y + this.top.top + Δ, this.top.w, this.top.h - Δ);
  };
  prototype.bottomCollision = function(x, y, Δ){
    return new Rect(x + this.bottom.left, y + this.bottom.top, this.bottom.w, this.bottom.h + Δ);
  };
  Object.defineProperty(prototype, 'boundingBox', {
    get: function(){
      return new Rect(this.left.left, this.top.top, this.left.w + this.right.w, this.top.h + this.bottom.h);
    },
    configurable: true,
    enumerable: true
  });
  return CompositeCollisionRectangle;
}(CollisionRectangle));
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{"./rectangle":36,"./units":50,"std":48}],12:[function(require,module,exports){
var kScreenWidth, kScreenHeight, kFps, kMaxFrameTime, kGraphicsQuality, debugFeatures, that, showCollisions, showSpritesheets, showReadout, assetPath, fileExt, findAsset, out$ = typeof exports != 'undefined' && exports || this;
out$.kScreenWidth = kScreenWidth = 20;
out$.kScreenHeight = kScreenHeight = 15;
out$.kFps = kFps = 60;
out$.kMaxFrameTime = kMaxFrameTime = 5 * 1000 / kFps;
out$.kGraphicsQuality = kGraphicsQuality = 32;
out$.debugFeatures = debugFeatures = (that = ENABLE_DEBUG_FEATURES) != null ? that : false;
out$.showCollisions = showCollisions = debugFeatures;
out$.showSpritesheets = showSpritesheets = debugFeatures;
out$.showReadout = showReadout = debugFeatures;
switch (kGraphicsQuality) {
case 16:
  out$.assetPath = assetPath = 'data/16x16/';
  out$.fileExt = fileExt = '.bmp';
  break;
case 32:
  out$.assetPath = assetPath = 'data/32x32/';
  out$.fileExt = fileExt = '.bmp';
}
out$.findAsset = findAsset = function(){
  return (function(it){
    return assetPath + it;
  })((function(it){
    return it + fileExt;
  }).apply(this, arguments));
};
},{}],13:[function(require,module,exports){
var std, units, Timer, NumberSprite, kVelocity, kVanishTime, DamageText, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
Timer = require('./timer').Timer;
NumberSprite = require('./sprite').NumberSprite;
kVelocity = -units.kHalfTile / 250;
kVanishTime = 2000;
out$.DamageText = DamageText = (function(){
  DamageText.displayName = 'DamageText';
  var prototype = DamageText.prototype, constructor = DamageText;
  function DamageText(graphics, centerX, centerY){
    this.centerX = centerX;
    this.centerY = centerY;
    this.timer = new Timer(kVanishTime);
    this.damage = 0;
    this.offsetY = 0;
    this.shouldRise = false;
  }
  prototype.setPosition = function(x, y){
    this.centerX = x;
    return this.centerY = y + this.offsetY;
  };
  prototype.setDamage = function(damage){
    this.shouldRise = this.damage === 0;
    if (this.shouldRise) {
      this.offsetY = 0;
    }
    this.damage += damage;
    return this.timer.reset();
  };
  prototype.update = function(elapsedTime){
    if (this.timer.isExpired) {
      this.damage = 0;
    }
    if (this.shouldRise) {
      this.offsetY = std.max(units.tileToGame(-1), this.offsetY + kVelocity * elapsedTime);
    }
    return this.expired;
  };
  prototype.draw = function(graphics){
    if (this.timer.isActive && this.damage > 0) {
      return new NumberSprite.DamageNumber(graphics, this.damage).drawCentered(graphics, this.centerX, this.centerY);
    }
  };
  Object.defineProperty(prototype, 'expired', {
    get: function(){
      return this.timer.isExpired;
    },
    configurable: true,
    enumerable: true
  });
  return DamageText;
}());
},{"./sprite":45,"./timer":49,"./units":50,"std":48}],14:[function(require,module,exports){
var std, allTexts, owners, reject, DamageTexts, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
allTexts = [];
owners = new WeakMap;
reject = std.flip(std.reject)(allTexts);
out$.DamageTexts = DamageTexts = {
  addDamageable: function(damageable){
    var text;
    text = damageable.getDamageText();
    allTexts.push(text);
    return owners.set(text, damageable);
  },
  update: function(elapsedTime){
    return allTexts = reject(function(text){
      var owner;
      if (!text.expired) {
        owner = owners.get(text);
        text.setPosition(owner.centerX, owner.centerY);
      }
      return text.update(elapsedTime);
    });
  },
  draw: function(graphics){
    var i$, ref$, len$, text, results$ = [];
    for (i$ = 0, len$ = (ref$ = allTexts).length; i$ < len$; ++i$) {
      text = ref$[i$];
      results$.push(text.draw(graphics));
    }
    return results$;
  }
};
},{"std":48}],15:[function(require,module,exports){
var std, InterfaceError, Damageable, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
InterfaceError = std.InterfaceError;
out$.Damageable = Damageable = (function(){
  Damageable.displayName = 'Damageable';
  var prototype = Damageable.prototype, constructor = Damageable;
  prototype.centerX = 0;
  prototype.centerY = 0;
  prototype.getDamageText = function(){
    throw new InterfaceError("Damageable - `get-damage-text` method not implemented");
  };
  function Damageable(){}
  return Damageable;
}());
},{"std":48}],16:[function(require,module,exports){
var std, units, kHalfTile, tpx, PolarVector, AnimatedSprite, kBaseVelocity, DeathCloudParticle, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
kHalfTile = units.kHalfTile, tpx = units.tileToPx;
PolarVector = require('./polar').PolarVector;
AnimatedSprite = require('./sprite').AnimatedSprite;
kBaseVelocity = 0.12;
out$.DeathCloudParticle = DeathCloudParticle = (function(){
  DeathCloudParticle.displayName = 'DeathCloudParticle';
  var prototype = DeathCloudParticle.prototype, constructor = DeathCloudParticle;
  function DeathCloudParticle(graphics, centerX, centerY, speed, angle){
    this.centerX = centerX;
    this.centerY = centerY;
    this.speed = speed;
    this.offset = new PolarVector(0, angle);
    this.sprite = new AnimatedSprite(graphics, 'Npc/NpcSym', tpx(1), tpx(0), tpx(1), tpx(1), 18, 7);
  }
  prototype.update = function(elapsedTime){
    this.sprite.update(elapsedTime);
    this.offset.mag += elapsedTime * this.speed;
    return this.sprite.numCompletedLoops === 0;
  };
  prototype.draw = function(graphics){
    return this.sprite.draw(graphics, this.centerX + this.offset.x - kHalfTile, this.centerY + this.offset.y - kHalfTile);
  };
  DeathCloudParticle.createRandomDeathClouds = function(ptools, centerX, centerY, num){
    var i$, ix, randomAngle, randomSpeed, results$ = [];
    for (i$ = 0; i$ < num; ++i$) {
      ix = i$;
      randomAngle = std.rand(0, std.tau);
      randomSpeed = kBaseVelocity * std.rand(0, 2);
      results$.push(ptools.entitySystem.addNewParticle(new DeathCloudParticle(ptools.graphics, centerX, centerY, randomSpeed, randomAngle)));
    }
    return results$;
  };
  return DeathCloudParticle;
}());
},{"./polar":33,"./sprite":45,"./units":50,"std":48}],17:[function(require,module,exports){
var std, units, config, tpx, tileToGame, kHalfTile, Damageable, DamageText, DamageTexts, ref$, Sprite, AnimatedSprite, Rect, RIGHT, LEFT, kAngularVelocity, kFlyFps, kNumFlyFrames, kContactDamage, SpriteState, FirstCaveBat, slice$ = [].slice, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
config = require('./config');
tpx = units.tileToPx, tileToGame = units.tileToGame, kHalfTile = units.kHalfTile;
Damageable = require('./damageable').Damageable;
DamageText = require('./damage-text').DamageText;
DamageTexts = require('./damage-texts').DamageTexts;
ref$ = require('./sprite'), Sprite = ref$.Sprite, AnimatedSprite = ref$.AnimatedSprite;
Rect = require('./rectangle').Rectangle;
RIGHT = "R";
LEFT = "L";
kAngularVelocity = 120 / 1000;
kFlyFps = 15;
kNumFlyFrames = 3;
kContactDamage = 1;
SpriteState = function(){
  var args;
  args = slice$.call(arguments);
  return String(args.join('-'));
};
out$.FirstCaveBat = FirstCaveBat = (function(superclass){
  var prototype = extend$((import$(FirstCaveBat, superclass).displayName = 'FirstCaveBat', FirstCaveBat), superclass).prototype, constructor = FirstCaveBat;
  function FirstCaveBat(graphics, x, flightCenterY){
    this.x = x;
    this.flightCenterY = flightCenterY;
    this.y = this.flightCenterY;
    this.flightAngle = 0;
    this.alive = true;
    this.angularVelocity = kAngularVelocity;
    this.sprites = this.initialiseSprites(graphics);
    this.damageText = new DamageText(graphics);
    this.contactDamage = kContactDamage;
    DamageTexts.addDamageable(this);
  }
  Object.defineProperty(prototype, 'spritestate', {
    get: function(){
      return SpriteState(this.horizontalFacing);
    },
    configurable: true,
    enumerable: true
  });
  prototype.initialiseSprite = function(graphics, facing){
    var facingOffset;
    facingOffset = facing === RIGHT ? 1 : 0;
    return new AnimatedSprite(graphics, 'Npc/NpcCemet', tpx(2), tpx(2 + facingOffset), tpx(1), tpx(1), kFlyFps, kNumFlyFrames);
  };
  prototype.initialiseSprites = function(graphics, spriteMap){
    var i$, ref$, len$, facing;
    spriteMap == null && (spriteMap = {});
    for (i$ = 0, len$ = (ref$ = [LEFT, RIGHT]).length; i$ < len$; ++i$) {
      facing = ref$[i$];
      spriteMap[SpriteState(facing)] = this.initialiseSprite(graphics, facing);
    }
    return spriteMap;
  };
  prototype.update = function(elapsedTime, playerX){
    this.horizontalFacing = playerX < this.x ? LEFT : RIGHT;
    this.flightAngle += this.angularVelocity * elapsedTime;
    this.y = this.flightCenterY + units.tileToGame(5) / 2 * std.sin(units.degToRad(this.flightAngle));
    this.sprites[this.spritestate].update(elapsedTime);
    return this.alive;
  };
  prototype.draw = function(graphics){
    if (config.showCollisions) {
      graphics.visualiseRect(this.collisionRectangle());
    }
    return this.sprites[this.spritestate].draw(graphics, this.x, this.y);
  };
  prototype.damageCollision = function(){
    return new Rect(this.centerX, this.centerY, 1, 1);
  };
  prototype.collisionRectangle = function(){
    return new Rect(this.x, this.y, tileToGame(1), tileToGame(1));
  };
  prototype.takeDamage = function(damage){
    this.damageText.setDamage(damage);
    return this.alive = false;
  };
  Object.defineProperty(prototype, 'centerX', {
    get: function(){
      return this.x + kHalfTile;
    },
    configurable: true,
    enumerable: true
  });
  Object.defineProperty(prototype, 'centerY', {
    get: function(){
      return this.y + kHalfTile;
    },
    configurable: true,
    enumerable: true
  });
  prototype.getDamageText = function(){
    return this.damageText;
  };
  return FirstCaveBat;
}(Damageable));
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{"./config":12,"./damage-text":13,"./damage-texts":14,"./damageable":15,"./rectangle":36,"./sprite":45,"./units":50,"std":48}],18:[function(require,module,exports){
var std, SDL, input, units, config, readout, graphics, Map, tileToGame, Timer, Player, Pickups, Rectangle, FirstCaveBat, FixedBackdrop, DamageTexts, ParticleTools, StarParticle, DeathCloudParticle, ref$, PowerDorito, Pickup, kScreenWidth, kScreenHeight, kFps, kMaxFrameTime, kDebugMode, running, player, bat, map, ptools, pickups, timeFactor, lastFrameTime, anyKeysPressed, eventLoop, update, draw, createTestWorld, start, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
SDL = require('SDL');
input = require('./input');
units = require('./units');
config = require('./config');
readout = require('./readout');
graphics = require('./graphics');
Map = require('./map');
tileToGame = units.tileToGame;
Timer = require('./timer').Timer;
Player = require('./player').Player;
Pickups = require('./pickups').Pickups;
Rectangle = require('./rectangle').Rectangle;
FirstCaveBat = require('./first-cave-bat').FirstCaveBat;
FixedBackdrop = require('./backdrop').FixedBackdrop;
DamageTexts = require('./damage-texts').DamageTexts;
ParticleTools = require('./particle-system').ParticleTools;
StarParticle = require('./star-particle').StarParticle;
DeathCloudParticle = require('./death-cloud-particle').DeathCloudParticle;
ref$ = require('./pickup'), PowerDorito = ref$.PowerDorito, Pickup = ref$.Pickup;
kScreenWidth = config.kScreenWidth, kScreenHeight = config.kScreenHeight, kFps = config.kFps, kMaxFrameTime = config.kMaxFrameTime, kDebugMode = config.kDebugMode;
running = true;
player = null;
bat = null;
map = null;
ptools = null;
pickups = null;
timeFactor = 1;
lastFrameTime = 0;
anyKeysPressed = false;
eventLoop = function(){
  var startTime, event, Δt, elapsedTime;
  startTime = SDL.getTicks();
  input.beginNewFrame();
  while (event = SDL.pollEvent()) {
    anyKeysPressed = true;
    readout.update('willstop', false);
    switch (event.type) {
    case SDL.KEYDOWN:
      input.keyDownEvent(event);
      break;
    case SDL.KEYUP:
      input.keyUpEvent(event);
      break;
    default:
      throw new Error({
        message: "Unknown event type: " + event
      });
    }
  }
  if (input.wasKeyPressed(SDL.KEY.ESCAPE)) {
    running = false;
  }
  if (input.isKeyHeld(SDL.KEY.LEFT) && input.isKeyHeld(SDL.KEY.RIGHT)) {
    player.stopMoving();
  } else if (input.isKeyHeld(SDL.KEY.LEFT)) {
    player.startMovingLeft();
  } else if (input.isKeyHeld(SDL.KEY.RIGHT)) {
    player.startMovingRight();
  } else {
    player.stopMoving();
  }
  if (input.wasKeyPressed(SDL.KEY.Z)) {
    player.startJump();
  } else if (input.wasKeyReleased(SDL.KEY.Z)) {
    player.stopJump();
  }
  if (input.wasKeyPressed(SDL.KEY.X)) {
    player.startFire();
  } else if (input.wasKeyReleased(SDL.KEY.X)) {
    player.stopFire();
  }
  if (input.isKeyHeld(SDL.KEY.UP) && input.isKeyHeld(SDL.KEY.DOWN)) {
    player.lookHorizontal();
  } else if (input.isKeyHeld(SDL.KEY.UP)) {
    player.lookUp();
  } else if (input.isKeyHeld(SDL.KEY.DOWN)) {
    player.lookDown();
  } else {
    player.lookHorizontal();
  }
  if (input.wasKeyPressed(SDL.KEY.ONE)) {
    timeFactor = 1;
  }
  if (input.wasKeyPressed(SDL.KEY.TWO)) {
    timeFactor = 2;
  }
  if (input.wasKeyPressed(SDL.KEY.THREE)) {
    timeFactor = 3;
  }
  if (input.wasKeyPressed(SDL.KEY.FOUR)) {
    timeFactor = 4;
  }
  Δt = std.min(SDL.getTicks() - lastFrameTime, kMaxFrameTime);
  update(Δt / timeFactor);
  draw();
  if (running) {
    lastFrameTime = SDL.getTicks();
    elapsedTime = lastFrameTime - startTime;
    readout.update('frametime', std.floor(1000 / Δt));
    readout.update('drawtime', elapsedTime);
    return SDL.delay(1000 / kFps - elapsedTime, eventLoop);
  } else {
    return std.log('Game stopped.');
  }
};
update = function(elapsedTime){
  var i$, ref$, len$, projectile;
  Timer.updateAll(elapsedTime);
  player.update(elapsedTime, map);
  if (bat && !(bat != null && bat.update(elapsedTime, player.x))) {
    pickups.add(new PowerDorito(graphics, bat.centerX, bat.centerY, Pickup.SMALL));
    DeathCloudParticle.createRandomDeathClouds(ptools, bat.centerX, bat.centerY, 3);
    bat = null;
  }
  for (i$ = 0, len$ = (ref$ = player.getProjectiles()).length; i$ < len$; ++i$) {
    projectile = ref$[i$];
    if (bat != null && bat.collisionRectangle().collidesWith(projectile.collisionRectangle())) {
      projectile.collideWithEnemy();
      bat.takeDamage(projectile.contactDamage);
    }
  }
  pickups.handleCollisions(player);
  if (bat != null && bat.damageCollision().collidesWith(player.damageCollision())) {
    player.takeDamage(bat.contactDamage);
  }
  DamageTexts.update(elapsedTime);
  pickups.update(elapsedTime, map);
  return ptools.update(elapsedTime);
};
draw = function(){
  graphics.clear();
  map.drawBackground(graphics);
  if (bat != null) {
    bat.draw(graphics);
  }
  ptools.entitySystem.draw(graphics);
  pickups.draw(graphics);
  player.draw(graphics);
  map.draw(graphics);
  ptools.frontSystem.draw(graphics);
  DamageTexts.draw(graphics);
  return player.drawHud(graphics);
};
createTestWorld = function(){
  map = Map.createTestMap(graphics);
  ptools = new ParticleTools(graphics);
  player = new Player(graphics, units.tileToGame(kScreenWidth / 2), units.tileToGame(10), ptools);
  bat = new FirstCaveBat(graphics, units.tileToGame(7), units.tileToGame(8));
  return pickups = new Pickups;
};
out$.start = start = function(){
  SDL.init(SDL.INIT_EVERYTHING);
  readout.addReader('frametime', 'Frame time');
  readout.addReader('drawtime', 'Draw time');
  readout.addReader('willstop', 'Will stop', true);
  createTestWorld();
  eventLoop();
  return std.delay(5000, function(){
    if (!anyKeysPressed) {
      return running = false;
    } else {
      return std.log("Game being interacted with. Don't shut down");
    }
  });
};
},{"./backdrop":10,"./config":12,"./damage-texts":14,"./death-cloud-particle":16,"./first-cave-bat":17,"./graphics":19,"./input":24,"./map":27,"./particle-system":28,"./pickup":30,"./pickups":31,"./player":32,"./readout":35,"./rectangle":36,"./star-particle":47,"./timer":49,"./units":50,"SDL":39,"std":48}],19:[function(require,module,exports){
var std, SDL, config, units, kScreenWidth, kScreenHeight, kTransparentColor, kScreenScaleFactor, spritesheets, screen, loadImage, blitSurface, clear, visualiseRect, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
SDL = require('SDL');
config = require('./config');
units = require('./units');
kScreenWidth = config.kScreenWidth, kScreenHeight = config.kScreenHeight;
kTransparentColor = [0, 0, 0];
kScreenScaleFactor = config.kGraphicsQuality === 16 ? 2 : 1;
spritesheets = {};
screen = SDL.setVideoMode(units.tileToPx(kScreenWidth), units.tileToPx(kScreenHeight), kScreenScaleFactor);
out$.loadImage = loadImage = function(filename, useTransparency){
  useTransparency == null && (useTransparency = false);
  if (spritesheets[filename] == null) {
    spritesheets[filename] = SDL.loadImage(config.findAsset(filename));
    if (useTransparency) {
      SDL.setColorKey(spritesheets[filename], kTransparentColor);
    }
    if (config.showSpritesheets) {
      document.body.appendChild(spritesheets[filename].canvas);
    }
  }
  return spritesheets[filename];
};
out$.blitSurface = blitSurface = function(source, srcRect, destRect){
  return SDL.blitSurface(source, srcRect, screen, destRect);
};
out$.clear = clear = bind$(screen, 'clear');
out$.visualiseRect = visualiseRect = function(rect, fill){
  var paintRect;
  paintRect = new SDL.Rect(units.gameToPx(rect.left), units.gameToPx(rect.top), units.gameToPx(rect.w), units.gameToPx(rect.h));
  if (fill) {
    return screen.drawRect(paintRect, 'red');
  } else {
    return screen.drawBox(paintRect, 'red');
  }
};
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}
},{"./config":12,"./units":50,"SDL":39,"std":48}],20:[function(require,module,exports){
var std, units, div, tileToGame, tpx, gameToPx, kHalfTile, Timer, ref$, Sprite, NumberSprite, VaryingWidthSprite, kDrawY, kLvDrawX, kBarDrawX, kLvlNumDrawX, kFlashTime, kFlashPeriod, kSpriteName, kBarSrcWidth, kBarSrcHeight, kBarSrcX, kBarSrcY, kFlashSrcX, kFlashSrcY, kMaxSrcX, kMaxSrcY, kFillSrcX, kFillSrcY, kLvlSrcX, kLvlSrcY, kLvlSrcWidth, kLvlSrcHeight, GunExperienceHUD, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
div = std.div;
tileToGame = units.tileToGame, tpx = units.tileToPx, gameToPx = units.gameToPx, kHalfTile = units.kHalfTile;
Timer = require('./timer').Timer;
ref$ = require('./sprite'), Sprite = ref$.Sprite, NumberSprite = ref$.NumberSprite, VaryingWidthSprite = ref$.VaryingWidthSprite;
kDrawY = tileToGame(1.5);
kLvDrawX = tileToGame(1.0);
kBarDrawX = tileToGame(2.5);
kLvlNumDrawX = tileToGame(2.0);
kFlashTime = 800;
kFlashPeriod = 40;
kSpriteName = 'TextBox';
kBarSrcWidth = 2.5;
kBarSrcHeight = 0.5;
kBarSrcX = 0.0;
kBarSrcY = 4.5;
kFlashSrcX = 2.5;
kFlashSrcY = 5.0;
kMaxSrcX = 2.5;
kMaxSrcY = 4.5;
kFillSrcX = 0.0;
kFillSrcY = 5.0;
kLvlSrcX = tileToGame(5);
kLvlSrcY = 160;
kLvlSrcWidth = tileToGame(1);
kLvlSrcHeight = tileToGame(0.5);
out$.GunExperienceHUD = GunExperienceHUD = (function(){
  GunExperienceHUD.displayName = 'GunExperienceHUD';
  var prototype = GunExperienceHUD.prototype, constructor = GunExperienceHUD;
  function GunExperienceHUD(graphics, levelXp, maxXp){
    this.xpBarSprite = new Sprite(graphics, kSpriteName, tpx(kBarSrcX), tpx(kBarSrcY), tpx(kBarSrcWidth), tpx(kBarSrcHeight));
    this.lvSprite = new Sprite(graphics, kSpriteName, gameToPx(kLvlSrcX), gameToPx(kLvlSrcY), gameToPx(kLvlSrcWidth), gameToPx(kLvlSrcHeight));
    this.flashSprite = new Sprite(graphics, kSpriteName, tpx(kFlashSrcX), tpx(kFlashSrcY), tpx(kBarSrcWidth), tpx(kBarSrcHeight));
    this.maxSprite = new Sprite(graphics, kSpriteName, tpx(kMaxSrcX), tpx(kMaxSrcY), tpx(kBarSrcWidth), tpx(kBarSrcHeight));
    this.fillSprite = new VaryingWidthSprite(graphics, kSpriteName, tpx(kFillSrcX), tpx(kFillSrcY), tpx(kBarSrcWidth), tpx(kBarSrcHeight));
    this.flashTimer = new Timer(kFlashTime);
  }
  prototype.activateFlash = function(){
    return this.flashTimer.reset();
  };
  prototype.draw = function(graphics, gunLvl, currentXp, levelXp){
    this.lvSprite.draw(graphics, kLvDrawX, kDrawY);
    this.xpBarSprite.draw(graphics, kBarDrawX, kDrawY);
    NumberSprite.HUDNumber(graphics, gunLvl, 1).draw(graphics, kLvlNumDrawX, kDrawY);
    if (currentXp < levelXp) {
      this.fillSprite.setPercentageWidth(currentXp / levelXp);
      this.fillSprite.draw(graphics, kBarDrawX, kDrawY);
    } else {
      this.maxSprite.draw(graphics, kBarDrawX, kDrawY);
    }
    if (this.flashTimer.isActive && div(this.flashTimer.currentTime, kFlashPeriod) % 2 === 0) {
      return this.flashSprite.draw(graphics, kBarDrawX, kDrawY);
    }
  };
  return GunExperienceHUD;
}());
},{"./sprite":45,"./timer":49,"./units":50,"std":48}],21:[function(require,module,exports){
var std, units, px, Timer, Particle, Sprite, PolarVector, Rectangle, kFlashPeriod, kLifeTime, kSpeed, HeadBumpParticle, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
px = units.gameToPx;
Timer = require('./timer').Timer;
Particle = require('./particle').Particle;
Sprite = require('./sprite').Sprite;
PolarVector = require('./polar').PolarVector;
Rectangle = require('./rectangle').Rectangle;
kFlashPeriod = 25;
kLifeTime = 700;
kSpeed = 0.12;
out$.HeadBumpParticle = HeadBumpParticle = (function(superclass){
  var prototype = extend$((import$(HeadBumpParticle, superclass).displayName = 'HeadBumpParticle', HeadBumpParticle), superclass).prototype, constructor = HeadBumpParticle;
  function HeadBumpParticle(graphics, centerX, centerY){
    this.centerX = centerX;
    this.centerY = centerY;
    this.lifeTimer = new Timer(kLifeTime, true);
    this.particleA = new PolarVector(0, std.rand(0, std.tau));
    this.particleB = new PolarVector(0, std.rand(0, std.tau));
    this.maxOffsetA = std.floor(std.rand(4, 20));
    this.maxOffsetB = std.floor(std.rand(4, 20));
    this.sprite = new Sprite(graphics, 'Caret', px(116), px(54), px(6), px(6));
  }
  prototype.update = function(elapsedTime){
    this.particleA.mag = std.min(this.maxOffsetA, this.particleA.mag + elapsedTime * kSpeed);
    this.particleB.mag = std.min(this.maxOffsetB, this.particleB.mag + elapsedTime * kSpeed);
    return this.lifeTimer.active();
  };
  prototype.draw = function(graphics){
    if ((this.lifeTimer.currentTime / kFlashPeriod) % 2 < 1) {
      this.sprite.draw(graphics, this.centerX + this.particleA.x, this.centerY + this.particleA.y);
      return this.sprite.draw(graphics, this.centerX + this.particleB.x, this.centerY + this.particleB.y);
    }
  };
  return HeadBumpParticle;
}(Particle));
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{"./particle":29,"./polar":33,"./rectangle":36,"./sprite":45,"./timer":49,"./units":50,"std":48}],22:[function(require,module,exports){
var std, units, div, kHalfTile, pxToTile, tpx, pxToGame, tileToGame, Timer, ref$, Sprite, NumberSprite, VaryingWidthSprite, kHealthBarX, kHealthBarY, kHealthFillX, kHealthFillY, kHealthNumX, kHealthNumY, kMaxFillPx, kDamageDelay, kSpritePath, kBarSrcX, kBarSrcY, kFillSrcY, kDamageSrcY, kBarSrcWidth, kBarSrcHeight, Health, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
div = std.div;
kHalfTile = units.kHalfTile, pxToTile = units.pxToTile, tpx = units.tileToPx, pxToGame = units.pxToGame, tileToGame = units.tileToGame;
Timer = require('./timer').Timer;
ref$ = require('./sprite'), Sprite = ref$.Sprite, NumberSprite = ref$.NumberSprite, VaryingWidthSprite = ref$.VaryingWidthSprite;
kHealthBarX = tileToGame(1);
kHealthBarY = tileToGame(2);
kHealthFillX = tileToGame(2.5);
kHealthFillY = tileToGame(2);
kHealthNumX = tileToGame(1.5);
kHealthNumY = tileToGame(2);
kMaxFillPx = tpx(2.5) - 1;
kDamageDelay = 1500;
kSpritePath = 'TextBox';
kBarSrcX = 0;
kBarSrcY = 2.5;
kFillSrcY = 1.5;
kDamageSrcY = 2;
kBarSrcWidth = 4;
kBarSrcHeight = 0.5;
out$.Health = Health = (function(){
  Health.displayName = 'Health';
  var prototype = Health.prototype, constructor = Health;
  function Health(graphics, maxHealth){
    this.maxHealth = maxHealth != null ? maxHealth : 6;
    this.currentHealth = this.maxHealth;
    this.damage = 0;
    this.damageTimer = new Timer(kDamageDelay);
    this.healthBarSprite = new Sprite(graphics, kSpritePath, tpx(kBarSrcX), tpx(kBarSrcY), tpx(kBarSrcWidth), tpx(kBarSrcHeight));
    this.healthFillSprite = new VaryingWidthSprite(graphics, kSpritePath, tpx(kBarSrcX), tpx(kFillSrcY), kMaxFillPx, tpx(kBarSrcHeight), kMaxFillPx);
    this.damageFillSprite = new VaryingWidthSprite(graphics, kSpritePath, tpx(kBarSrcX), tpx(kDamageSrcY), kMaxFillPx, tpx(kBarSrcHeight), kMaxFillPx);
  }
  prototype.update = function(elapsedTime){
    if (this.damage > 0 && this.damageTimer.isExpired) {
      this.currentHealth = std.max(0, this.currentHealth - this.damage);
      return this.damage = 0;
    }
  };
  prototype.draw = function(graphics){
    this.healthBarSprite.draw(graphics, kHealthBarX, kHealthBarY);
    if (this.currentHealth !== 0) {
      if (this.damage) {
        this.damageFillSprite.draw(graphics, kHealthFillX, kHealthFillY);
      }
      this.healthFillSprite.draw(graphics, kHealthFillX, kHealthFillY);
    }
    return new NumberSprite.HUDNumber(graphics, this.currentHealth, 2).draw(graphics, kHealthNumX, kHealthNumY);
  };
  prototype.takeDamage = function(damage){
    if (this.currentHealth === 0) {
      return;
    }
    this.damageTimer.reset();
    this.healthFillSprite.setPercentageWidth((this.currentHealth - damage) / this.maxHealth);
    this.damageFillSprite.setPercentageWidth(this.currentHealth / this.maxHealth);
    this.damage = damage;
    return this.currentHealth - damage <= 0;
  };
  return Health;
}());
},{"./sprite":45,"./timer":49,"./units":50,"std":48}],23:[function(require,module,exports){
var std, AnimatedSprite, ImmobileSingleLoopParticle, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
AnimatedSprite = require('./sprite').AnimatedSprite;
out$.ImmobileSingleLoopParticle = ImmobileSingleLoopParticle = (function(){
  ImmobileSingleLoopParticle.displayName = 'ImmobileSingleLoopParticle';
  var prototype = ImmobileSingleLoopParticle.prototype, constructor = ImmobileSingleLoopParticle;
  function ImmobileSingleLoopParticle(graphics, x, y, spritePath, srcX, srcY, srcW, srcH, fps, frames){
    this.x = x;
    this.y = y;
    this.sprite = new AnimatedSprite(graphics, spritePath, srcX, srcY, srcW, srcH, fps, frames);
  }
  prototype.update = function(elapsedTime){
    this.sprite.update(elapsedTime);
    return this.sprite.numCompletedLoops === 0;
  };
  prototype.draw = function(graphics){
    return this.sprite.draw(graphics, this.x, this.y);
  };
  return ImmobileSingleLoopParticle;
}());
},{"./sprite":45,"std":48}],24:[function(require,module,exports){
var std, Input;
std = require('std');
Input = (function(){
  Input.displayName = 'Input';
  var prototype = Input.prototype, constructor = Input;
  function Input(){
    this.heldKeys = {};
    this.pressedKeys = {};
    this.releasedKeys = {};
  }
  prototype.beginNewFrame = function(){
    this.pressedKeys = {};
    return this.releasedKeys = {};
  };
  prototype.keyDownEvent = function(event){
    this.pressedKeys[event.key] = true;
    return this.heldKeys[event.key] = true;
  };
  prototype.keyUpEvent = function(event){
    this.releasedKeys[event.key] = true;
    return this.heldKeys[event.key] = false;
  };
  prototype.wasKeyPressed = function(key){
    return this.pressedKeys[key];
  };
  prototype.wasKeyReleased = function(key){
    return this.releasedKeys[key];
  };
  prototype.isKeyHeld = function(key){
    return this.heldKeys[key];
  };
  return Input;
}());
module.exports = new Input;
},{"std":48}],25:[function(require,module,exports){
var std, units, Kinematics, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
out$.Kinematics = Kinematics = (function(){
  Kinematics.displayName = 'Kinematics';
  var prototype = Kinematics.prototype, constructor = Kinematics;
  function Kinematics(position, velocity){
    this.position = position;
    this.velocity = velocity;
  }
  prototype.delta = function(elapsedTime){
    return this.velocity * elapsedTime;
  };
  return Kinematics;
}());
},{"./units":50,"std":48}],26:[function(require,module,exports){
var std, units, InterfaceError, WALL_TILE, ref$, TOP, BOTTOM, LEFT, RIGHT, Side, topBox, leftBox, rightBox, bottomBox, MapCollidable, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
InterfaceError = std.InterfaceError;
WALL_TILE = require('./map').WALL_TILE;
ref$ = std['enum'], TOP = ref$[0], BOTTOM = ref$[1], LEFT = ref$[2], RIGHT = ref$[3];
out$.Side = Side = {
  TOP: TOP,
  BOTTOM: BOTTOM,
  LEFT: LEFT,
  RIGHT: RIGHT
};
topBox = function(rect, x, y, Δ){
  return rect.topCollision(x.position, y.position, Δ);
};
leftBox = function(rect, x, y, Δ){
  return rect.leftCollision(x.position, y.position, Δ);
};
rightBox = function(rect, x, y, Δ){
  return rect.rightCollision(x.position, y.position, Δ);
};
bottomBox = function(rect, x, y, Δ){
  return rect.bottomCollision(x.position, y.position, Δ);
};
out$.MapCollidable = MapCollidable = (function(){
  MapCollidable.displayName = 'MapCollidable';
  var prototype = MapCollidable.prototype, constructor = MapCollidable;
  function MapCollidable(){}
  prototype.onCollision = function(){
    throw new InterfaceError("MapCollidable - `on-collision` method not implemented");
  };
  prototype.onDelta = function(){
    throw new InterfaceError("MapCollidable - `on-delta` method not implemented");
  };
  prototype.onWallCollision = function(map, rect, λ){
    var i$, ref$, len$, tile;
    for (i$ = 0, len$ = (ref$ = map.getCollidingTiles(rect)).length; i$ < len$; ++i$) {
      tile = ref$[i$];
      if (tile.type === WALL_TILE) {
        return λ.call(this, tile);
      }
    }
    return λ.call(this);
  };
  prototype.updateX = function(rect, acc, kx, ky, elapsedTime, map){
    var Δx;
    acc.updateVelocity(kx, elapsedTime);
    Δx = kx.velocity * elapsedTime;
    if (Δx > 0) {
      this.onWallCollision(map, rightBox(rect, kx, ky, Δx), function(tile){
        if (tile) {
          kx.position = units.tileToGame(tile.col) - rect.boundingBox.right;
          return this.onCollision(Side.RIGHT, true);
        } else {
          kx.position += Δx;
          return this.onDelta(Side.RIGHT);
        }
      });
      return this.onWallCollision(map, leftBox(rect, kx, ky, 0), function(tile){
        if (tile) {
          kx.position = units.tileToGame(tile.col + 1) - rect.boundingBox.left;
          return this.onCollision(Side.LEFT, false);
        }
      });
    } else {
      this.onWallCollision(map, leftBox(rect, kx, ky, Δx), function(tile){
        if (tile) {
          kx.position = units.tileToGame(tile.col + 1) - rect.boundingBox.left;
          return this.onCollision(Side.LEFT, true);
        } else {
          kx.position += Δx;
          return this.onDelta(Side.LEFT);
        }
      });
      return this.onWallCollision(map, rightBox(rect, kx, ky, 0), function(tile){
        if (tile) {
          kx.position = units.tileToGame(tile.col) - rect.boundingBox.right;
          return this.onCollision(Side.RIGHT, false);
        }
      });
    }
  };
  prototype.updateY = function(rect, acc, kx, ky, elapsedTime, map){
    var Δy;
    acc.updateVelocity(ky, elapsedTime);
    Δy = ky.velocity * elapsedTime;
    if (Δy > 0) {
      this.onWallCollision(map, bottomBox(rect, kx, ky, Δy), function(tile){
        if (tile) {
          ky.position = units.tileToGame(tile.row) - rect.boundingBox.bottom;
          return this.onCollision(Side.BOTTOM, true);
        } else {
          ky.position += Δy;
          return this.onDelta(Side.BOTTOM);
        }
      });
      return this.onWallCollision(map, topBox(rect, kx, ky, 0), function(tile){
        if (tile) {
          ky.position = units.tileToGame(tile.row + 1) + rect.boundingBox.top;
          return this.onCollision(Side.TOP, false);
        }
      });
    } else {
      this.onWallCollision(map, topBox(rect, kx, ky, Δy), function(tile){
        if (tile) {
          ky.position = units.tileToGame(tile.row + 1) + rect.boundingBox.top;
          this.onCollision(Side.TOP, true);
          return ky.position = units.tileToGame(tile.row + 1) + rect.boundingBox.top;
        } else {
          ky.position += Δy;
          return this.onDelta(Side.TOP);
        }
      });
      return this.onWallCollision(map, bottomBox(rect, kx, ky, 0), function(tile){
        if (tile) {
          ky.position = units.tileToGame(tile.row) - rect.boundingBox.bottom;
          return this.onCollision(Side.BOTTOM, false);
        }
      });
    }
  };
  return MapCollidable;
}());
},{"./map":27,"./units":50,"std":48}],27:[function(require,module,exports){
var std, units, div, tpx, gameToPx, tileToGame, Sprite, FixedBackdrop, ref$, AIR_TILE, WALL_TILE, kMapWidth, Tile, CollisionTile, Map;
std = require('std');
units = require('./units');
div = std.div;
tpx = units.tileToPx, gameToPx = units.gameToPx, tileToGame = units.tileToGame;
Sprite = require('./sprite').Sprite;
FixedBackdrop = require('./backdrop').FixedBackdrop;
ref$ = std['enum'], AIR_TILE = ref$[0], WALL_TILE = ref$[1];
kMapWidth = 20;
Tile = (function(){
  Tile.displayName = 'Tile';
  var prototype = Tile.prototype, constructor = Tile;
  function Tile(type, sprite){
    this.type = type != null ? type : AIR_TILE;
    this.sprite = sprite;
  }
  return Tile;
}());
CollisionTile = (function(){
  CollisionTile.displayName = 'CollisionTile';
  var prototype = CollisionTile.prototype, constructor = CollisionTile;
  function CollisionTile(row, col, type){
    this.row = row;
    this.col = col;
    this.type = type;
  }
  return CollisionTile;
}());
module.exports = Map = (function(){
  Map.displayName = 'Map';
  var prototype = Map.prototype, constructor = Map;
  function Map(){
    this.backdrop = null;
    this.tiles = Map.createMatrix(new Tile, kMapWidth, 15);
    this.bgTiles = Map.createMatrix(null, kMapWidth, 15);
  }
  prototype.draw = function(graphics){
    var i$, ref$, len$, y, row, lresult$, j$, len1$, x, tile, ref1$, results$ = [];
    for (i$ = 0, len$ = (ref$ = this.tiles).length; i$ < len$; ++i$) {
      y = i$;
      row = ref$[i$];
      lresult$ = [];
      for (j$ = 0, len1$ = row.length; j$ < len1$; ++j$) {
        x = j$;
        tile = row[j$];
        lresult$.push((ref1$ = tile.sprite) != null ? ref1$.draw(graphics, tileToGame(x), tileToGame(y)) : void 8);
      }
      results$.push(lresult$);
    }
    return results$;
  };
  prototype.drawBackground = function(graphics){
    var i$, ref$, len$, y, row, lresult$, j$, len1$, x, sprite, results$ = [];
    this.backdrop.draw(graphics);
    for (i$ = 0, len$ = (ref$ = this.bgTiles).length; i$ < len$; ++i$) {
      y = i$;
      row = ref$[i$];
      lresult$ = [];
      for (j$ = 0, len1$ = row.length; j$ < len1$; ++j$) {
        x = j$;
        sprite = row[j$];
        lresult$.push(sprite != null ? sprite.draw(graphics, tileToGame(x), tileToGame(y)) : void 8);
      }
      results$.push(lresult$);
    }
    return results$;
  };
  prototype.getCollidingTiles = function(rect){
    var firstRow, lastRow, firstCol, lastCol, collisionTiles, i$, row, j$, col;
    firstRow = div(gameToPx(rect.top), tpx(1));
    lastRow = div(gameToPx(rect.bottom), tpx(1));
    firstCol = div(gameToPx(rect.left), tpx(1));
    lastCol = div(gameToPx(rect.right), tpx(1));
    collisionTiles = [];
    for (i$ = firstRow; i$ <= lastRow; ++i$) {
      row = i$;
      for (j$ = firstCol; j$ <= lastCol; ++j$) {
        col = j$;
        if (row < 0 || col < 0 || col >= kMapWidth) {
          collisionTiles.push(new CollisionTile(row, col, WALL_TILE));
        } else {
          collisionTiles.push(new CollisionTile(row, col, this.tiles[row][col].type));
        }
      }
    }
    return collisionTiles;
  };
  Map.createTestMap = function(graphics){
    var map, bgPath, fgPath, numRows, numCols, row, tile, i$, col, chainTop, chainMid, chainBtm;
    map = new Map;
    bgPath = 'bkBlue';
    fgPath = 'Stage/PrtCave';
    map.backdrop = new FixedBackdrop(bgPath, graphics);
    numRows = 15;
    numCols = 20;
    row = 11;
    tile = new Tile(WALL_TILE, new Sprite(graphics, fgPath, tpx(1), tpx(0), tpx(1), tpx(1)));
    for (i$ = 0; i$ <= numCols; ++i$) {
      col = i$;
      map.tiles[row][col] = tile;
    }
    map.tiles[10][5] = tile;
    map.tiles[9][4] = tile;
    map.tiles[8][3] = tile;
    map.tiles[7][2] = tile;
    map.tiles[10][3] = tile;
    map.tiles[10][0] = tile;
    map.tiles[8][10] = tile;
    chainTop = new Sprite(graphics, fgPath, tpx(11), tpx(2), tpx(1), tpx(1));
    chainMid = new Sprite(graphics, fgPath, tpx(12), tpx(2), tpx(1), tpx(1));
    chainBtm = new Sprite(graphics, fgPath, tpx(13), tpx(2), tpx(1), tpx(1));
    map.bgTiles[8][2] = chainTop;
    map.bgTiles[9][2] = chainMid;
    map.bgTiles[10][2] = chainBtm;
    return map;
  };
  Map.createMatrix = function(value, cols, rows){
    var i$, y, lresult$, j$, z, results$ = [];
    for (i$ = 0; i$ <= rows; ++i$) {
      y = i$;
      lresult$ = [];
      for (j$ = 0; j$ <= cols; ++j$) {
        z = j$;
        lresult$.push(value);
      }
      results$.push(lresult$);
    }
    return results$;
  };
  Map.WALL_TILE = WALL_TILE;
  Map.AIR_TILE = AIR_TILE;
  return Map;
}());
},{"./backdrop":10,"./sprite":45,"./units":50,"std":48}],28:[function(require,module,exports){
var std, units, readout, ParticleTools, ParticleSystem, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
readout = require('./readout');
out$.ParticleTools = ParticleTools = (function(){
  ParticleTools.displayName = 'ParticleTools';
  var prototype = ParticleTools.prototype, constructor = ParticleTools;
  function ParticleTools(graphics){
    this.graphics = graphics;
    readout.addReader('particles', 'Particles', 0);
    this.entitySystem = new ParticleSystem;
    this.frontSystem = new ParticleSystem;
  }
  prototype.update = function(elapsedTime){
    readout.update('particles', this.entitySystem.particles.length + this.frontSystem.particles.length);
    this.entitySystem.update(elapsedTime);
    return this.frontSystem.update(elapsedTime);
  };
  return ParticleTools;
}());
out$.ParticleSystem = ParticleSystem = (function(){
  ParticleSystem.displayName = 'ParticleSystem';
  var prototype = ParticleSystem.prototype, constructor = ParticleSystem;
  function ParticleSystem(){
    this.particles = [];
  }
  prototype.addNewParticle = function(it){
    return this.particles.push(it);
  };
  prototype.update = function(elapsedTime){
    return this.particles = std.filter(function(it){
      return it.update(elapsedTime);
    }, this.particles);
  };
  prototype.draw = function(graphics){
    return this.particles.forEach(function(it){
      return it.draw(graphics);
    });
  };
  return ParticleSystem;
}());
},{"./readout":35,"./units":50,"std":48}],29:[function(require,module,exports){
var InterfaceError, Particle, out$ = typeof exports != 'undefined' && exports || this;
InterfaceError = (function(superclass){
  var prototype = extend$((import$(InterfaceError, superclass).displayName = 'InterfaceError', InterfaceError), superclass).prototype, constructor = InterfaceError;
  function InterfaceError(message){
    this.message = message;
    this.name = 'InterfaceError';
  }
  return InterfaceError;
}(Error));
out$.Particle = Particle = (function(){
  Particle.displayName = 'Particle';
  var prototype = Particle.prototype, constructor = Particle;
  prototype.update = function(elapsedTime){
    throw new InterfaceError("Particle - `update` not implemented");
  };
  prototype.draw = function(graphics){
    throw new InterfaceError("Particle - `draw` not implemented");
  };
  function Particle(){}
  return Particle;
}());
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{}],30:[function(require,module,exports){
var std, units, kHalfTile, tpx, Timer, Rectangle, Kinematics, AnimatedSprite, ref$, MapCollidable, Side, SimpleCollisionRectangle, FrictionAccelerator, kGravityAcc, HEALTH, MISSILES, EXPERIENCE, SMALL, MEDIUM, LARGE, Pickup, PowerDorito, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units'), kHalfTile = units.kHalfTile, tpx = units.tileToPx;
Timer = require('./timer').Timer;
Rectangle = require('./rectangle').Rectangle;
Kinematics = require('./kinematics').Kinematics;
AnimatedSprite = require('./sprite').AnimatedSprite;
ref$ = require('./map-collidable'), MapCollidable = ref$.MapCollidable, Side = ref$.Side;
SimpleCollisionRectangle = require('./collision-rectangle').SimpleCollisionRectangle;
ref$ = require('./accelerators'), FrictionAccelerator = ref$.FrictionAccelerator, kGravityAcc = ref$.kGravityAcc;
ref$ = std['enum'], HEALTH = ref$[0], MISSILES = ref$[1], EXPERIENCE = ref$[2];
ref$ = std['enum'], SMALL = ref$[0], MEDIUM = ref$[1], LARGE = ref$[2];
out$.Pickup = Pickup = (function(){
  Pickup.displayName = 'Pickup';
  var prototype = Pickup.prototype, constructor = Pickup;
  Pickup.SMALL = SMALL;
  Pickup.MEDIUM = MEDIUM;
  Pickup.LARGE = LARGE;
  function Pickup(type, value){
    this.type = type;
    this.value = value;
    this.collisonRectangle = new Rectangle;
  }
  prototype.draw = function(graphics){};
  prototype.update = function(elapsedTime){};
  return Pickup;
}());
out$.PowerDorito = PowerDorito = (function(superclass){
  var kValues, kSpriteName, kSourceX, kSourceYs, kSourceWidth, kSourceHeight, kFps, kNumFrames, kLifetime, kFlashtime, kFlashPeriod, kBounceSpeed, kFriction, kCollisionRectangles, prototype = extend$((import$(PowerDorito, superclass).displayName = 'PowerDorito', PowerDorito), superclass).prototype, constructor = PowerDorito;
  importAll$(prototype, arguments[1]);
  kValues = [1, 5, 20];
  kSpriteName = 'Npc/NpcSym';
  kSourceX = 0;
  kSourceYs = [1, 2, 3];
  kSourceWidth = 1;
  kSourceHeight = 1;
  kFps = 14;
  kNumFrames = 6;
  kLifetime = 8000;
  kFlashtime = 7000;
  kFlashPeriod = 50;
  kBounceSpeed = 0.225;
  kFriction = new FrictionAccelerator(0.00002);
  kCollisionRectangles = [new SimpleCollisionRectangle(new Rectangle(8, 8, 16, 16)), new SimpleCollisionRectangle(new Rectangle(4, 4, 24, 24)), new SimpleCollisionRectangle(new Rectangle(0, 0, 32, 32))];
  function PowerDorito(graphics, centerX, centerY, size){
    this.centerX = centerX;
    this.centerY = centerY;
    this.size = size != null ? size : SMALL;
    PowerDorito.superclass.call(this, EXPERIENCE, kValues[this.size]);
    this.kinematicsX = new Kinematics(this.centerX - kHalfTile, 0.025 * std.rand(-5, 5));
    this.kinematicsY = new Kinematics(this.centerY - kHalfTile, 0.025 * std.rand(-5, 5));
    this.timer = new Timer(kLifetime, true);
    this.sprite = new AnimatedSprite(graphics, kSpriteName, tpx(kSourceX), tpx(kSourceYs[this.size]), tpx(kSourceWidth), tpx(kSourceHeight), kFps, kNumFrames);
  }
  prototype.draw = function(graphics){
    if (this.timer.currentTime < kFlashtime || std.div(this.timer.currentTime, kFlashPeriod) % 2 === 0) {
      this.sprite.draw(graphics, this.kinematicsX.position, this.kinematicsY.position);
    }
    return graphics.visualiseRect(this.collisionRectangle());
  };
  prototype.update = function(elapsedTime, map){
    this.sprite.update();
    this.updateY(kCollisionRectangles[this.size], kGravityAcc, this.kinematicsX, this.kinematicsY, elapsedTime, map);
    this.updateX(kCollisionRectangles[this.size], kFriction, this.kinematicsX, this.kinematicsY, elapsedTime, map);
    return this.timer.isActive;
  };
  prototype.collisionRectangle = function(){
    var box;
    box = kCollisionRectangles[this.size].boundingBox;
    return new Rectangle(this.kinematicsX.position + box.left, this.kinematicsY.position + box.top, box.w, box.h);
  };
  prototype.onCollision = function(side, isDeltaDirection){
    if (side === Side.TOP) {
      return this.kinematicsY.velocity = 0;
    } else if (side === Side.BOTTOM) {
      return this.kinematicsY.velocity = -kBounceSpeed;
    } else {
      return this.kinematicsX.velocity *= -1;
    }
  };
  prototype.onDelta = function(side){};
  return PowerDorito;
}(Pickup, MapCollidable.prototype));
Pickup.HEALTH = HEALTH;
Pickup.MISSILES = MISSILES;
Pickup.EXPERIENCE = EXPERIENCE;
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function importAll$(obj, src){
  for (var key in src) obj[key] = src[key];
  return obj;
}
},{"./accelerators":8,"./collision-rectangle":11,"./kinematics":25,"./map-collidable":26,"./rectangle":36,"./sprite":45,"./timer":49,"./units":50,"std":48}],31:[function(require,module,exports){
var std, units, Pickups, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
out$.Pickups = Pickups = (function(){
  Pickups.displayName = 'Pickups';
  var prototype = Pickups.prototype, constructor = Pickups;
  function Pickups(){
    this.pickups = [];
  }
  prototype.update = function(elapsedTime, map){
    return this.pickups = this.pickups.filter(function(it){
      return it.update(elapsedTime, map);
    });
  };
  prototype.add = function(pickup){
    return this.pickups.push(pickup);
  };
  prototype.draw = function(graphics){
    return this.pickups.map(function(it){
      return it.draw(graphics);
    });
  };
  prototype.handleCollisions = function(player){
    return this.pickups = this.pickups.filter(function(it){
      if (player.damageCollision().collidesWith(it.collisionRectangle())) {
        player.collectPickup(it);
        return false;
      }
      return true;
    });
  };
  return Pickups;
}());
},{"./units":50,"std":48}],32:[function(require,module,exports){
var std, units, config, readout, kHalfTile, tileToGame, tpx, Timer, Health, Pickup, Kinematics, Damageable, DamageText, DamageTexts, PolarStar, GunExperienceHUD, MapCollidable, ref$, SpriteState, State, Rect, HeadBumpParticle, CompositeCollisionRectangle, ConstantAccelerator, FrictionAccelerator, BidirectionalAccelerator, kZero, kGravity, kTerminalSpeed, Side, Sprite, AnimatedSprite, NumberSprite, kCharacterFrame, kWalkFrame, kStandFrame, kJumpFrame, kFallFrame, kUpFrameOffset, kDownFrame, kBackFrame, kNumWalkFrames, kWalkFps, kStrideMiddleFrameOffset, kStrideLeftFrameOffset, kStrideRightFrameOffset, kJumpSpeed, kShortJumpSpeed, kMaxSpeedX, kWalkAcc, kAirAcc, kGravityAcc, kFrictionAcc, kJumpGravityAcc, kInvincibleTime, kInvincibleFlashTime, kCollisionX, kCollisionYTop, kCollisionYHeight, kCollisionYTopWidth, kCollisionYBottomWidth, kCollisionYTopLeft, kCollisionYBottomLeft, kCollisionRectangle, WalkingAnimation, Player, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
config = require('./config');
readout = require('./readout');
kHalfTile = units.kHalfTile, tileToGame = units.tileToGame, tpx = units.tileToPx;
Timer = require('./timer').Timer;
Health = require('./health').Health;
Pickup = require('./pickup').Pickup;
Kinematics = require('./kinematics').Kinematics;
Damageable = require('./damageable').Damageable;
DamageText = require('./damage-text').DamageText;
DamageTexts = require('./damage-texts').DamageTexts;
PolarStar = require('./arms').PolarStar;
GunExperienceHUD = require('./gun-xp-hud').GunExperienceHUD;
MapCollidable = require('./map-collidable').MapCollidable;
ref$ = require('./spritestate'), SpriteState = ref$.SpriteState, State = ref$.State;
Rect = require('./rectangle').Rectangle;
HeadBumpParticle = require('./head-bump-particle').HeadBumpParticle;
CompositeCollisionRectangle = require('./collision-rectangle').CompositeCollisionRectangle;
ref$ = require('./accelerators'), ConstantAccelerator = ref$.ConstantAccelerator, FrictionAccelerator = ref$.FrictionAccelerator, BidirectionalAccelerator = ref$.BidirectionalAccelerator, kZero = ref$.kZero, kGravity = ref$.kGravity, kTerminalSpeed = ref$.kTerminalSpeed;
Side = require('./map-collidable').Side;
ref$ = require('./sprite'), Sprite = ref$.Sprite, AnimatedSprite = ref$.AnimatedSprite, NumberSprite = ref$.NumberSprite;
kCharacterFrame = 0;
kWalkFrame = 0;
kStandFrame = 0;
kJumpFrame = 1;
kFallFrame = 2;
kUpFrameOffset = 3;
kDownFrame = 6;
kBackFrame = 7;
kNumWalkFrames = 3;
kWalkFps = 15;
kStrideMiddleFrameOffset = 0;
kStrideLeftFrameOffset = 1;
kStrideRightFrameOffset = 2;
kJumpSpeed = 0.25;
kShortJumpSpeed = kJumpSpeed / 1.5;
kMaxSpeedX = 0.15859375;
kWalkAcc = new BidirectionalAccelerator(0.00083007812, kMaxSpeedX);
kAirAcc = new BidirectionalAccelerator(0.0003125, kMaxSpeedX);
kGravityAcc = new ConstantAccelerator(kGravity, kTerminalSpeed);
kFrictionAcc = new FrictionAccelerator(0.00049804687);
kJumpGravityAcc = new ConstantAccelerator(0.0003125, kTerminalSpeed);
kInvincibleTime = 3000;
kInvincibleFlashTime = 50;
kCollisionX = new Rect(6, 10, 20, 12);
kCollisionYTop = 2;
kCollisionYHeight = 30;
kCollisionYTopWidth = 18;
kCollisionYBottomWidth = 10;
kCollisionYTopLeft = (tileToGame(1) - kCollisionYTopWidth) / 2;
kCollisionYBottomLeft = (tileToGame(1) - kCollisionYBottomWidth) / 2;
kCollisionRectangle = new CompositeCollisionRectangle(new Rect(kCollisionYTopLeft, kCollisionYTop, kCollisionYTopWidth, kCollisionYHeight / 2), new Rect(kCollisionYBottomLeft, kCollisionYTop + kCollisionYHeight / 2, kCollisionYBottomWidth, kCollisionYHeight / 2), new Rect(6, 10, 10, 12), new Rect(16, 10, 10, 12));
WalkingAnimation = (function(){
  WalkingAnimation.displayName = 'WalkingAnimation';
  var prototype = WalkingAnimation.prototype, constructor = WalkingAnimation;
  function WalkingAnimation(numFrames, fps){
    this.numFrames = numFrames;
    this.fps = fps;
    this.frameTimer = new Timer(1000 / this.fps);
    this.forward = true;
    this.index = 0;
  }
  prototype.stride = function(){
    switch (this.index) {
    case 0:
      return State.STRIDE_LEFT;
    case 1:
      return State.STRIDE_MIDDLE;
    case 2:
      return State.STRIDE_RIGHT;
    default:
      return State.STRIDE_LEFT;
    }
  };
  prototype.update = function(){
    if (this.frameTimer.isExpired) {
      this.frameTimer.reset();
      if (this.forward) {
        this.index += 1;
        return this.forward = this.index !== this.numFrames - 1;
      } else {
        this.index -= 1;
        return this.forward = this.index === 0;
      }
    }
  };
  prototype.reset = function(){
    this.frameTimer.reset();
    this.index = 0;
    return this.forward = true;
  };
  return WalkingAnimation;
}());
out$.Player = Player = (function(){
  Player.displayName = 'Player';
  var prototype = Player.prototype, constructor = Player;
  importAll$(prototype, arguments[0]);
  importAll$(prototype, arguments[1]);
  function Player(graphics, x, y, ptools){
    this.ptools = ptools;
    readout.addReader('player-pos', 'Player');
    this.accelerationX = 0;
    this.horizontalFacing = State.LEFT;
    this.intendedVerticalFacing = State.HORIZONTAL;
    this.onGround = false;
    this.jumpActive = false;
    this.interacting = false;
    this.kinematicsX = new Kinematics(x, 0);
    this.kinematicsY = new Kinematics(y, 0);
    this.walkAnimation = new WalkingAnimation(kNumWalkFrames, kWalkFps);
    this.invincibleTimer = new Timer(kInvincibleTime);
    this.health = new Health(graphics);
    this.gunHud = new GunExperienceHUD(graphics);
    this.sprites = this.initialiseSprites(graphics);
    this.damageText = new DamageText(graphics);
    DamageTexts.addDamageable(this);
    this.gun = new PolarStar(graphics);
  }
  prototype.initialiseSprites = function(graphics, spriteMap){
    spriteMap == null && (spriteMap = {});
    return SpriteState.generateWith(function(state){
      var tileX, tileY;
      tileX = (function(){
        switch (true) {
        case state.WALKING:
          return kWalkFrame;
        case state.STANDING:
          return kStandFrame;
        case state.JUMPING:
          return kJumpFrame;
        case state.FALLING:
          return kFallFrame;
        case state.INTERACTING:
          return kBackFrame;
        }
      }());
      if (state.UP) {
        tileX += kUpFrameOffset;
      }
      if (state.DOWN) {
        tileX = kDownFrame;
      }
      tileY = kCharacterFrame + (state.LEFT ? 0 : 1);
      if (state.WALKING) {
        tileX += (function(){
          switch (true) {
          case state.STRIDE_LEFT:
            return kStrideLeftFrameOffset;
          case state.STRIDE_RIGHT:
            return kStrideRightFrameOffset;
          case state.STRIDE_MIDDLE:
            return kStrideMiddleFrameOffset;
          }
        }());
      }
      return new Sprite(graphics, 'MyChar', tpx(tileX), tpx(tileY), tpx(1), tpx(1));
    });
  };
  prototype.update = function(elapsedTime, map){
    var accX, accY;
    this.health.update();
    this.walkAnimation.update(elapsedTime);
    this.gun.updateProjectiles(elapsedTime, map, this.ptools);
    readout.update('player-pos', std.round(this.centerX) + "," + std.round(this.centerY));
    accX = this.onGround
      ? this.accelerationX === 0
        ? kFrictionAcc
        : this.accelerationX < 0
          ? kWalkAcc.negative
          : kWalkAcc.positive
      : this.accelerationX === 0
        ? kZero
        : this.accelerationX < 0
          ? kAirAcc.negative
          : kAirAcc.positive;
    this.updateX(kCollisionRectangle, accX, this.kinematicsX, this.kinematicsY, elapsedTime, map);
    accY = this.jumpActive && this.kinematicsY.velocity < 0 ? kJumpGravityAcc : kGravityAcc;
    return this.updateY(kCollisionRectangle, accY, this.kinematicsX, this.kinematicsY, elapsedTime, map);
  };
  prototype.takeDamage = function(damage){
    damage == null && (damage = 1);
    if (!this.invincibleTimer.isActive) {
      this.health.takeDamage(damage);
      this.kinematicsY.velocity = std.min(-kShortJumpSpeed, this.kinematicsY.velocity);
      this.invincible = true;
      this.invincibleTimer.reset();
      return this.damageText.setDamage(damage);
    }
  };
  prototype.collectPickup = function(pickup){
    std.log('SFX: Ding!');
    std.log(pickup, Pickup.EXPERIENCE);
    if (pickup.type === Pickup.EXPERIENCE) {
      this.gun.collectExperience(pickup.value);
      return this.gunHud.activateFlash();
    }
  };
  prototype.spriteIsVisible = function(){
    var duty;
    duty = std.div(this.invincibleTimer.currentTime, kInvincibleFlashTime) % 2 === 0;
    return !(this.invincibleTimer.isActive && duty);
  };
  prototype.draw = function(graphics){
    var state;
    if (config.showCollisions) {
      graphics.visualiseRect(this.damageCollision());
    }
    if (this.spriteIsVisible()) {
      state = this.getSpriteState();
      this.gun.draw(graphics, this.kinematicsX.position, this.kinematicsY.position, state);
      return this.sprites[state.key].draw(graphics, this.kinematicsX.position, this.kinematicsY.position);
    }
  };
  prototype.drawHud = function(graphics){
    if (!this.spriteIsVisible()) {
      return;
    }
    this.gun.drawHud(graphics, this.gunHud);
    return this.health.draw(graphics);
  };
  prototype.getSpriteState = function(){
    var motionType;
    motionType = this.interacting
      ? State.INTERACTING
      : this.onGround
        ? this.accelerationX === 0
          ? State.STANDING
          : State.WALKING
        : this.kinematicsY.velocity < 0
          ? State.JUMPING
          : State.FALLING;
    return SpriteState.make(this.horizontalFacing, this.verticalFacing(), motionType, this.walkAnimation.stride());
  };
  prototype.onCollision = function(side, isDeltaDirection){
    switch (side) {
    case Side.TOP:
      if (isDeltaDirection) {
        this.kinematicsY.velocity = 0;
      }
      return this.ptools.frontSystem.addNewParticle(new HeadBumpParticle(this.ptools.graphics, this.centerX, this.kinematicsY.position + kCollisionRectangle.boundingBox.top));
    case Side.BOTTOM:
      this.onGround = true;
      if (isDeltaDirection) {
        return this.kinematicsY.velocity = 0;
      }
      break;
    case Side.LEFT:
      if (isDeltaDirection) {
        return this.kinematicsX.velocity = 0;
      }
      break;
    case Side.RIGHT:
      if (isDeltaDirection) {
        return this.kinematicsX.velocity = 0;
      }
    }
  };
  prototype.onDelta = function(side){
    switch (side) {
    case Side.TOP:
      return this.onGround = false;
    case Side.BOTTOM:
      return this.onGround = false;
    case Side.LEFT:
      break;
    case Side.RIGHT:
    }
  };
  prototype.damageCollision = function(){
    return kCollisionRectangle.boundingBox.translate(this.kinematicsX.position, this.kinematicsY.position);
  };
  prototype.startMovingLeft = function(){
    if (this.onGround && this.accelerationX === 0) {
      this.walkAnimation.reset();
    }
    this.horizontalFacing = State.LEFT;
    this.accelerationX = -1;
    return this.interacting = false;
  };
  prototype.startMovingRight = function(){
    if (this.onGround && this.accelerationX === 0) {
      this.walkAnimation.reset();
    }
    this.horizontalFacing = State.RIGHT;
    this.accelerationX = 1;
    return this.interacting = false;
  };
  prototype.stopMoving = function(){
    return this.accelerationX = 0;
  };
  prototype.startJump = function(){
    this.jumpActive = true;
    this.interacting = false;
    if (this.onGround) {
      return this.kinematicsY.velocity = -kJumpSpeed;
    }
  };
  prototype.stopJump = function(){
    return this.jumpActive = false;
  };
  prototype.startFire = function(){
    return this.gun.startFire(this.getSpriteState(), this.kinematicsX.position, this.kinematicsY.position);
  };
  prototype.stopFire = function(){
    return this.gun.stopFire();
  };
  prototype.lookUp = function(){
    this.intendedVerticalFacing = State.UP;
    return this.interacting = false;
  };
  prototype.lookDown = function(){
    if (this.intendedVerticalFacing === State.DOWN) {
      return;
    }
    this.intendedVerticalFacing = State.DOWN;
    return this.interacting = this.onGround;
  };
  prototype.lookHorizontal = function(){
    return this.intendedVerticalFacing = State.HORIZONTAL;
  };
  Object.defineProperty(prototype, 'centerX', {
    get: function(){
      return this.kinematicsX.position + kHalfTile;
    },
    configurable: true,
    enumerable: true
  });
  Object.defineProperty(prototype, 'centerY', {
    get: function(){
      return this.kinematicsY.position + kHalfTile;
    },
    configurable: true,
    enumerable: true
  });
  prototype.getDamageText = function(){
    return this.damageText;
  };
  prototype.getProjectiles = function(){
    return this.gun.getProjectiles();
  };
  prototype.verticalFacing = function(){
    if (this.onGround && this.intendedVerticalFacing === State.DOWN) {
      return State.HORIZONTAL;
    } else {
      return this.intendedVerticalFacing;
    }
  };
  return Player;
}(Damageable.prototype, MapCollidable.prototype));
function importAll$(obj, src){
  for (var key in src) obj[key] = src[key];
  return obj;
}
},{"./accelerators":8,"./arms":9,"./collision-rectangle":11,"./config":12,"./damage-text":13,"./damage-texts":14,"./damageable":15,"./gun-xp-hud":20,"./head-bump-particle":21,"./health":22,"./kinematics":25,"./map-collidable":26,"./pickup":30,"./readout":35,"./rectangle":36,"./sprite":45,"./spritestate":46,"./timer":49,"./units":50,"std":48}],33:[function(require,module,exports){
var std, PolarVector, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
out$.PolarVector = PolarVector = (function(){
  PolarVector.displayName = 'PolarVector';
  var prototype = PolarVector.prototype, constructor = PolarVector;
  function PolarVector(mag, angle){
    this.mag = mag;
    this.angle = angle;
  }
  Object.defineProperty(prototype, 'x', {
    get: function(){
      return this.mag * std.cos(this.angle);
    },
    configurable: true,
    enumerable: true
  });
  Object.defineProperty(prototype, 'y', {
    get: function(){
      return this.mag * std.sin(this.angle);
    },
    configurable: true,
    enumerable: true
  });
  return PolarVector;
}());
},{"std":48}],34:[function(require,module,exports){
var Projectile, out$ = typeof exports != 'undefined' && exports || this;
out$.Projectile = Projectile = (function(){
  Projectile.displayName = 'Projectile';
  var prototype = Projectile.prototype, constructor = Projectile;
  function Projectile(damage){
    this.contactDamage = damage;
  }
  prototype.collisionRectangle = function(){};
  prototype.collideWithEnemy = function(){};
  return Projectile;
}());
},{}],35:[function(require,module,exports){
var config, elm, applyStyles, Reader, host, readers, install, addReader, update, removeReader, out$ = typeof exports != 'undefined' && exports || this;
config = require('./config');
elm = bind$(document, 'createElement');
applyStyles = function(el, styles){
  var k, v, results$ = [];
  for (k in styles) {
    v = styles[k];
    results$.push(el.style[k] = v);
  }
  return results$;
};
Reader = (function(){
  Reader.displayName = 'Reader';
  var prototype = Reader.prototype, constructor = Reader;
  function Reader(name, labelText, value){
    var that;
    this.name = name;
    this.labelText = labelText;
    this.value = value;
    this.dom = elm('tr');
    this.label = elm('td');
    this.output = elm('td');
    this.dom.appendChild(this.label);
    this.dom.appendChild(this.output);
    this.label.innerHTML = this.labelText;
    if (that = this.value) {
      this.output.innerHTML = that;
    }
  }
  prototype.update = function(value){
    this.value = value;
    return this.output.innerHTML = this.value;
  };
  prototype.hide = function(){
    return this.dom.styles.display = 'none';
  };
  prototype.show = function(){
    return this.dom.styles.display = 'block';
  };
  prototype.install = function(host){
    return host.appendChild(this.dom);
  };
  prototype['delete'] = function(){
    return this.dom.parentNode.removeChild(this.dom);
  };
  return Reader;
}());
host = elm('table');
readers = {};
applyStyles(host, {
  fontFamily: 'monospace',
  width: '100%',
  paddingLeft: '10px',
  color: 'lightgrey',
  borderWidth: "3px 1px"
});
out$.install = install = function(){
  if (config.showReadout) {
    return document.body.appendChild(host);
  }
};
out$.addReader = addReader = function(name, label, value){
  readers[name] = new Reader(name, label, value);
  return readers[name].install(host);
};
out$.update = update = function(readerName, value){
  var ref$;
  return (ref$ = readers[readerName]) != null ? ref$.update(value) : void 8;
};
out$.removeReader = removeReader = function(name){
  var ref$;
  readers[name]['delete']();
  return ref$ = readers[name], delete readers[name], ref$;
};
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}
},{"./config":12}],36:[function(require,module,exports){
var units, Rectangle, out$ = typeof exports != 'undefined' && exports || this;
units = require('./units');
out$.Rectangle = Rectangle = (function(){
  Rectangle.displayName = 'Rectangle';
  var prototype = Rectangle.prototype, constructor = Rectangle;
  function Rectangle(x, y, w, h, m){
    m == null && (m = 1);
    this.x = x * m;
    this.y = y * m;
    this.w = w * m;
    this.h = h * m;
    this.top = this.y;
    this.left = this.x;
    this.right = this.x + this.w;
    this.bottom = this.y + this.h;
  }
  prototype.collidesWith = function(other){
    return this.right >= other.left && this.left <= other.right && this.top <= other.bottom && this.bottom >= other.top;
  };
  prototype.translate = function(x, y){
    return new Rectangle(this.x + x, this.y + y, this.w, this.h);
  };
  return Rectangle;
}());
},{"./units":50}],37:[function(require,module,exports){
var raf, out$ = typeof exports != 'undefined' && exports || this;
raf = requestAnimationFrame;
import$(out$, {
  delay: function(time, λ){
    return raf(λ);
  }
});
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{}],38:[function(require,module,exports){
var std, queue, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
queue = [];
import$(out$, {
  pushEvent: function(event){
    return queue.push(event);
  },
  pollEvent: function(){
    if (queue.length) {
      return queue.shift();
    }
  }
});
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{"std":48}],39:[function(require,module,exports){
var std, delay, timer, screen, keyboard, eventQueue, Rect, Surface, ref$, INIT_EVERYTHING, FULLSCREEN, init, KEY, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
delay = require('./delay');
timer = require('./timer');
screen = require('./screen');
keyboard = require('./keyboard');
eventQueue = require('./event-queue');
out$.Rect = Rect = require('./rect');
out$.Surface = Surface = require('./surface');
ref$ = std['enum'], INIT_EVERYTHING = ref$[0], FULLSCREEN = ref$[1];
out$.init = init = function(mode){
  std.log("SDL::Init - with mode:", mode);
  timer.init();
  return keyboard.init();
};
out$.INIT_EVERYTHING = INIT_EVERYTHING;
out$.FULLSCREEN = FULLSCREEN;
out$.KEYDOWN = keyboard.KEYDOWN;
out$.KEYUP = keyboard.KEYUP;
out$.KEY = KEY = keyboard.KEYCODES;
out$.delay = delay.delay;
out$.getTicks = timer.getTicks;
out$.pollEvent = eventQueue.pollEvent;
out$.setVideoMode = screen.setVideoMode;
out$.blitSurface = Surface.blitSurface;
out$.setColorKey = Surface.setColorKey;
out$.loadImage = Surface.loadImage;
},{"./delay":37,"./event-queue":38,"./keyboard":40,"./rect":41,"./screen":42,"./surface":43,"./timer":44,"std":48}],40:[function(require,module,exports){
var std, queue, ref$, KEYDOWN, KEYUP, KEYCODES, monitorKeys, init, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
queue = require('./event-queue');
ref$ = std['enum'], KEYDOWN = ref$[0], KEYUP = ref$[1];
out$.KEYCODES = KEYCODES = {
  ESCAPE: 27,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  ONE: 49,
  TWO: 50,
  THREE: 51,
  FOUR: 52,
  FIVE: 53,
  SIX: 54,
  SEVEN: 55,
  EIGHT: 56,
  NINE: 57,
  A: 65,
  Q: 81,
  S: 83,
  W: 87,
  X: 88,
  Z: 90
};
monitorKeys = function(){
  document.addEventListener('keydown', function(event){
    var which;
    which = event.which;
    queue.pushEvent({
      type: KEYDOWN,
      key: which
    });
    if (which === KEYCODES.UP || which === KEYCODES.DOWN || which === KEYCODES.LEFT || which === KEYCODES.RIGHT) {
      return event.preventDefault();
    }
  });
  return document.addEventListener('keyup', function(event){
    var which;
    which = event.which;
    queue.pushEvent({
      type: KEYUP,
      key: which
    });
    return event.preventDefault();
  });
};
out$.init = init = function(){
  std.log("SDL::Keyboard - Monitoring key input");
  return monitorKeys();
};
out$.KEYDOWN = KEYDOWN;
out$.KEYUP = KEYUP;
},{"./event-queue":38,"std":48}],41:[function(require,module,exports){
var Rect;
module.exports = Rect = (function(){
  Rect.displayName = 'Rect';
  var prototype = Rect.prototype, constructor = Rect;
  function Rect(x, y, w, h){
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }
  Rect.clone = function(arg$){
    var x, y, w, h;
    x = arg$.x, y = arg$.y, w = arg$.w, h = arg$.h;
    return new Rect(x, y, w, h);
  };
  return Rect;
}());
},{}],42:[function(require,module,exports){
var std, Surface, applyScaleStyles, createNewScreen, setVideoMode, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
Surface = require('./surface');
applyScaleStyles = function(canvas, scaleFactor){
  if (scaleFactor !== 0) {
    return canvas.style.width = canvas.width * scaleFactor + 'px';
  }
};
createNewScreen = function(w, h, scaleFactor){
  var screen;
  screen = new Surface(null, w, h);
  document.body.appendChild(screen.canvas);
  applyScaleStyles(screen.canvas, scaleFactor);
  return screen;
};
out$.setVideoMode = setVideoMode = function(width, height, scaleFactor){
  scaleFactor == null && (scaleFactor = 1);
  return createNewScreen(width, height, scaleFactor);
};
},{"./surface":43,"std":48}],43:[function(require,module,exports){
var std, Rect, makeTransparent, Surface;
std = require('std');
Rect = require('./rect');
makeTransparent = function(data, color){
  var canvas, context, pixels, i$, to$, i;
  canvas = document.createElement('canvas');
  canvas.width = data.width;
  canvas.height = data.height;
  context = canvas.getContext('2d');
  context.drawImage(data, 0, 0);
  pixels = context.getImageData(0, 0, canvas.width, canvas.height);
  for (i$ = 0, to$ = pixels.data.length; i$ <= to$; i$ += 4) {
    i = i$;
    if (pixels.data[i + 0] === color[0] && pixels.data[i + 1] === color[1] && pixels.data[i + 2] === color[2]) {
      pixels.data[i + 3] = 0;
    }
  }
  context.putImageData(pixels, 0, 0);
  return canvas;
};
module.exports = Surface = (function(){
  Surface.displayName = 'Surface';
  var prototype = Surface.prototype, constructor = Surface;
  function Surface(src, width, height){
    this.width = width;
    this.height = height;
    this.canvas = document.createElement('canvas');
    this.ctx = this.canvas.getContext('2d');
    this.ready = false;
    this.colorKey = null;
    this.resetCanvasSize();
    this.ctx.fillStyle = 'red';
    this.ctx.fillRect(0, 0, this.width, this.height);
    if (typeof src === 'string') {
      this.loadImageData(src);
    } else if (src != null) {
      this.saveImageData(src);
    } else {}
  }
  prototype.resetCanvasSize = function(){
    this.canvas.width = this.width;
    return this.canvas.height = this.height;
  };
  prototype.inheritSizeFromImage = function(data){
    if (this.width == null && this.height == null) {
      this.width = data.naturalWidth;
      this.height = data.naturalHeight;
      return this.resetCanvasSize();
    }
  };
  prototype.loadImageData = function(path){
    var data, this$ = this;
    data = new Image;
    data.onload = function(){
      this$.inheritSizeFromImage(data);
      return this$.saveImageData(data);
    };
    data.onerror = function(){
      std.log("Cant load:", path);
      return this$.ctx.fillRect(0, 0, this$.width, this$.height);
    };
    return data.src = path;
  };
  prototype.saveImageData = function(data){
    this.data = this.colorKey ? makeTransparent(data, this.colorKey) : data;
    this.ready = true;
    this.ctx.clearRect(0, 0, this.width, this.height);
    return this.ctx.drawImage(this.data, 0, 0, this.width, this.height);
  };
  prototype.setColorKey = function(color){
    this.colorKey = color;
    if (this.ready) {
      return this.saveImageData(this.data);
    }
  };
  prototype.drawRect = function(rect, color){
    color == null && (color = 'black');
    this.ctx.fillStyle = color;
    return this.ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
  };
  prototype.drawBox = function(rect, color){
    color == null && (color = 'black');
    this.ctx.strokeStyle = color;
    this.ctx.beginPath();
    this.ctx.moveTo(0.5 + rect.x, 0.5 + rect.y);
    this.ctx.lineTo(0.5 + rect.x, -0.5 + rect.y + rect.h);
    this.ctx.lineTo(-0.5 + rect.x + rect.w, -0.5 + rect.y + rect.h);
    this.ctx.lineTo(-0.5 + rect.x + rect.w, 0.5 + rect.y);
    this.ctx.lineTo(0.5 + rect.x, 0.5 + rect.y);
    this.ctx.stroke();
    return this.ctx.closePath();
  };
  prototype.clear = function(){
    return this.ctx.clearRect(0, 0, this.width, this.height);
  };
  Surface.setColorKey = function(surface, color){
    return surface.setColorKey(color);
  };
  Surface.blitSurface = function(source, srcRect, dest, destRect){
    if (srcRect) {
      return dest.ctx.drawImage(source.canvas, srcRect.x, srcRect.y, srcRect.w, srcRect.h, destRect.x, destRect.y, destRect.w, destRect.h);
    } else {
      return dest.ctx.drawImage(source.canvas, destRect.x, destRect.y, destRect.w, destRect.h);
    }
  };
  Surface.loadImage = function(path){
    return new Surface(path);
  };
  return Surface;
}());
},{"./rect":41,"std":48}],44:[function(require,module,exports){
var startTime, out$ = typeof exports != 'undefined' && exports || this;
startTime = 0;
import$(out$, {
  init: function(){
    return startTime = Date.now();
  },
  getTicks: function(){
    return Date.now() - startTime;
  }
});
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{}],45:[function(require,module,exports){
var SDL, std, units, div, kHalfTile, tpx, gameToPx, Timer, Rect, Sprite, AnimatedSprite, NumberSprite, VaryingWidthSprite, out$ = typeof exports != 'undefined' && exports || this;
SDL = require('SDL');
std = require('std');
units = require('./units');
div = std.div;
kHalfTile = units.kHalfTile, tpx = units.tileToPx, gameToPx = units.gameToPx;
Timer = require('./timer').Timer;
Rect = require('./rectangle').Rectangle;
out$.Sprite = Sprite = (function(){
  Sprite.displayName = 'Sprite';
  var prototype = Sprite.prototype, constructor = Sprite;
  function Sprite(graphics, path, x, y, w, h){
    this.w = w;
    this.h = h;
    this.sourceRect = new Rect(x, y, this.w, this.h);
    this.spriteSheet = graphics.loadImage(path, true);
  }
  prototype.update = function(){};
  prototype.draw = function(graphics, x, y){
    var destRect;
    destRect = new SDL.Rect(gameToPx(x), gameToPx(y), this.w, this.h);
    return graphics.blitSurface(this.spriteSheet, this.sourceRect, destRect);
  };
  return Sprite;
}());
out$.AnimatedSprite = AnimatedSprite = (function(superclass){
  var prototype = extend$((import$(AnimatedSprite, superclass).displayName = 'AnimatedSprite', AnimatedSprite), superclass).prototype, constructor = AnimatedSprite;
  function AnimatedSprite(graphics, path, srcX, srcY, w, h, fps, numFrames){
    var res$, i$, to$, ridx$;
    this.w = w;
    this.h = h;
    this.fps = fps;
    this.numFrames = numFrames;
    AnimatedSprite.superclass.apply(this, arguments);
    this.frameTimer = new Timer(1000 / this.fps);
    res$ = [];
    for (i$ = 0, to$ = this.numFrames; i$ < to$; ++i$) {
      ridx$ = i$;
      res$.push(ridx$);
    }
    this.keyframes = res$;
    this.currentFrame = 0;
    this.currentKeyframe = this.keyframes[0];
    this.originX = srcX;
    this.numCompletedLoops = 0;
  }
  prototype.draw = function(graphics, x, y, frameOffset){
    var destRect;
    frameOffset == null && (frameOffset = this.currentKeyframe);
    this.sourceRect.x = this.originX + frameOffset * this.sourceRect.w;
    destRect = new SDL.Rect(gameToPx(x), gameToPx(y), this.w, this.h);
    return graphics.blitSurface(this.spriteSheet, this.sourceRect, destRect);
  };
  prototype.update = function(){
    if (this.frameTimer.isExpired) {
      this.frameTimer.reset();
      this.currentFrame += 1;
      if (this.currentFrame >= this.keyframes.length) {
        this.numCompletedLoops += 1;
        this.currentFrame = 0;
      }
      return this.currentKeyframe = this.keyframes[this.currentFrame];
    }
  };
  return AnimatedSprite;
}(Sprite));
out$.NumberSprite = NumberSprite = (function(){
  NumberSprite.displayName = 'NumberSprite';
  var kDigitSrcY, kOpPlusSrcX, kOpMinusSrcX, kOpSrcY, kDigitSize, kRadix, ref$, WHITE, RED, PLUS, MINUS, NONE, prototype = NumberSprite.prototype, constructor = NumberSprite;
  kDigitSrcY = 3.5;
  kOpPlusSrcX = 2;
  kOpMinusSrcX = 2.5;
  kOpSrcY = 3;
  kDigitSize = units.kHalfTile;
  kRadix = 10;
  ref$ = std['enum'], WHITE = ref$[0], RED = ref$[1];
  ref$ = std['enum'], PLUS = ref$[0], MINUS = ref$[1], NONE = ref$[2];
  function NumberSprite(graphics, num, len, color, op){
    var srcY;
    this.num = num;
    this.len = len;
    this.color = color;
    this.op = op;
    this.digits = NumberSprite.seperateDigits(this.num);
    this.numDigits = this.digits.length;
    this.padding = this.len === 0
      ? 0
      : kDigitSize * (this.len - this.numDigits);
    srcY = this.color === WHITE
      ? kDigitSrcY
      : kDigitSrcY + 0.5;
    this.glyphs = this.digits.map(function(it){
      return new Sprite(graphics, 'TextBox', tpx(0.5 * it), tpx(srcY), tpx(0.5), tpx(0.5));
    });
    if (this.op === PLUS) {
      this.glyphs.push(new Sprite(graphics, 'TextBox', tpx(kOpPlusSrcX), tpx(kOpSrcY), tpx(0.5), tpx(0.5)));
    }
    if (this.op === MINUS) {
      this.glyphs.push(new Sprite(graphics, 'TextBox', tpx(kOpMinusSrcX), tpx(kOpSrcY), tpx(0.5), tpx(0.5)));
    }
    this.width = kHalfTile * this.glyphs.length;
    this.height = kHalfTile;
  }
  prototype.draw = function(graphics, x, y){
    var i$, ref$, len$, i, glyph, offset, results$ = [];
    for (i$ = 0, len$ = (ref$ = this.glyphs).length; i$ < len$; ++i$) {
      i = i$;
      glyph = ref$[i$];
      offset = kDigitSize * (this.glyphs.length - 1 - i);
      results$.push(glyph.draw(graphics, x + this.padding + offset, y));
    }
    return results$;
  };
  prototype.drawCentered = function(graphics, x, y){
    return this.draw(graphics, x - this.width / 2, y - this.height / 2);
  };
  NumberSprite.seperateDigits = function(num){
    var digit, results$ = [];
    if (num === 0) {
      return [0];
    } else {
      while (num !== 0) {
        digit = num % kRadix;
        num = div(num, kRadix);
        results$.push(digit);
      }
      return results$;
    }
  };
  NumberSprite.HUDNumber = function(graphics, num, len){
    this.num = num;
    this.len = len;
    return new NumberSprite(graphics, this.num, this.len, WHITE, NONE);
  };
  NumberSprite.DamageNumber = function(graphics, num){
    this.num = num;
    return new NumberSprite(graphics, this.num, 0, RED, MINUS);
  };
  NumberSprite.ExperienceNumber = function(graphics, num){
    this.num = num;
    return new NumberSprite(graphics, this.num, 0, WHITE, PLUS);
  };
  return NumberSprite;
}());
out$.VaryingWidthSprite = VaryingWidthSprite = (function(superclass){
  var prototype = extend$((import$(VaryingWidthSprite, superclass).displayName = 'VaryingWidthSprite', VaryingWidthSprite), superclass).prototype, constructor = VaryingWidthSprite;
  function VaryingWidthSprite(graphics, path, x, y, w, h, maxWidth){
    this.w = w;
    this.h = h;
    this.maxWidth = maxWidth != null
      ? maxWidth
      : this.w;
    VaryingWidthSprite.superclass.apply(this, arguments);
  }
  prototype.setWidth = function(width){
    return this.w = width;
  };
  prototype.setPercentageWidth = function(fraction){
    return this.w = fraction * this.maxWidth;
  };
  return VaryingWidthSprite;
}(Sprite));
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{"./rectangle":36,"./timer":49,"./units":50,"SDL":39,"std":48}],46:[function(require,module,exports){
var std, units, NONE, STANDING, WALKING, JUMPING, FALLING, INTERACTING, LEFT, RIGHT, UP, DOWN, HORIZONTAL, STRIDE_LEFT, STRIDE_RIGHT, STRIDE_MIDDLE, State, motions, hfacings, vfacings, strides, SpriteState, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
NONE = Math.pow(2, 0);
STANDING = Math.pow(2, 1);
WALKING = Math.pow(2, 2);
JUMPING = Math.pow(2, 3);
FALLING = Math.pow(2, 4);
INTERACTING = Math.pow(2, 5);
LEFT = Math.pow(2, 6);
RIGHT = Math.pow(2, 7);
UP = Math.pow(2, 8);
DOWN = Math.pow(2, 9);
HORIZONTAL = Math.pow(2, 10);
STRIDE_LEFT = Math.pow(2, 11);
STRIDE_RIGHT = Math.pow(2, 12);
STRIDE_MIDDLE = Math.pow(2, 13);
out$.State = State = {
  NONE: NONE,
  STANDING: STANDING,
  WALKING: WALKING,
  JUMPING: JUMPING,
  FALLING: FALLING,
  INTERACTING: INTERACTING,
  LEFT: LEFT,
  RIGHT: RIGHT,
  UP: UP,
  DOWN: DOWN,
  HORIZONTAL: HORIZONTAL,
  STRIDE_LEFT: STRIDE_LEFT,
  STRIDE_RIGHT: STRIDE_RIGHT,
  STRIDE_MIDDLE: STRIDE_MIDDLE
};
out$.motions = motions = [STANDING, WALKING, JUMPING, FALLING, INTERACTING];
out$.hfacings = hfacings = [LEFT, RIGHT];
out$.vfacings = vfacings = [UP, DOWN, HORIZONTAL];
out$.strides = strides = [STRIDE_LEFT, STRIDE_RIGHT, STRIDE_MIDDLE];
out$.SpriteState = SpriteState = {
  make: function(hfacing, vfacing, motion, stride){
    motion == null && (motion = NONE);
    stride == null && (stride = NONE);
    return {
      key: hfacing | vfacing | motion | stride,
      UP: vfacing === UP,
      DOWN: vfacing === DOWN,
      LEFT: hfacing === LEFT,
      RIGHT: hfacing === RIGHT,
      WALKING: motion === WALKING,
      JUMPING: motion === JUMPING,
      FALLING: motion === FALLING,
      STANDING: motion === STANDING,
      HORIZONTAL: vfacing === HORIZONTAL,
      INTERACTING: motion === INTERACTING,
      STRIDE_LEFT: stride === STRIDE_LEFT,
      STRIDE_RIGHT: stride === STRIDE_RIGHT,
      STRIDE_MIDDLE: stride === STRIDE_MIDDLE
    };
  },
  generateWith: function(fn){
    var m, h, v, s, ss;
    return std.mash((function(){
      var i$, ref$, len$, j$, ref1$, len1$, k$, ref2$, len2$, l$, ref3$, len3$, results$ = [];
      for (i$ = 0, len$ = (ref$ = motions).length; i$ < len$; ++i$) {
        m = ref$[i$];
        for (j$ = 0, len1$ = (ref1$ = hfacings).length; j$ < len1$; ++j$) {
          h = ref1$[j$];
          for (k$ = 0, len2$ = (ref2$ = vfacings).length; k$ < len2$; ++k$) {
            v = ref2$[k$];
            for (l$ = 0, len3$ = (ref3$ = strides).length; l$ < len3$; ++l$) {
              s = ref3$[l$];
              ss = SpriteState.make(h, v, m, s);
              results$.push([ss.key, fn(ss)]);
            }
          }
        }
      }
      return results$;
    }()));
  }
};
},{"./units":50,"std":48}],47:[function(require,module,exports){
var std, tpx, ImmobileSingleLoopParticle, StarParticle, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
tpx = require('./units').tileToPx;
ImmobileSingleLoopParticle = require('./immobile-single-loop-particle').ImmobileSingleLoopParticle;
out$.StarParticle = StarParticle = (function(superclass){
  var prototype = extend$((import$(StarParticle, superclass).displayName = 'StarParticle', StarParticle), superclass).prototype, constructor = StarParticle;
  function StarParticle(graphics, x, y){
    StarParticle.superclass.call(this, graphics, x, y, 'Caret', tpx(0), tpx(3), tpx(1), tpx(1), 18, 4);
  }
  return StarParticle;
}(ImmobileSingleLoopParticle));
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{"./immobile-single-loop-particle":23,"./units":50,"std":48}],48:[function(require,module,exports){
var ref$, id, map, filter, reject, any, div, reverse, log, info, objMap, mash, flip, delay, round, floor, abs, max, min, sin, cos, pi, tau, rand, InterfaceError, out$ = typeof exports != 'undefined' && exports || this;
ref$ = require('prelude-ls'), id = ref$.id, map = ref$.map, filter = ref$.filter, reject = ref$.reject, any = ref$.any, div = ref$.div, reverse = ref$.reverse;
out$.log = log = function(){
  console.log.apply(console, arguments);
  return arguments[0];
};
out$.info = info = function(){
  console.info.apply(console, arguments);
  return arguments[0];
};
out$.objMap = objMap = curry$(function(λ, o){
  var k, v, results$ = [];
  for (k in o) {
    v = o[k];
    results$.push(λ(k, v));
  }
  return results$;
});
out$.mash = mash = function(it){
  var i$, len$, ref$, k, v, results$ = {};
  for (i$ = 0, len$ = it.length; i$ < len$; ++i$) {
    ref$ = it[i$], k = ref$[0], v = ref$[1];
    results$[k] = v;
  }
  return results$;
};
out$.flip = flip = function(λ){
  return curry$(function(a, b){
    return λ(b, a);
  });
};
out$.delay = delay = flip(setTimeout);
out$.round = round = Math.round;
out$.floor = floor = Math.floor;
out$.abs = abs = Math.abs;
out$.max = max = Math.max;
out$.min = min = Math.min;
out$.sin = sin = Math.sin;
out$.cos = cos = Math.cos;
out$.pi = pi = Math.PI;
out$.tau = tau = Math.PI * 2;
out$.rand = rand = function(min, max){
  return min + Math.random() * (max - min);
};
out$.InterfaceError = InterfaceError = (function(superclass){
  var prototype = extend$((import$(InterfaceError, superclass).displayName = 'InterfaceError', InterfaceError), superclass).prototype, constructor = InterfaceError;
  function InterfaceError(message){
    this.message = message;
    this.name = 'InterfaceError';
  }
  return InterfaceError;
}(Error));
ref$ = out$;
ref$.id = id;
ref$.any = any;
ref$.map = map;
ref$.filter = filter;
ref$.reject = reject;
ref$.div = div;
ref$.reverse = reverse;
ref$['enum'] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20];
ref$.bitmask = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096];
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{"prelude-ls":7}],49:[function(require,module,exports){
var std, units, Timer, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
out$.Timer = Timer = (function(){
  Timer.displayName = 'Timer';
  var allTimers, prototype = Timer.prototype, constructor = Timer;
  allTimers = [];
  function Timer(expirationTime, startActive){
    this.expirationTime = expirationTime;
    startActive == null && (startActive = false);
    this.currentTime = startActive
      ? 0
      : this.expirationTime;
    allTimers.push(this);
  }
  prototype.update = function(elapsedTime){
    return this.currentTime += elapsedTime;
  };
  prototype.reset = function(){
    return this.currentTime = 0;
  };
  Object.defineProperty(prototype, 'isActive', {
    get: function(){
      return this.currentTime < this.expirationTime;
    },
    configurable: true,
    enumerable: true
  });
  Object.defineProperty(prototype, 'isExpired', {
    get: function(){
      return !this.isActive;
    },
    configurable: true,
    enumerable: true
  });
  prototype.active = function(){
    return this.currentTime < this.expirationTime;
  };
  prototype.expired = function(){
    return !(this.currentTime < this.expirationTime);
  };
  Timer.updateAll = function(elapsedTime){
    return allTimers.map(function(it){
      return it.update(elapsedTime);
    });
  };
  return Timer;
}());
},{"./units":50,"std":48}],50:[function(require,module,exports){
var std, config, kPi, kGameUnitsPerTile, kPixelScaleFactor, Game, Pixel, Tile, Degrees, GunLevel, GunXP, FPS, MS, Velocity, Acceleration, HP, gameToPx, gameToTile, tileToGame, tileToPx, pxToGame, pxToTile, degToRad, kOneTile, kHalfTile, kTilePx, kMaxGunLevel, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
config = require('./config');
kPi = Math.PI;
kGameUnitsPerTile = 32;
kPixelScaleFactor = kGameUnitsPerTile / config.kGraphicsQuality;
out$.Game = Game = std.id;
out$.Pixel = Pixel = std.floor;
out$.Tile = Tile = function(){
  return std.abs(std.floor.apply(this, arguments));
};
out$.Degrees = Degrees = std.id;
out$.GunLevel = GunLevel = std.floor;
out$.GunXP = GunXP = std.floor;
out$.FPS = FPS = std.id;
out$.MS = MS = std.id;
out$.Velocity = Velocity = std.id;
out$.Acceleration = Acceleration = std.id;
out$.HP = HP = std.floor;
out$.gameToPx = gameToPx = function(){
  return Pixel((function(it){
    return it / kPixelScaleFactor;
  }).apply(this, arguments));
};
out$.gameToTile = gameToTile = function(){
  return Tile((function(it){
    return it / kGameUnitsPerTile;
  }).apply(this, arguments));
};
out$.tileToGame = tileToGame = (function(it){
  return it * kGameUnitsPerTile;
});
out$.tileToPx = tileToPx = function(){
  return gameToPx(tileToGame.apply(this, arguments));
};
out$.pxToGame = pxToGame = (function(it){
  return it * kPixelScaleFactor;
});
out$.pxToTile = pxToTile = function(){
  return (function(it){
    return it / kGameUnitsPerTile;
  })(pxToGame.apply(this, arguments));
};
out$.degToRad = degToRad = (function(it){
  return it * kPi / 180;
});
out$.kOneTile = kOneTile = tileToGame(1);
out$.kHalfTile = kHalfTile = tileToGame(0.5);
out$.kTilePx = kTilePx = tileToPx(1);
out$.kMaxGunLevel = kMaxGunLevel = 3;
},{"./config":12,"std":48}],51:[function(require,module,exports){
var std, units, tpx, ImmobileSingleLoopParticle, WallParticle, out$ = typeof exports != 'undefined' && exports || this;
std = require('std');
units = require('./units');
tpx = require('./units').tileToPx;
ImmobileSingleLoopParticle = require('./immobile-single-loop-particle').ImmobileSingleLoopParticle;
out$.WallParticle = WallParticle = (function(superclass){
  var prototype = extend$((import$(WallParticle, superclass).displayName = 'WallParticle', WallParticle), superclass).prototype, constructor = WallParticle;
  function WallParticle(graphics, x, y){
    WallParticle.superclass.call(this, graphics, x, y, 'Caret', tpx(11), tpx(0), tpx(1), tpx(1), 18, 4);
  }
  return WallParticle;
}(ImmobileSingleLoopParticle));
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{"./immobile-single-loop-particle":23,"./units":50,"std":48}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi4vc3JjL2luZGV4LmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9ub2RlX21vZHVsZXMvcHJlbHVkZS1scy9saWIvRnVuYy5qcyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvbm9kZV9tb2R1bGVzL3ByZWx1ZGUtbHMvbGliL0xpc3QuanMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L25vZGVfbW9kdWxlcy9wcmVsdWRlLWxzL2xpYi9OdW0uanMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L25vZGVfbW9kdWxlcy9wcmVsdWRlLWxzL2xpYi9PYmouanMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L25vZGVfbW9kdWxlcy9wcmVsdWRlLWxzL2xpYi9TdHIuanMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L25vZGVfbW9kdWxlcy9wcmVsdWRlLWxzL2xpYi9pbmRleC5qcyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL2FjY2VsZXJhdG9ycy5scyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL2FybXMubHMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L3NyYy9iYWNrZHJvcC5scyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL2NvbGxpc2lvbi1yZWN0YW5nbGUubHMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L3NyYy9jb25maWcubHMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L3NyYy9kYW1hZ2UtdGV4dC5scyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL2RhbWFnZS10ZXh0cy5scyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL2RhbWFnZWFibGUubHMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L3NyYy9kZWF0aC1jbG91ZC1wYXJ0aWNsZS5scyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL2ZpcnN0LWNhdmUtYmF0LmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9zcmMvZ2FtZS5scyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL2dyYXBoaWNzLmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9zcmMvZ3VuLXhwLWh1ZC5scyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL2hlYWQtYnVtcC1wYXJ0aWNsZS5scyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL2hlYWx0aC5scyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL2ltbW9iaWxlLXNpbmdsZS1sb29wLXBhcnRpY2xlLmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9zcmMvaW5wdXQubHMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L3NyYy9raW5lbWF0aWNzLmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9zcmMvbWFwLWNvbGxpZGFibGUubHMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L3NyYy9tYXAubHMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L3NyYy9wYXJ0aWNsZS1zeXN0ZW0ubHMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L3NyYy9wYXJ0aWNsZS5scyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL3BpY2t1cC5scyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL3BpY2t1cHMubHMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L3NyYy9wbGF5ZXIubHMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L3NyYy9wb2xhci5scyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL3Byb2plY3RpbGUubHMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L3NyYy9yZWFkb3V0LmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9zcmMvcmVjdGFuZ2xlLmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9zcmMvc2RsL2RlbGF5LmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9zcmMvc2RsL2V2ZW50LXF1ZXVlLmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9zcmMvc2RsL2luZGV4LmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9zcmMvc2RsL2tleWJvYXJkLmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9zcmMvc2RsL3JlY3QubHMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L3NyYy9zZGwvc2NyZWVuLmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9zcmMvc2RsL3N1cmZhY2UubHMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L3NyYy9zZGwvdGltZXIubHMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L3NyYy9zcHJpdGUubHMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L3NyYy9zcHJpdGVzdGF0ZS5scyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL3N0YXItcGFydGljbGUubHMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L3NyYy9zdGQvaW5kZXgubHMiLCIvVXNlcnMvbGFrbWVlci9Qcm9qZWN0cy9jYXZlLXN0b3J5L3NyYy90aW1lci5scyIsIi9Vc2Vycy9sYWttZWVyL1Byb2plY3RzL2NhdmUtc3Rvcnkvc3JjL3VuaXRzLmxzIiwiL1VzZXJzL2xha21lZXIvUHJvamVjdHMvY2F2ZS1zdG9yeS9zcmMvd2FsbC1wYXJ0aWNsZS5scyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsInZhciByZWFkb3V0LCBHYW1lO1xucmVhZG91dCA9IHJlcXVpcmUoJy4vcmVhZG91dCcpO1xuR2FtZSA9IHJlcXVpcmUoJy4vZ2FtZScpO1xucmVhZG91dC5pbnN0YWxsKCk7XG5HYW1lLnN0YXJ0KCk7IiwiLy8gR2VuZXJhdGVkIGJ5IExpdmVTY3JpcHQgMS4yLjBcbnZhciBhcHBseSwgY3VycnksIGZsaXAsIGZpeCwgb3ZlcjtcbmFwcGx5ID0gY3VycnkkKGZ1bmN0aW9uKGYsIGxpc3Qpe1xuICByZXR1cm4gZi5hcHBseShudWxsLCBsaXN0KTtcbn0pO1xuY3VycnkgPSBmdW5jdGlvbihmKXtcbiAgcmV0dXJuIGN1cnJ5JChmKTtcbn07XG5mbGlwID0gY3VycnkkKGZ1bmN0aW9uKGYsIHgsIHkpe1xuICByZXR1cm4gZih5LCB4KTtcbn0pO1xuZml4ID0gZnVuY3Rpb24oZil7XG4gIHJldHVybiBmdW5jdGlvbihnKXtcbiAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBmKGcoZykpLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfShmdW5jdGlvbihnKXtcbiAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBmKGcoZykpLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSk7XG59O1xub3ZlciA9IGN1cnJ5JChmdW5jdGlvbihmLCBnLCB4LCB5KXtcbiAgcmV0dXJuIGYoZyh4KSwgZyh5KSk7XG59KTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBjdXJyeTogY3VycnksXG4gIGZsaXA6IGZsaXAsXG4gIGZpeDogZml4LFxuICBhcHBseTogYXBwbHksXG4gIG92ZXI6IG92ZXJcbn07XG5mdW5jdGlvbiBjdXJyeSQoZiwgYm91bmQpe1xuICB2YXIgY29udGV4dCxcbiAgX2N1cnJ5ID0gZnVuY3Rpb24oYXJncykge1xuICAgIHJldHVybiBmLmxlbmd0aCA+IDEgPyBmdW5jdGlvbigpe1xuICAgICAgdmFyIHBhcmFtcyA9IGFyZ3MgPyBhcmdzLmNvbmNhdCgpIDogW107XG4gICAgICBjb250ZXh0ID0gYm91bmQgPyBjb250ZXh0IHx8IHRoaXMgOiB0aGlzO1xuICAgICAgcmV0dXJuIHBhcmFtcy5wdXNoLmFwcGx5KHBhcmFtcywgYXJndW1lbnRzKSA8XG4gICAgICAgICAgZi5sZW5ndGggJiYgYXJndW1lbnRzLmxlbmd0aCA/XG4gICAgICAgIF9jdXJyeS5jYWxsKGNvbnRleHQsIHBhcmFtcykgOiBmLmFwcGx5KGNvbnRleHQsIHBhcmFtcyk7XG4gICAgfSA6IGY7XG4gIH07XG4gIHJldHVybiBfY3VycnkoKTtcbn0iLCIvLyBHZW5lcmF0ZWQgYnkgTGl2ZVNjcmlwdCAxLjIuMFxudmFyIGVhY2gsIG1hcCwgY29tcGFjdCwgZmlsdGVyLCByZWplY3QsIHBhcnRpdGlvbiwgZmluZCwgaGVhZCwgZmlyc3QsIHRhaWwsIGxhc3QsIGluaXRpYWwsIGVtcHR5LCByZXZlcnNlLCB1bmlxdWUsIHVuaXF1ZUJ5LCBmb2xkLCBmb2xkbCwgZm9sZDEsIGZvbGRsMSwgZm9sZHIsIGZvbGRyMSwgdW5mb2xkciwgY29uY2F0LCBjb25jYXRNYXAsIGZsYXR0ZW4sIGRpZmZlcmVuY2UsIGludGVyc2VjdGlvbiwgdW5pb24sIGNvdW50QnksIGdyb3VwQnksIGFuZExpc3QsIG9yTGlzdCwgYW55LCBhbGwsIHNvcnQsIHNvcnRXaXRoLCBzb3J0QnksIHN1bSwgcHJvZHVjdCwgbWVhbiwgYXZlcmFnZSwgbWF4aW11bSwgbWluaW11bSwgbWF4aW11bUJ5LCBtaW5pbXVtQnksIHNjYW4sIHNjYW5sLCBzY2FuMSwgc2NhbmwxLCBzY2Fuciwgc2NhbnIxLCBzbGljZSwgdGFrZSwgZHJvcCwgc3BsaXRBdCwgdGFrZVdoaWxlLCBkcm9wV2hpbGUsIHNwYW4sIGJyZWFrTGlzdCwgemlwLCB6aXBXaXRoLCB6aXBBbGwsIHppcEFsbFdpdGgsIGF0LCBlbGVtSW5kZXgsIGVsZW1JbmRpY2VzLCBmaW5kSW5kZXgsIGZpbmRJbmRpY2VzLCB0b1N0cmluZyQgPSB7fS50b1N0cmluZywgc2xpY2UkID0gW10uc2xpY2U7XG5lYWNoID0gY3VycnkkKGZ1bmN0aW9uKGYsIHhzKXtcbiAgdmFyIGkkLCBsZW4kLCB4O1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IHhzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeCA9IHhzW2kkXTtcbiAgICBmKHgpO1xuICB9XG4gIHJldHVybiB4cztcbn0pO1xubWFwID0gY3VycnkkKGZ1bmN0aW9uKGYsIHhzKXtcbiAgdmFyIGkkLCBsZW4kLCB4LCByZXN1bHRzJCA9IFtdO1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IHhzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeCA9IHhzW2kkXTtcbiAgICByZXN1bHRzJC5wdXNoKGYoeCkpO1xuICB9XG4gIHJldHVybiByZXN1bHRzJDtcbn0pO1xuY29tcGFjdCA9IGZ1bmN0aW9uKHhzKXtcbiAgdmFyIGkkLCBsZW4kLCB4LCByZXN1bHRzJCA9IFtdO1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IHhzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeCA9IHhzW2kkXTtcbiAgICBpZiAoeCkge1xuICAgICAgcmVzdWx0cyQucHVzaCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHMkO1xufTtcbmZpbHRlciA9IGN1cnJ5JChmdW5jdGlvbihmLCB4cyl7XG4gIHZhciBpJCwgbGVuJCwgeCwgcmVzdWx0cyQgPSBbXTtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSB4cy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHggPSB4c1tpJF07XG4gICAgaWYgKGYoeCkpIHtcbiAgICAgIHJlc3VsdHMkLnB1c2goeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRzJDtcbn0pO1xucmVqZWN0ID0gY3VycnkkKGZ1bmN0aW9uKGYsIHhzKXtcbiAgdmFyIGkkLCBsZW4kLCB4LCByZXN1bHRzJCA9IFtdO1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IHhzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeCA9IHhzW2kkXTtcbiAgICBpZiAoIWYoeCkpIHtcbiAgICAgIHJlc3VsdHMkLnB1c2goeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRzJDtcbn0pO1xucGFydGl0aW9uID0gY3VycnkkKGZ1bmN0aW9uKGYsIHhzKXtcbiAgdmFyIHBhc3NlZCwgZmFpbGVkLCBpJCwgbGVuJCwgeDtcbiAgcGFzc2VkID0gW107XG4gIGZhaWxlZCA9IFtdO1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IHhzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeCA9IHhzW2kkXTtcbiAgICAoZih4KSA/IHBhc3NlZCA6IGZhaWxlZCkucHVzaCh4KTtcbiAgfVxuICByZXR1cm4gW3Bhc3NlZCwgZmFpbGVkXTtcbn0pO1xuZmluZCA9IGN1cnJ5JChmdW5jdGlvbihmLCB4cyl7XG4gIHZhciBpJCwgbGVuJCwgeDtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSB4cy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHggPSB4c1tpJF07XG4gICAgaWYgKGYoeCkpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfVxufSk7XG5oZWFkID0gZmlyc3QgPSBmdW5jdGlvbih4cyl7XG4gIHJldHVybiB4c1swXTtcbn07XG50YWlsID0gZnVuY3Rpb24oeHMpe1xuICBpZiAoIXhzLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4geHMuc2xpY2UoMSk7XG59O1xubGFzdCA9IGZ1bmN0aW9uKHhzKXtcbiAgcmV0dXJuIHhzW3hzLmxlbmd0aCAtIDFdO1xufTtcbmluaXRpYWwgPSBmdW5jdGlvbih4cyl7XG4gIGlmICgheHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiB4cy5zbGljZSgwLCAtMSk7XG59O1xuZW1wdHkgPSBmdW5jdGlvbih4cyl7XG4gIHJldHVybiAheHMubGVuZ3RoO1xufTtcbnJldmVyc2UgPSBmdW5jdGlvbih4cyl7XG4gIHJldHVybiB4cy5jb25jYXQoKS5yZXZlcnNlKCk7XG59O1xudW5pcXVlID0gZnVuY3Rpb24oeHMpe1xuICB2YXIgcmVzdWx0LCBpJCwgbGVuJCwgeDtcbiAgcmVzdWx0ID0gW107XG4gIGZvciAoaSQgPSAwLCBsZW4kID0geHMubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4ID0geHNbaSRdO1xuICAgIGlmICghaW4kKHgsIHJlc3VsdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbnVuaXF1ZUJ5ID0gY3VycnkkKGZ1bmN0aW9uKGYsIHhzKXtcbiAgdmFyIHNlZW4sIGkkLCBsZW4kLCB4LCB2YWwsIHJlc3VsdHMkID0gW107XG4gIHNlZW4gPSBbXTtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSB4cy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHggPSB4c1tpJF07XG4gICAgdmFsID0gZih4KTtcbiAgICBpZiAoaW4kKHZhbCwgc2VlbikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBzZWVuLnB1c2godmFsKTtcbiAgICByZXN1bHRzJC5wdXNoKHgpO1xuICB9XG4gIHJldHVybiByZXN1bHRzJDtcbn0pO1xuZm9sZCA9IGZvbGRsID0gY3VycnkkKGZ1bmN0aW9uKGYsIG1lbW8sIHhzKXtcbiAgdmFyIGkkLCBsZW4kLCB4O1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IHhzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeCA9IHhzW2kkXTtcbiAgICBtZW1vID0gZihtZW1vLCB4KTtcbiAgfVxuICByZXR1cm4gbWVtbztcbn0pO1xuZm9sZDEgPSBmb2xkbDEgPSBjdXJyeSQoZnVuY3Rpb24oZiwgeHMpe1xuICByZXR1cm4gZm9sZChmLCB4c1swXSwgeHMuc2xpY2UoMSkpO1xufSk7XG5mb2xkciA9IGN1cnJ5JChmdW5jdGlvbihmLCBtZW1vLCB4cyl7XG4gIHZhciBpJCwgeDtcbiAgZm9yIChpJCA9IHhzLmxlbmd0aCAtIDE7IGkkID49IDA7IC0taSQpIHtcbiAgICB4ID0geHNbaSRdO1xuICAgIG1lbW8gPSBmKHgsIG1lbW8pO1xuICB9XG4gIHJldHVybiBtZW1vO1xufSk7XG5mb2xkcjEgPSBjdXJyeSQoZnVuY3Rpb24oZiwgeHMpe1xuICByZXR1cm4gZm9sZHIoZiwgeHNbeHMubGVuZ3RoIC0gMV0sIHhzLnNsaWNlKDAsIC0xKSk7XG59KTtcbnVuZm9sZHIgPSBjdXJyeSQoZnVuY3Rpb24oZiwgYil7XG4gIHZhciByZXN1bHQsIHgsIHRoYXQ7XG4gIHJlc3VsdCA9IFtdO1xuICB4ID0gYjtcbiAgd2hpbGUgKCh0aGF0ID0gZih4KSkgIT0gbnVsbCkge1xuICAgIHJlc3VsdC5wdXNoKHRoYXRbMF0pO1xuICAgIHggPSB0aGF0WzFdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcbmNvbmNhdCA9IGZ1bmN0aW9uKHhzcyl7XG4gIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIHhzcyk7XG59O1xuY29uY2F0TWFwID0gY3VycnkkKGZ1bmN0aW9uKGYsIHhzKXtcbiAgdmFyIHg7XG4gIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIChmdW5jdGlvbigpe1xuICAgIHZhciBpJCwgcmVmJCwgbGVuJCwgcmVzdWx0cyQgPSBbXTtcbiAgICBmb3IgKGkkID0gMCwgbGVuJCA9IChyZWYkID0geHMpLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgICB4ID0gcmVmJFtpJF07XG4gICAgICByZXN1bHRzJC5wdXNoKGYoeCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cyQ7XG4gIH0oKSkpO1xufSk7XG5mbGF0dGVuID0gZnVuY3Rpb24oeHMpe1xuICB2YXIgeDtcbiAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgKGZ1bmN0aW9uKCl7XG4gICAgdmFyIGkkLCByZWYkLCBsZW4kLCByZXN1bHRzJCA9IFtdO1xuICAgIGZvciAoaSQgPSAwLCBsZW4kID0gKHJlZiQgPSB4cykubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICAgIHggPSByZWYkW2kkXTtcbiAgICAgIGlmICh0b1N0cmluZyQuY2FsbCh4KS5zbGljZSg4LCAtMSkgPT09ICdBcnJheScpIHtcbiAgICAgICAgcmVzdWx0cyQucHVzaChmbGF0dGVuKHgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdHMkLnB1c2goeCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzJDtcbiAgfSgpKSk7XG59O1xuZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKHhzKXtcbiAgdmFyIHlzcywgcmVzdWx0cywgaSQsIGxlbiQsIHgsIGokLCBsZW4xJCwgeXM7XG4gIHlzcyA9IHNsaWNlJC5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHJlc3VsdHMgPSBbXTtcbiAgb3V0ZXI6IGZvciAoaSQgPSAwLCBsZW4kID0geHMubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4ID0geHNbaSRdO1xuICAgIGZvciAoaiQgPSAwLCBsZW4xJCA9IHlzcy5sZW5ndGg7IGokIDwgbGVuMSQ7ICsraiQpIHtcbiAgICAgIHlzID0geXNzW2okXTtcbiAgICAgIGlmIChpbiQoeCwgeXMpKSB7XG4gICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHRzLnB1c2goeCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oeHMpe1xuICB2YXIgeXNzLCByZXN1bHRzLCBpJCwgbGVuJCwgeCwgaiQsIGxlbjEkLCB5cztcbiAgeXNzID0gc2xpY2UkLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgcmVzdWx0cyA9IFtdO1xuICBvdXRlcjogZm9yIChpJCA9IDAsIGxlbiQgPSB4cy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHggPSB4c1tpJF07XG4gICAgZm9yIChqJCA9IDAsIGxlbjEkID0geXNzLmxlbmd0aDsgaiQgPCBsZW4xJDsgKytqJCkge1xuICAgICAgeXMgPSB5c3NbaiRdO1xuICAgICAgaWYgKCFpbiQoeCwgeXMpKSB7XG4gICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHRzLnB1c2goeCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xudW5pb24gPSBmdW5jdGlvbigpe1xuICB2YXIgeHNzLCByZXN1bHRzLCBpJCwgbGVuJCwgeHMsIGokLCBsZW4xJCwgeDtcbiAgeHNzID0gc2xpY2UkLmNhbGwoYXJndW1lbnRzKTtcbiAgcmVzdWx0cyA9IFtdO1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IHhzcy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHhzID0geHNzW2kkXTtcbiAgICBmb3IgKGokID0gMCwgbGVuMSQgPSB4cy5sZW5ndGg7IGokIDwgbGVuMSQ7ICsraiQpIHtcbiAgICAgIHggPSB4c1tqJF07XG4gICAgICBpZiAoIWluJCh4LCByZXN1bHRzKSkge1xuICAgICAgICByZXN1bHRzLnB1c2goeCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRzO1xufTtcbmNvdW50QnkgPSBjdXJyeSQoZnVuY3Rpb24oZiwgeHMpe1xuICB2YXIgcmVzdWx0cywgaSQsIGxlbiQsIHgsIGtleTtcbiAgcmVzdWx0cyA9IHt9O1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IHhzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeCA9IHhzW2kkXTtcbiAgICBrZXkgPSBmKHgpO1xuICAgIGlmIChrZXkgaW4gcmVzdWx0cykge1xuICAgICAgcmVzdWx0c1trZXldICs9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdHNba2V5XSA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRzO1xufSk7XG5ncm91cEJ5ID0gY3VycnkkKGZ1bmN0aW9uKGYsIHhzKXtcbiAgdmFyIHJlc3VsdHMsIGkkLCBsZW4kLCB4LCBrZXk7XG4gIHJlc3VsdHMgPSB7fTtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSB4cy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHggPSB4c1tpJF07XG4gICAga2V5ID0gZih4KTtcbiAgICBpZiAoa2V5IGluIHJlc3VsdHMpIHtcbiAgICAgIHJlc3VsdHNba2V5XS5wdXNoKHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRzW2tleV0gPSBbeF07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRzO1xufSk7XG5hbmRMaXN0ID0gZnVuY3Rpb24oeHMpe1xuICB2YXIgaSQsIGxlbiQsIHg7XG4gIGZvciAoaSQgPSAwLCBsZW4kID0geHMubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4ID0geHNbaSRdO1xuICAgIGlmICgheCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5vckxpc3QgPSBmdW5jdGlvbih4cyl7XG4gIHZhciBpJCwgbGVuJCwgeDtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSB4cy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHggPSB4c1tpJF07XG4gICAgaWYgKHgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuYW55ID0gY3VycnkkKGZ1bmN0aW9uKGYsIHhzKXtcbiAgdmFyIGkkLCBsZW4kLCB4O1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IHhzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeCA9IHhzW2kkXTtcbiAgICBpZiAoZih4KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn0pO1xuYWxsID0gY3VycnkkKGZ1bmN0aW9uKGYsIHhzKXtcbiAgdmFyIGkkLCBsZW4kLCB4O1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IHhzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeCA9IHhzW2kkXTtcbiAgICBpZiAoIWYoeCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59KTtcbnNvcnQgPSBmdW5jdGlvbih4cyl7XG4gIHJldHVybiB4cy5jb25jYXQoKS5zb3J0KGZ1bmN0aW9uKHgsIHkpe1xuICAgIGlmICh4ID4geSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmICh4IDwgeSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0pO1xufTtcbnNvcnRXaXRoID0gY3VycnkkKGZ1bmN0aW9uKGYsIHhzKXtcbiAgcmV0dXJuIHhzLmNvbmNhdCgpLnNvcnQoZik7XG59KTtcbnNvcnRCeSA9IGN1cnJ5JChmdW5jdGlvbihmLCB4cyl7XG4gIHJldHVybiB4cy5jb25jYXQoKS5zb3J0KGZ1bmN0aW9uKHgsIHkpe1xuICAgIGlmIChmKHgpID4gZih5KSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChmKHgpIDwgZih5KSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0pO1xufSk7XG5zdW0gPSBmdW5jdGlvbih4cyl7XG4gIHZhciByZXN1bHQsIGkkLCBsZW4kLCB4O1xuICByZXN1bHQgPSAwO1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IHhzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeCA9IHhzW2kkXTtcbiAgICByZXN1bHQgKz0geDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbnByb2R1Y3QgPSBmdW5jdGlvbih4cyl7XG4gIHZhciByZXN1bHQsIGkkLCBsZW4kLCB4O1xuICByZXN1bHQgPSAxO1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IHhzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeCA9IHhzW2kkXTtcbiAgICByZXN1bHQgKj0geDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbm1lYW4gPSBhdmVyYWdlID0gZnVuY3Rpb24oeHMpe1xuICB2YXIgc3VtLCBpJCwgbGVuJCwgeDtcbiAgc3VtID0gMDtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSB4cy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHggPSB4c1tpJF07XG4gICAgc3VtICs9IHg7XG4gIH1cbiAgcmV0dXJuIHN1bSAvIHhzLmxlbmd0aDtcbn07XG5tYXhpbXVtID0gZnVuY3Rpb24oeHMpe1xuICB2YXIgbWF4LCBpJCwgcmVmJCwgbGVuJCwgeDtcbiAgbWF4ID0geHNbMF07XG4gIGZvciAoaSQgPSAwLCBsZW4kID0gKHJlZiQgPSB4cy5zbGljZSgxKSkubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4ID0gcmVmJFtpJF07XG4gICAgaWYgKHggPiBtYXgpIHtcbiAgICAgIG1heCA9IHg7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXg7XG59O1xubWluaW11bSA9IGZ1bmN0aW9uKHhzKXtcbiAgdmFyIG1pbiwgaSQsIHJlZiQsIGxlbiQsIHg7XG4gIG1pbiA9IHhzWzBdO1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IChyZWYkID0geHMuc2xpY2UoMSkpLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeCA9IHJlZiRbaSRdO1xuICAgIGlmICh4IDwgbWluKSB7XG4gICAgICBtaW4gPSB4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWluO1xufTtcbm1heGltdW1CeSA9IGN1cnJ5JChmdW5jdGlvbihmLCB4cyl7XG4gIHZhciBtYXgsIGkkLCByZWYkLCBsZW4kLCB4O1xuICBtYXggPSB4c1swXTtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSAocmVmJCA9IHhzLnNsaWNlKDEpKS5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHggPSByZWYkW2kkXTtcbiAgICBpZiAoZih4KSA+IGYobWF4KSkge1xuICAgICAgbWF4ID0geDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1heDtcbn0pO1xubWluaW11bUJ5ID0gY3VycnkkKGZ1bmN0aW9uKGYsIHhzKXtcbiAgdmFyIG1pbiwgaSQsIHJlZiQsIGxlbiQsIHg7XG4gIG1pbiA9IHhzWzBdO1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IChyZWYkID0geHMuc2xpY2UoMSkpLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeCA9IHJlZiRbaSRdO1xuICAgIGlmIChmKHgpIDwgZihtaW4pKSB7XG4gICAgICBtaW4gPSB4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWluO1xufSk7XG5zY2FuID0gc2NhbmwgPSBjdXJyeSQoZnVuY3Rpb24oZiwgbWVtbywgeHMpe1xuICB2YXIgbGFzdCwgeDtcbiAgbGFzdCA9IG1lbW87XG4gIHJldHVybiBbbWVtb10uY29uY2F0KChmdW5jdGlvbigpe1xuICAgIHZhciBpJCwgcmVmJCwgbGVuJCwgcmVzdWx0cyQgPSBbXTtcbiAgICBmb3IgKGkkID0gMCwgbGVuJCA9IChyZWYkID0geHMpLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgICB4ID0gcmVmJFtpJF07XG4gICAgICByZXN1bHRzJC5wdXNoKGxhc3QgPSBmKGxhc3QsIHgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHMkO1xuICB9KCkpKTtcbn0pO1xuc2NhbjEgPSBzY2FubDEgPSBjdXJyeSQoZnVuY3Rpb24oZiwgeHMpe1xuICBpZiAoIXhzLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gc2NhbihmLCB4c1swXSwgeHMuc2xpY2UoMSkpO1xufSk7XG5zY2FuciA9IGN1cnJ5JChmdW5jdGlvbihmLCBtZW1vLCB4cyl7XG4gIHhzID0geHMuY29uY2F0KCkucmV2ZXJzZSgpO1xuICByZXR1cm4gc2NhbihmLCBtZW1vLCB4cykucmV2ZXJzZSgpO1xufSk7XG5zY2FucjEgPSBjdXJyeSQoZnVuY3Rpb24oZiwgeHMpe1xuICBpZiAoIXhzLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICB4cyA9IHhzLmNvbmNhdCgpLnJldmVyc2UoKTtcbiAgcmV0dXJuIHNjYW4oZiwgeHNbMF0sIHhzLnNsaWNlKDEpKS5yZXZlcnNlKCk7XG59KTtcbnNsaWNlID0gY3VycnkkKGZ1bmN0aW9uKHgsIHksIHhzKXtcbiAgcmV0dXJuIHhzLnNsaWNlKHgsIHkpO1xufSk7XG50YWtlID0gY3VycnkkKGZ1bmN0aW9uKG4sIHhzKXtcbiAgaWYgKG4gPD0gMCkge1xuICAgIHJldHVybiB4cy5zbGljZSgwLCAwKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geHMuc2xpY2UoMCwgbik7XG4gIH1cbn0pO1xuZHJvcCA9IGN1cnJ5JChmdW5jdGlvbihuLCB4cyl7XG4gIGlmIChuIDw9IDApIHtcbiAgICByZXR1cm4geHM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHhzLnNsaWNlKG4pO1xuICB9XG59KTtcbnNwbGl0QXQgPSBjdXJyeSQoZnVuY3Rpb24obiwgeHMpe1xuICByZXR1cm4gW3Rha2UobiwgeHMpLCBkcm9wKG4sIHhzKV07XG59KTtcbnRha2VXaGlsZSA9IGN1cnJ5JChmdW5jdGlvbihwLCB4cyl7XG4gIHZhciBsZW4sIGk7XG4gIGxlbiA9IHhzLmxlbmd0aDtcbiAgaWYgKCFsZW4pIHtcbiAgICByZXR1cm4geHM7XG4gIH1cbiAgaSA9IDA7XG4gIHdoaWxlIChpIDwgbGVuICYmIHAoeHNbaV0pKSB7XG4gICAgaSArPSAxO1xuICB9XG4gIHJldHVybiB4cy5zbGljZSgwLCBpKTtcbn0pO1xuZHJvcFdoaWxlID0gY3VycnkkKGZ1bmN0aW9uKHAsIHhzKXtcbiAgdmFyIGxlbiwgaTtcbiAgbGVuID0geHMubGVuZ3RoO1xuICBpZiAoIWxlbikge1xuICAgIHJldHVybiB4cztcbiAgfVxuICBpID0gMDtcbiAgd2hpbGUgKGkgPCBsZW4gJiYgcCh4c1tpXSkpIHtcbiAgICBpICs9IDE7XG4gIH1cbiAgcmV0dXJuIHhzLnNsaWNlKGkpO1xufSk7XG5zcGFuID0gY3VycnkkKGZ1bmN0aW9uKHAsIHhzKXtcbiAgcmV0dXJuIFt0YWtlV2hpbGUocCwgeHMpLCBkcm9wV2hpbGUocCwgeHMpXTtcbn0pO1xuYnJlYWtMaXN0ID0gY3VycnkkKGZ1bmN0aW9uKHAsIHhzKXtcbiAgcmV0dXJuIHNwYW4oZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbm90JChwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9LCB4cyk7XG59KTtcbnppcCA9IGN1cnJ5JChmdW5jdGlvbih4cywgeXMpe1xuICB2YXIgcmVzdWx0LCBsZW4sIGkkLCBsZW4kLCBpLCB4O1xuICByZXN1bHQgPSBbXTtcbiAgbGVuID0geXMubGVuZ3RoO1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IHhzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgaSA9IGkkO1xuICAgIHggPSB4c1tpJF07XG4gICAgaWYgKGkgPT09IGxlbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKFt4LCB5c1tpXV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcbnppcFdpdGggPSBjdXJyeSQoZnVuY3Rpb24oZiwgeHMsIHlzKXtcbiAgdmFyIHJlc3VsdCwgbGVuLCBpJCwgbGVuJCwgaSwgeDtcbiAgcmVzdWx0ID0gW107XG4gIGxlbiA9IHlzLmxlbmd0aDtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSB4cy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIGkgPSBpJDtcbiAgICB4ID0geHNbaSRdO1xuICAgIGlmIChpID09PSBsZW4pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXN1bHQucHVzaChmKHgsIHlzW2ldKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuemlwQWxsID0gZnVuY3Rpb24oKXtcbiAgdmFyIHhzcywgbWluTGVuZ3RoLCBpJCwgbGVuJCwgeHMsIHJlZiQsIGksIGxyZXN1bHQkLCBqJCwgcmVzdWx0cyQgPSBbXTtcbiAgeHNzID0gc2xpY2UkLmNhbGwoYXJndW1lbnRzKTtcbiAgbWluTGVuZ3RoID0gOWU5O1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IHhzcy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIHhzID0geHNzW2kkXTtcbiAgICBtaW5MZW5ndGggPD0gKHJlZiQgPSB4cy5sZW5ndGgpIHx8IChtaW5MZW5ndGggPSByZWYkKTtcbiAgfVxuICBmb3IgKGkkID0gMDsgaSQgPCBtaW5MZW5ndGg7ICsraSQpIHtcbiAgICBpID0gaSQ7XG4gICAgbHJlc3VsdCQgPSBbXTtcbiAgICBmb3IgKGokID0gMCwgbGVuJCA9IHhzcy5sZW5ndGg7IGokIDwgbGVuJDsgKytqJCkge1xuICAgICAgeHMgPSB4c3NbaiRdO1xuICAgICAgbHJlc3VsdCQucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJlc3VsdHMkLnB1c2gobHJlc3VsdCQpO1xuICB9XG4gIHJldHVybiByZXN1bHRzJDtcbn07XG56aXBBbGxXaXRoID0gZnVuY3Rpb24oZil7XG4gIHZhciB4c3MsIG1pbkxlbmd0aCwgaSQsIGxlbiQsIHhzLCByZWYkLCBpLCByZXN1bHRzJCA9IFtdO1xuICB4c3MgPSBzbGljZSQuY2FsbChhcmd1bWVudHMsIDEpO1xuICBtaW5MZW5ndGggPSA5ZTk7XG4gIGZvciAoaSQgPSAwLCBsZW4kID0geHNzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgeHMgPSB4c3NbaSRdO1xuICAgIG1pbkxlbmd0aCA8PSAocmVmJCA9IHhzLmxlbmd0aCkgfHwgKG1pbkxlbmd0aCA9IHJlZiQpO1xuICB9XG4gIGZvciAoaSQgPSAwOyBpJCA8IG1pbkxlbmd0aDsgKytpJCkge1xuICAgIGkgPSBpJDtcbiAgICByZXN1bHRzJC5wdXNoKGYuYXBwbHkobnVsbCwgKGZuJCgpKSkpO1xuICB9XG4gIHJldHVybiByZXN1bHRzJDtcbiAgZnVuY3Rpb24gZm4kKCl7XG4gICAgdmFyIGkkLCByZWYkLCBsZW4kLCByZXN1bHRzJCA9IFtdO1xuICAgIGZvciAoaSQgPSAwLCBsZW4kID0gKHJlZiQgPSB4c3MpLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgICB4cyA9IHJlZiRbaSRdO1xuICAgICAgcmVzdWx0cyQucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzJDtcbiAgfVxufTtcbmF0ID0gY3VycnkkKGZ1bmN0aW9uKG4sIHhzKXtcbiAgaWYgKG4gPCAwKSB7XG4gICAgcmV0dXJuIHhzW3hzLmxlbmd0aCArIG5dO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB4c1tuXTtcbiAgfVxufSk7XG5lbGVtSW5kZXggPSBjdXJyeSQoZnVuY3Rpb24oZWwsIHhzKXtcbiAgdmFyIGkkLCBsZW4kLCBpLCB4O1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IHhzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgaSA9IGkkO1xuICAgIHggPSB4c1tpJF07XG4gICAgaWYgKHggPT09IGVsKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbn0pO1xuZWxlbUluZGljZXMgPSBjdXJyeSQoZnVuY3Rpb24oZWwsIHhzKXtcbiAgdmFyIGkkLCBsZW4kLCBpLCB4LCByZXN1bHRzJCA9IFtdO1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IHhzLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgaSA9IGkkO1xuICAgIHggPSB4c1tpJF07XG4gICAgaWYgKHggPT09IGVsKSB7XG4gICAgICByZXN1bHRzJC5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0cyQ7XG59KTtcbmZpbmRJbmRleCA9IGN1cnJ5JChmdW5jdGlvbihmLCB4cyl7XG4gIHZhciBpJCwgbGVuJCwgaSwgeDtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSB4cy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIGkgPSBpJDtcbiAgICB4ID0geHNbaSRdO1xuICAgIGlmIChmKHgpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbn0pO1xuZmluZEluZGljZXMgPSBjdXJyeSQoZnVuY3Rpb24oZiwgeHMpe1xuICB2YXIgaSQsIGxlbiQsIGksIHgsIHJlc3VsdHMkID0gW107XG4gIGZvciAoaSQgPSAwLCBsZW4kID0geHMubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICBpID0gaSQ7XG4gICAgeCA9IHhzW2kkXTtcbiAgICBpZiAoZih4KSkge1xuICAgICAgcmVzdWx0cyQucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHMkO1xufSk7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZWFjaDogZWFjaCxcbiAgbWFwOiBtYXAsXG4gIGZpbHRlcjogZmlsdGVyLFxuICBjb21wYWN0OiBjb21wYWN0LFxuICByZWplY3Q6IHJlamVjdCxcbiAgcGFydGl0aW9uOiBwYXJ0aXRpb24sXG4gIGZpbmQ6IGZpbmQsXG4gIGhlYWQ6IGhlYWQsXG4gIGZpcnN0OiBmaXJzdCxcbiAgdGFpbDogdGFpbCxcbiAgbGFzdDogbGFzdCxcbiAgaW5pdGlhbDogaW5pdGlhbCxcbiAgZW1wdHk6IGVtcHR5LFxuICByZXZlcnNlOiByZXZlcnNlLFxuICBkaWZmZXJlbmNlOiBkaWZmZXJlbmNlLFxuICBpbnRlcnNlY3Rpb246IGludGVyc2VjdGlvbixcbiAgdW5pb246IHVuaW9uLFxuICBjb3VudEJ5OiBjb3VudEJ5LFxuICBncm91cEJ5OiBncm91cEJ5LFxuICBmb2xkOiBmb2xkLFxuICBmb2xkMTogZm9sZDEsXG4gIGZvbGRsOiBmb2xkbCxcbiAgZm9sZGwxOiBmb2xkbDEsXG4gIGZvbGRyOiBmb2xkcixcbiAgZm9sZHIxOiBmb2xkcjEsXG4gIHVuZm9sZHI6IHVuZm9sZHIsXG4gIGFuZExpc3Q6IGFuZExpc3QsXG4gIG9yTGlzdDogb3JMaXN0LFxuICBhbnk6IGFueSxcbiAgYWxsOiBhbGwsXG4gIHVuaXF1ZTogdW5pcXVlLFxuICB1bmlxdWVCeTogdW5pcXVlQnksXG4gIHNvcnQ6IHNvcnQsXG4gIHNvcnRXaXRoOiBzb3J0V2l0aCxcbiAgc29ydEJ5OiBzb3J0QnksXG4gIHN1bTogc3VtLFxuICBwcm9kdWN0OiBwcm9kdWN0LFxuICBtZWFuOiBtZWFuLFxuICBhdmVyYWdlOiBhdmVyYWdlLFxuICBjb25jYXQ6IGNvbmNhdCxcbiAgY29uY2F0TWFwOiBjb25jYXRNYXAsXG4gIGZsYXR0ZW46IGZsYXR0ZW4sXG4gIG1heGltdW06IG1heGltdW0sXG4gIG1pbmltdW06IG1pbmltdW0sXG4gIG1heGltdW1CeTogbWF4aW11bUJ5LFxuICBtaW5pbXVtQnk6IG1pbmltdW1CeSxcbiAgc2Nhbjogc2NhbixcbiAgc2NhbjE6IHNjYW4xLFxuICBzY2FubDogc2NhbmwsXG4gIHNjYW5sMTogc2NhbmwxLFxuICBzY2Fucjogc2NhbnIsXG4gIHNjYW5yMTogc2NhbnIxLFxuICBzbGljZTogc2xpY2UsXG4gIHRha2U6IHRha2UsXG4gIGRyb3A6IGRyb3AsXG4gIHNwbGl0QXQ6IHNwbGl0QXQsXG4gIHRha2VXaGlsZTogdGFrZVdoaWxlLFxuICBkcm9wV2hpbGU6IGRyb3BXaGlsZSxcbiAgc3Bhbjogc3BhbixcbiAgYnJlYWtMaXN0OiBicmVha0xpc3QsXG4gIHppcDogemlwLFxuICB6aXBXaXRoOiB6aXBXaXRoLFxuICB6aXBBbGw6IHppcEFsbCxcbiAgemlwQWxsV2l0aDogemlwQWxsV2l0aCxcbiAgYXQ6IGF0LFxuICBlbGVtSW5kZXg6IGVsZW1JbmRleCxcbiAgZWxlbUluZGljZXM6IGVsZW1JbmRpY2VzLFxuICBmaW5kSW5kZXg6IGZpbmRJbmRleCxcbiAgZmluZEluZGljZXM6IGZpbmRJbmRpY2VzXG59O1xuZnVuY3Rpb24gY3VycnkkKGYsIGJvdW5kKXtcbiAgdmFyIGNvbnRleHQsXG4gIF9jdXJyeSA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICByZXR1cm4gZi5sZW5ndGggPiAxID8gZnVuY3Rpb24oKXtcbiAgICAgIHZhciBwYXJhbXMgPSBhcmdzID8gYXJncy5jb25jYXQoKSA6IFtdO1xuICAgICAgY29udGV4dCA9IGJvdW5kID8gY29udGV4dCB8fCB0aGlzIDogdGhpcztcbiAgICAgIHJldHVybiBwYXJhbXMucHVzaC5hcHBseShwYXJhbXMsIGFyZ3VtZW50cykgPFxuICAgICAgICAgIGYubGVuZ3RoICYmIGFyZ3VtZW50cy5sZW5ndGggP1xuICAgICAgICBfY3VycnkuY2FsbChjb250ZXh0LCBwYXJhbXMpIDogZi5hcHBseShjb250ZXh0LCBwYXJhbXMpO1xuICAgIH0gOiBmO1xuICB9O1xuICByZXR1cm4gX2N1cnJ5KCk7XG59XG5mdW5jdGlvbiBpbiQoeCwgeHMpe1xuICB2YXIgaSA9IC0xLCBsID0geHMubGVuZ3RoID4+PiAwO1xuICB3aGlsZSAoKytpIDwgbCkgaWYgKHggPT09IHhzW2ldKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gbm90JCh4KXsgcmV0dXJuICF4OyB9IiwiLy8gR2VuZXJhdGVkIGJ5IExpdmVTY3JpcHQgMS4yLjBcbnZhciBtYXgsIG1pbiwgbmVnYXRlLCBhYnMsIHNpZ251bSwgcXVvdCwgcmVtLCBkaXYsIG1vZCwgcmVjaXAsIHBpLCB0YXUsIGV4cCwgc3FydCwgbG4sIHBvdywgc2luLCB0YW4sIGNvcywgYXNpbiwgYWNvcywgYXRhbiwgYXRhbjIsIHRydW5jYXRlLCByb3VuZCwgY2VpbGluZywgZmxvb3IsIGlzSXROYU4sIGV2ZW4sIG9kZCwgZ2NkLCBsY207XG5tYXggPSBjdXJyeSQoZnVuY3Rpb24oeCQsIHkkKXtcbiAgcmV0dXJuIHgkID4geSQgPyB4JCA6IHkkO1xufSk7XG5taW4gPSBjdXJyeSQoZnVuY3Rpb24oeCQsIHkkKXtcbiAgcmV0dXJuIHgkIDwgeSQgPyB4JCA6IHkkO1xufSk7XG5uZWdhdGUgPSBmdW5jdGlvbih4KXtcbiAgcmV0dXJuIC14O1xufTtcbmFicyA9IE1hdGguYWJzO1xuc2lnbnVtID0gZnVuY3Rpb24oeCl7XG4gIGlmICh4IDwgMCkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIGlmICh4ID4gMCkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xucXVvdCA9IGN1cnJ5JChmdW5jdGlvbih4LCB5KXtcbiAgcmV0dXJuIH5+KHggLyB5KTtcbn0pO1xucmVtID0gY3VycnkkKGZ1bmN0aW9uKHgkLCB5JCl7XG4gIHJldHVybiB4JCAlIHkkO1xufSk7XG5kaXYgPSBjdXJyeSQoZnVuY3Rpb24oeCwgeSl7XG4gIHJldHVybiBNYXRoLmZsb29yKHggLyB5KTtcbn0pO1xubW9kID0gY3VycnkkKGZ1bmN0aW9uKHgkLCB5JCl7XG4gIHZhciByZWYkO1xuICByZXR1cm4gKCh4JCkgJSAocmVmJCA9IHkkKSArIHJlZiQpICUgcmVmJDtcbn0pO1xucmVjaXAgPSAoZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gMSAvIGl0O1xufSk7XG5waSA9IE1hdGguUEk7XG50YXUgPSBwaSAqIDI7XG5leHAgPSBNYXRoLmV4cDtcbnNxcnQgPSBNYXRoLnNxcnQ7XG5sbiA9IE1hdGgubG9nO1xucG93ID0gY3VycnkkKGZ1bmN0aW9uKHgkLCB5JCl7XG4gIHJldHVybiBNYXRoLnBvdyh4JCwgeSQpO1xufSk7XG5zaW4gPSBNYXRoLnNpbjtcbnRhbiA9IE1hdGgudGFuO1xuY29zID0gTWF0aC5jb3M7XG5hc2luID0gTWF0aC5hc2luO1xuYWNvcyA9IE1hdGguYWNvcztcbmF0YW4gPSBNYXRoLmF0YW47XG5hdGFuMiA9IGN1cnJ5JChmdW5jdGlvbih4LCB5KXtcbiAgcmV0dXJuIE1hdGguYXRhbjIoeCwgeSk7XG59KTtcbnRydW5jYXRlID0gZnVuY3Rpb24oeCl7XG4gIHJldHVybiB+fng7XG59O1xucm91bmQgPSBNYXRoLnJvdW5kO1xuY2VpbGluZyA9IE1hdGguY2VpbDtcbmZsb29yID0gTWF0aC5mbG9vcjtcbmlzSXROYU4gPSBmdW5jdGlvbih4KXtcbiAgcmV0dXJuIHggIT09IHg7XG59O1xuZXZlbiA9IGZ1bmN0aW9uKHgpe1xuICByZXR1cm4geCAlIDIgPT09IDA7XG59O1xub2RkID0gZnVuY3Rpb24oeCl7XG4gIHJldHVybiB4ICUgMiAhPT0gMDtcbn07XG5nY2QgPSBjdXJyeSQoZnVuY3Rpb24oeCwgeSl7XG4gIHZhciB6O1xuICB4ID0gTWF0aC5hYnMoeCk7XG4gIHkgPSBNYXRoLmFicyh5KTtcbiAgd2hpbGUgKHkgIT09IDApIHtcbiAgICB6ID0geCAlIHk7XG4gICAgeCA9IHk7XG4gICAgeSA9IHo7XG4gIH1cbiAgcmV0dXJuIHg7XG59KTtcbmxjbSA9IGN1cnJ5JChmdW5jdGlvbih4LCB5KXtcbiAgcmV0dXJuIE1hdGguYWJzKE1hdGguZmxvb3IoeCAvIGdjZCh4LCB5KSAqIHkpKTtcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1heDogbWF4LFxuICBtaW46IG1pbixcbiAgbmVnYXRlOiBuZWdhdGUsXG4gIGFiczogYWJzLFxuICBzaWdudW06IHNpZ251bSxcbiAgcXVvdDogcXVvdCxcbiAgcmVtOiByZW0sXG4gIGRpdjogZGl2LFxuICBtb2Q6IG1vZCxcbiAgcmVjaXA6IHJlY2lwLFxuICBwaTogcGksXG4gIHRhdTogdGF1LFxuICBleHA6IGV4cCxcbiAgc3FydDogc3FydCxcbiAgbG46IGxuLFxuICBwb3c6IHBvdyxcbiAgc2luOiBzaW4sXG4gIHRhbjogdGFuLFxuICBjb3M6IGNvcyxcbiAgYWNvczogYWNvcyxcbiAgYXNpbjogYXNpbixcbiAgYXRhbjogYXRhbixcbiAgYXRhbjI6IGF0YW4yLFxuICB0cnVuY2F0ZTogdHJ1bmNhdGUsXG4gIHJvdW5kOiByb3VuZCxcbiAgY2VpbGluZzogY2VpbGluZyxcbiAgZmxvb3I6IGZsb29yLFxuICBpc0l0TmFOOiBpc0l0TmFOLFxuICBldmVuOiBldmVuLFxuICBvZGQ6IG9kZCxcbiAgZ2NkOiBnY2QsXG4gIGxjbTogbGNtXG59O1xuZnVuY3Rpb24gY3VycnkkKGYsIGJvdW5kKXtcbiAgdmFyIGNvbnRleHQsXG4gIF9jdXJyeSA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICByZXR1cm4gZi5sZW5ndGggPiAxID8gZnVuY3Rpb24oKXtcbiAgICAgIHZhciBwYXJhbXMgPSBhcmdzID8gYXJncy5jb25jYXQoKSA6IFtdO1xuICAgICAgY29udGV4dCA9IGJvdW5kID8gY29udGV4dCB8fCB0aGlzIDogdGhpcztcbiAgICAgIHJldHVybiBwYXJhbXMucHVzaC5hcHBseShwYXJhbXMsIGFyZ3VtZW50cykgPFxuICAgICAgICAgIGYubGVuZ3RoICYmIGFyZ3VtZW50cy5sZW5ndGggP1xuICAgICAgICBfY3VycnkuY2FsbChjb250ZXh0LCBwYXJhbXMpIDogZi5hcHBseShjb250ZXh0LCBwYXJhbXMpO1xuICAgIH0gOiBmO1xuICB9O1xuICByZXR1cm4gX2N1cnJ5KCk7XG59IiwiLy8gR2VuZXJhdGVkIGJ5IExpdmVTY3JpcHQgMS4yLjBcbnZhciB2YWx1ZXMsIGtleXMsIHBhaXJzVG9PYmosIG9ialRvUGFpcnMsIGxpc3RzVG9PYmosIG9ialRvTGlzdHMsIGVtcHR5LCBlYWNoLCBtYXAsIGNvbXBhY3QsIGZpbHRlciwgcmVqZWN0LCBwYXJ0aXRpb24sIGZpbmQ7XG52YWx1ZXMgPSBmdW5jdGlvbihvYmplY3Qpe1xuICB2YXIgaSQsIHgsIHJlc3VsdHMkID0gW107XG4gIGZvciAoaSQgaW4gb2JqZWN0KSB7XG4gICAgeCA9IG9iamVjdFtpJF07XG4gICAgcmVzdWx0cyQucHVzaCh4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cyQ7XG59O1xua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCl7XG4gIHZhciB4LCByZXN1bHRzJCA9IFtdO1xuICBmb3IgKHggaW4gb2JqZWN0KSB7XG4gICAgcmVzdWx0cyQucHVzaCh4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cyQ7XG59O1xucGFpcnNUb09iaiA9IGZ1bmN0aW9uKG9iamVjdCl7XG4gIHZhciBpJCwgbGVuJCwgeCwgcmVzdWx0cyQgPSB7fTtcbiAgZm9yIChpJCA9IDAsIGxlbiQgPSBvYmplY3QubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICB4ID0gb2JqZWN0W2kkXTtcbiAgICByZXN1bHRzJFt4WzBdXSA9IHhbMV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHMkO1xufTtcbm9ialRvUGFpcnMgPSBmdW5jdGlvbihvYmplY3Qpe1xuICB2YXIga2V5LCB2YWx1ZSwgcmVzdWx0cyQgPSBbXTtcbiAgZm9yIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICByZXN1bHRzJC5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHMkO1xufTtcbmxpc3RzVG9PYmogPSBjdXJyeSQoZnVuY3Rpb24oa2V5cywgdmFsdWVzKXtcbiAgdmFyIGkkLCBsZW4kLCBpLCBrZXksIHJlc3VsdHMkID0ge307XG4gIGZvciAoaSQgPSAwLCBsZW4kID0ga2V5cy5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgIGkgPSBpJDtcbiAgICBrZXkgPSBrZXlzW2kkXTtcbiAgICByZXN1bHRzJFtrZXldID0gdmFsdWVzW2ldO1xuICB9XG4gIHJldHVybiByZXN1bHRzJDtcbn0pO1xub2JqVG9MaXN0cyA9IGZ1bmN0aW9uKG9iamVjdCl7XG4gIHZhciBrZXlzLCB2YWx1ZXMsIGtleSwgdmFsdWU7XG4gIGtleXMgPSBbXTtcbiAgdmFsdWVzID0gW107XG4gIGZvciAoa2V5IGluIG9iamVjdCkge1xuICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAga2V5cy5wdXNoKGtleSk7XG4gICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICB9XG4gIHJldHVybiBba2V5cywgdmFsdWVzXTtcbn07XG5lbXB0eSA9IGZ1bmN0aW9uKG9iamVjdCl7XG4gIHZhciB4O1xuICBmb3IgKHggaW4gb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbmVhY2ggPSBjdXJyeSQoZnVuY3Rpb24oZiwgb2JqZWN0KXtcbiAgdmFyIGkkLCB4O1xuICBmb3IgKGkkIGluIG9iamVjdCkge1xuICAgIHggPSBvYmplY3RbaSRdO1xuICAgIGYoeCk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn0pO1xubWFwID0gY3VycnkkKGZ1bmN0aW9uKGYsIG9iamVjdCl7XG4gIHZhciBrLCB4LCByZXN1bHRzJCA9IHt9O1xuICBmb3IgKGsgaW4gb2JqZWN0KSB7XG4gICAgeCA9IG9iamVjdFtrXTtcbiAgICByZXN1bHRzJFtrXSA9IGYoeCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHMkO1xufSk7XG5jb21wYWN0ID0gZnVuY3Rpb24ob2JqZWN0KXtcbiAgdmFyIGssIHgsIHJlc3VsdHMkID0ge307XG4gIGZvciAoayBpbiBvYmplY3QpIHtcbiAgICB4ID0gb2JqZWN0W2tdO1xuaWYgKHgpIHtcbiAgICAgIHJlc3VsdHMkW2tdID0geDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHMkO1xufTtcbmZpbHRlciA9IGN1cnJ5JChmdW5jdGlvbihmLCBvYmplY3Qpe1xuICB2YXIgaywgeCwgcmVzdWx0cyQgPSB7fTtcbiAgZm9yIChrIGluIG9iamVjdCkge1xuICAgIHggPSBvYmplY3Rba107XG5pZiAoZih4KSkge1xuICAgICAgcmVzdWx0cyRba10gPSB4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0cyQ7XG59KTtcbnJlamVjdCA9IGN1cnJ5JChmdW5jdGlvbihmLCBvYmplY3Qpe1xuICB2YXIgaywgeCwgcmVzdWx0cyQgPSB7fTtcbiAgZm9yIChrIGluIG9iamVjdCkge1xuICAgIHggPSBvYmplY3Rba107XG5pZiAoIWYoeCkpIHtcbiAgICAgIHJlc3VsdHMkW2tdID0geDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHMkO1xufSk7XG5wYXJ0aXRpb24gPSBjdXJyeSQoZnVuY3Rpb24oZiwgb2JqZWN0KXtcbiAgdmFyIHBhc3NlZCwgZmFpbGVkLCBrLCB4O1xuICBwYXNzZWQgPSB7fTtcbiAgZmFpbGVkID0ge307XG4gIGZvciAoayBpbiBvYmplY3QpIHtcbiAgICB4ID0gb2JqZWN0W2tdO1xuICAgIChmKHgpID8gcGFzc2VkIDogZmFpbGVkKVtrXSA9IHg7XG4gIH1cbiAgcmV0dXJuIFtwYXNzZWQsIGZhaWxlZF07XG59KTtcbmZpbmQgPSBjdXJyeSQoZnVuY3Rpb24oZiwgb2JqZWN0KXtcbiAgdmFyIGkkLCB4O1xuICBmb3IgKGkkIGluIG9iamVjdCkge1xuICAgIHggPSBvYmplY3RbaSRdO1xuICAgIGlmIChmKHgpKSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHZhbHVlczogdmFsdWVzLFxuICBrZXlzOiBrZXlzLFxuICBwYWlyc1RvT2JqOiBwYWlyc1RvT2JqLFxuICBvYmpUb1BhaXJzOiBvYmpUb1BhaXJzLFxuICBsaXN0c1RvT2JqOiBsaXN0c1RvT2JqLFxuICBvYmpUb0xpc3RzOiBvYmpUb0xpc3RzLFxuICBlbXB0eTogZW1wdHksXG4gIGVhY2g6IGVhY2gsXG4gIG1hcDogbWFwLFxuICBmaWx0ZXI6IGZpbHRlcixcbiAgY29tcGFjdDogY29tcGFjdCxcbiAgcmVqZWN0OiByZWplY3QsXG4gIHBhcnRpdGlvbjogcGFydGl0aW9uLFxuICBmaW5kOiBmaW5kXG59O1xuZnVuY3Rpb24gY3VycnkkKGYsIGJvdW5kKXtcbiAgdmFyIGNvbnRleHQsXG4gIF9jdXJyeSA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICByZXR1cm4gZi5sZW5ndGggPiAxID8gZnVuY3Rpb24oKXtcbiAgICAgIHZhciBwYXJhbXMgPSBhcmdzID8gYXJncy5jb25jYXQoKSA6IFtdO1xuICAgICAgY29udGV4dCA9IGJvdW5kID8gY29udGV4dCB8fCB0aGlzIDogdGhpcztcbiAgICAgIHJldHVybiBwYXJhbXMucHVzaC5hcHBseShwYXJhbXMsIGFyZ3VtZW50cykgPFxuICAgICAgICAgIGYubGVuZ3RoICYmIGFyZ3VtZW50cy5sZW5ndGggP1xuICAgICAgICBfY3VycnkuY2FsbChjb250ZXh0LCBwYXJhbXMpIDogZi5hcHBseShjb250ZXh0LCBwYXJhbXMpO1xuICAgIH0gOiBmO1xuICB9O1xuICByZXR1cm4gX2N1cnJ5KCk7XG59IiwiLy8gR2VuZXJhdGVkIGJ5IExpdmVTY3JpcHQgMS4yLjBcbnZhciBzcGxpdCwgam9pbiwgbGluZXMsIHVubGluZXMsIHdvcmRzLCB1bndvcmRzLCBjaGFycywgdW5jaGFycywgcmV2ZXJzZSwgcmVwZWF0LCBjYXBpdGFsaXplLCBjYW1lbGl6ZSwgZGFzaGVyaXplO1xuc3BsaXQgPSBjdXJyeSQoZnVuY3Rpb24oc2VwLCBzdHIpe1xuICByZXR1cm4gc3RyLnNwbGl0KHNlcCk7XG59KTtcbmpvaW4gPSBjdXJyeSQoZnVuY3Rpb24oc2VwLCB4cyl7XG4gIHJldHVybiB4cy5qb2luKHNlcCk7XG59KTtcbmxpbmVzID0gZnVuY3Rpb24oc3RyKXtcbiAgaWYgKCFzdHIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBzdHIuc3BsaXQoJ1xcbicpO1xufTtcbnVubGluZXMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdC5qb2luKCdcXG4nKTtcbn07XG53b3JkcyA9IGZ1bmN0aW9uKHN0cil7XG4gIGlmICghc3RyLmxlbmd0aCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gc3RyLnNwbGl0KC9bIF0rLyk7XG59O1xudW53b3JkcyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0LmpvaW4oJyAnKTtcbn07XG5jaGFycyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0LnNwbGl0KCcnKTtcbn07XG51bmNoYXJzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQuam9pbignJyk7XG59O1xucmV2ZXJzZSA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKTtcbn07XG5yZXBlYXQgPSBjdXJyeSQoZnVuY3Rpb24obiwgc3RyKXtcbiAgdmFyIHJlc3VsdCwgaSQ7XG4gIHJlc3VsdCA9ICcnO1xuICBmb3IgKGkkID0gMDsgaSQgPCBuOyArK2kkKSB7XG4gICAgcmVzdWx0ICs9IHN0cjtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5jYXBpdGFsaXplID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn07XG5jYW1lbGl6ZSA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0LnJlcGxhY2UoL1stX10rKC4pPy9nLCBmdW5jdGlvbihhcmckLCBjKXtcbiAgICByZXR1cm4gKGMgIT0gbnVsbCA/IGMgOiAnJykudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59O1xuZGFzaGVyaXplID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW14tQS1aXSkoW0EtWl0rKS9nLCBmdW5jdGlvbihhcmckLCBsb3dlciwgdXBwZXIpe1xuICAgIHJldHVybiBsb3dlciArIFwiLVwiICsgKHVwcGVyLmxlbmd0aCA+IDFcbiAgICAgID8gdXBwZXJcbiAgICAgIDogdXBwZXIudG9Mb3dlckNhc2UoKSk7XG4gIH0pLnJlcGxhY2UoL14oW0EtWl0rKS8sIGZ1bmN0aW9uKGFyZyQsIHVwcGVyKXtcbiAgICBpZiAodXBwZXIubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHVwcGVyICsgXCItXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1cHBlci50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgfSk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNwbGl0OiBzcGxpdCxcbiAgam9pbjogam9pbixcbiAgbGluZXM6IGxpbmVzLFxuICB1bmxpbmVzOiB1bmxpbmVzLFxuICB3b3Jkczogd29yZHMsXG4gIHVud29yZHM6IHVud29yZHMsXG4gIGNoYXJzOiBjaGFycyxcbiAgdW5jaGFyczogdW5jaGFycyxcbiAgcmV2ZXJzZTogcmV2ZXJzZSxcbiAgcmVwZWF0OiByZXBlYXQsXG4gIGNhcGl0YWxpemU6IGNhcGl0YWxpemUsXG4gIGNhbWVsaXplOiBjYW1lbGl6ZSxcbiAgZGFzaGVyaXplOiBkYXNoZXJpemVcbn07XG5mdW5jdGlvbiBjdXJyeSQoZiwgYm91bmQpe1xuICB2YXIgY29udGV4dCxcbiAgX2N1cnJ5ID0gZnVuY3Rpb24oYXJncykge1xuICAgIHJldHVybiBmLmxlbmd0aCA+IDEgPyBmdW5jdGlvbigpe1xuICAgICAgdmFyIHBhcmFtcyA9IGFyZ3MgPyBhcmdzLmNvbmNhdCgpIDogW107XG4gICAgICBjb250ZXh0ID0gYm91bmQgPyBjb250ZXh0IHx8IHRoaXMgOiB0aGlzO1xuICAgICAgcmV0dXJuIHBhcmFtcy5wdXNoLmFwcGx5KHBhcmFtcywgYXJndW1lbnRzKSA8XG4gICAgICAgICAgZi5sZW5ndGggJiYgYXJndW1lbnRzLmxlbmd0aCA/XG4gICAgICAgIF9jdXJyeS5jYWxsKGNvbnRleHQsIHBhcmFtcykgOiBmLmFwcGx5KGNvbnRleHQsIHBhcmFtcyk7XG4gICAgfSA6IGY7XG4gIH07XG4gIHJldHVybiBfY3VycnkoKTtcbn0iLCIvLyBHZW5lcmF0ZWQgYnkgTGl2ZVNjcmlwdCAxLjIuMFxudmFyIEZ1bmMsIExpc3QsIE9iaiwgU3RyLCBOdW0sIGlkLCBpc1R5cGUsIHJlcGxpY2F0ZSwgcHJlbHVkZSwgdG9TdHJpbmckID0ge30udG9TdHJpbmc7XG5GdW5jID0gcmVxdWlyZSgnLi9GdW5jLmpzJyk7XG5MaXN0ID0gcmVxdWlyZSgnLi9MaXN0LmpzJyk7XG5PYmogPSByZXF1aXJlKCcuL09iai5qcycpO1xuU3RyID0gcmVxdWlyZSgnLi9TdHIuanMnKTtcbk51bSA9IHJlcXVpcmUoJy4vTnVtLmpzJyk7XG5pZCA9IGZ1bmN0aW9uKHgpe1xuICByZXR1cm4geDtcbn07XG5pc1R5cGUgPSBjdXJyeSQoZnVuY3Rpb24odHlwZSwgeCl7XG4gIHJldHVybiB0b1N0cmluZyQuY2FsbCh4KS5zbGljZSg4LCAtMSkgPT09IHR5cGU7XG59KTtcbnJlcGxpY2F0ZSA9IGN1cnJ5JChmdW5jdGlvbihuLCB4KXtcbiAgdmFyIGkkLCByZXN1bHRzJCA9IFtdO1xuICBmb3IgKGkkID0gMDsgaSQgPCBuOyArK2kkKSB7XG4gICAgcmVzdWx0cyQucHVzaCh4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cyQ7XG59KTtcblN0ci5lbXB0eSA9IExpc3QuZW1wdHk7XG5TdHIuc2xpY2UgPSBMaXN0LnNsaWNlO1xuU3RyLnRha2UgPSBMaXN0LnRha2U7XG5TdHIuZHJvcCA9IExpc3QuZHJvcDtcblN0ci5zcGxpdEF0ID0gTGlzdC5zcGxpdEF0O1xuU3RyLnRha2VXaGlsZSA9IExpc3QudGFrZVdoaWxlO1xuU3RyLmRyb3BXaGlsZSA9IExpc3QuZHJvcFdoaWxlO1xuU3RyLnNwYW4gPSBMaXN0LnNwYW47XG5TdHIuYnJlYWtTdHIgPSBMaXN0LmJyZWFrTGlzdDtcbnByZWx1ZGUgPSB7XG4gIEZ1bmM6IEZ1bmMsXG4gIExpc3Q6IExpc3QsXG4gIE9iajogT2JqLFxuICBTdHI6IFN0cixcbiAgTnVtOiBOdW0sXG4gIGlkOiBpZCxcbiAgaXNUeXBlOiBpc1R5cGUsXG4gIHJlcGxpY2F0ZTogcmVwbGljYXRlXG59O1xucHJlbHVkZS5lYWNoID0gTGlzdC5lYWNoO1xucHJlbHVkZS5tYXAgPSBMaXN0Lm1hcDtcbnByZWx1ZGUuZmlsdGVyID0gTGlzdC5maWx0ZXI7XG5wcmVsdWRlLmNvbXBhY3QgPSBMaXN0LmNvbXBhY3Q7XG5wcmVsdWRlLnJlamVjdCA9IExpc3QucmVqZWN0O1xucHJlbHVkZS5wYXJ0aXRpb24gPSBMaXN0LnBhcnRpdGlvbjtcbnByZWx1ZGUuZmluZCA9IExpc3QuZmluZDtcbnByZWx1ZGUuaGVhZCA9IExpc3QuaGVhZDtcbnByZWx1ZGUuZmlyc3QgPSBMaXN0LmZpcnN0O1xucHJlbHVkZS50YWlsID0gTGlzdC50YWlsO1xucHJlbHVkZS5sYXN0ID0gTGlzdC5sYXN0O1xucHJlbHVkZS5pbml0aWFsID0gTGlzdC5pbml0aWFsO1xucHJlbHVkZS5lbXB0eSA9IExpc3QuZW1wdHk7XG5wcmVsdWRlLnJldmVyc2UgPSBMaXN0LnJldmVyc2U7XG5wcmVsdWRlLmRpZmZlcmVuY2UgPSBMaXN0LmRpZmZlcmVuY2U7XG5wcmVsdWRlLmludGVyc2VjdGlvbiA9IExpc3QuaW50ZXJzZWN0aW9uO1xucHJlbHVkZS51bmlvbiA9IExpc3QudW5pb247XG5wcmVsdWRlLmNvdW50QnkgPSBMaXN0LmNvdW50Qnk7XG5wcmVsdWRlLmdyb3VwQnkgPSBMaXN0Lmdyb3VwQnk7XG5wcmVsdWRlLmZvbGQgPSBMaXN0LmZvbGQ7XG5wcmVsdWRlLmZvbGRsID0gTGlzdC5mb2xkbDtcbnByZWx1ZGUuZm9sZDEgPSBMaXN0LmZvbGQxO1xucHJlbHVkZS5mb2xkbDEgPSBMaXN0LmZvbGRsMTtcbnByZWx1ZGUuZm9sZHIgPSBMaXN0LmZvbGRyO1xucHJlbHVkZS5mb2xkcjEgPSBMaXN0LmZvbGRyMTtcbnByZWx1ZGUudW5mb2xkciA9IExpc3QudW5mb2xkcjtcbnByZWx1ZGUuYW5kTGlzdCA9IExpc3QuYW5kTGlzdDtcbnByZWx1ZGUub3JMaXN0ID0gTGlzdC5vckxpc3Q7XG5wcmVsdWRlLmFueSA9IExpc3QuYW55O1xucHJlbHVkZS5hbGwgPSBMaXN0LmFsbDtcbnByZWx1ZGUudW5pcXVlID0gTGlzdC51bmlxdWU7XG5wcmVsdWRlLnVuaXF1ZUJ5ID0gTGlzdC51bmlxdWVCeTtcbnByZWx1ZGUuc29ydCA9IExpc3Quc29ydDtcbnByZWx1ZGUuc29ydFdpdGggPSBMaXN0LnNvcnRXaXRoO1xucHJlbHVkZS5zb3J0QnkgPSBMaXN0LnNvcnRCeTtcbnByZWx1ZGUuc3VtID0gTGlzdC5zdW07XG5wcmVsdWRlLnByb2R1Y3QgPSBMaXN0LnByb2R1Y3Q7XG5wcmVsdWRlLm1lYW4gPSBMaXN0Lm1lYW47XG5wcmVsdWRlLmF2ZXJhZ2UgPSBMaXN0LmF2ZXJhZ2U7XG5wcmVsdWRlLmNvbmNhdCA9IExpc3QuY29uY2F0O1xucHJlbHVkZS5jb25jYXRNYXAgPSBMaXN0LmNvbmNhdE1hcDtcbnByZWx1ZGUuZmxhdHRlbiA9IExpc3QuZmxhdHRlbjtcbnByZWx1ZGUubWF4aW11bSA9IExpc3QubWF4aW11bTtcbnByZWx1ZGUubWluaW11bSA9IExpc3QubWluaW11bTtcbnByZWx1ZGUubWF4aW11bUJ5ID0gTGlzdC5tYXhpbXVtQnk7XG5wcmVsdWRlLm1pbmltdW1CeSA9IExpc3QubWluaW11bUJ5O1xucHJlbHVkZS5zY2FuID0gTGlzdC5zY2FuO1xucHJlbHVkZS5zY2FubCA9IExpc3Quc2Nhbmw7XG5wcmVsdWRlLnNjYW4xID0gTGlzdC5zY2FuMTtcbnByZWx1ZGUuc2NhbmwxID0gTGlzdC5zY2FubDE7XG5wcmVsdWRlLnNjYW5yID0gTGlzdC5zY2FucjtcbnByZWx1ZGUuc2NhbnIxID0gTGlzdC5zY2FucjE7XG5wcmVsdWRlLnNsaWNlID0gTGlzdC5zbGljZTtcbnByZWx1ZGUudGFrZSA9IExpc3QudGFrZTtcbnByZWx1ZGUuZHJvcCA9IExpc3QuZHJvcDtcbnByZWx1ZGUuc3BsaXRBdCA9IExpc3Quc3BsaXRBdDtcbnByZWx1ZGUudGFrZVdoaWxlID0gTGlzdC50YWtlV2hpbGU7XG5wcmVsdWRlLmRyb3BXaGlsZSA9IExpc3QuZHJvcFdoaWxlO1xucHJlbHVkZS5zcGFuID0gTGlzdC5zcGFuO1xucHJlbHVkZS5icmVha0xpc3QgPSBMaXN0LmJyZWFrTGlzdDtcbnByZWx1ZGUuemlwID0gTGlzdC56aXA7XG5wcmVsdWRlLnppcFdpdGggPSBMaXN0LnppcFdpdGg7XG5wcmVsdWRlLnppcEFsbCA9IExpc3QuemlwQWxsO1xucHJlbHVkZS56aXBBbGxXaXRoID0gTGlzdC56aXBBbGxXaXRoO1xucHJlbHVkZS5hdCA9IExpc3QuYXQ7XG5wcmVsdWRlLmVsZW1JbmRleCA9IExpc3QuZWxlbUluZGV4O1xucHJlbHVkZS5lbGVtSW5kaWNlcyA9IExpc3QuZWxlbUluZGljZXM7XG5wcmVsdWRlLmZpbmRJbmRleCA9IExpc3QuZmluZEluZGV4O1xucHJlbHVkZS5maW5kSW5kaWNlcyA9IExpc3QuZmluZEluZGljZXM7XG5wcmVsdWRlLmFwcGx5ID0gRnVuYy5hcHBseTtcbnByZWx1ZGUuY3VycnkgPSBGdW5jLmN1cnJ5O1xucHJlbHVkZS5mbGlwID0gRnVuYy5mbGlwO1xucHJlbHVkZS5maXggPSBGdW5jLmZpeDtcbnByZWx1ZGUub3ZlciA9IEZ1bmMub3ZlcjtcbnByZWx1ZGUuc3BsaXQgPSBTdHIuc3BsaXQ7XG5wcmVsdWRlLmpvaW4gPSBTdHIuam9pbjtcbnByZWx1ZGUubGluZXMgPSBTdHIubGluZXM7XG5wcmVsdWRlLnVubGluZXMgPSBTdHIudW5saW5lcztcbnByZWx1ZGUud29yZHMgPSBTdHIud29yZHM7XG5wcmVsdWRlLnVud29yZHMgPSBTdHIudW53b3JkcztcbnByZWx1ZGUuY2hhcnMgPSBTdHIuY2hhcnM7XG5wcmVsdWRlLnVuY2hhcnMgPSBTdHIudW5jaGFycztcbnByZWx1ZGUucmVwZWF0ID0gU3RyLnJlcGVhdDtcbnByZWx1ZGUuY2FwaXRhbGl6ZSA9IFN0ci5jYXBpdGFsaXplO1xucHJlbHVkZS5jYW1lbGl6ZSA9IFN0ci5jYW1lbGl6ZTtcbnByZWx1ZGUuZGFzaGVyaXplID0gU3RyLmRhc2hlcml6ZTtcbnByZWx1ZGUudmFsdWVzID0gT2JqLnZhbHVlcztcbnByZWx1ZGUua2V5cyA9IE9iai5rZXlzO1xucHJlbHVkZS5wYWlyc1RvT2JqID0gT2JqLnBhaXJzVG9PYmo7XG5wcmVsdWRlLm9ialRvUGFpcnMgPSBPYmoub2JqVG9QYWlycztcbnByZWx1ZGUubGlzdHNUb09iaiA9IE9iai5saXN0c1RvT2JqO1xucHJlbHVkZS5vYmpUb0xpc3RzID0gT2JqLm9ialRvTGlzdHM7XG5wcmVsdWRlLm1heCA9IE51bS5tYXg7XG5wcmVsdWRlLm1pbiA9IE51bS5taW47XG5wcmVsdWRlLm5lZ2F0ZSA9IE51bS5uZWdhdGU7XG5wcmVsdWRlLmFicyA9IE51bS5hYnM7XG5wcmVsdWRlLnNpZ251bSA9IE51bS5zaWdudW07XG5wcmVsdWRlLnF1b3QgPSBOdW0ucXVvdDtcbnByZWx1ZGUucmVtID0gTnVtLnJlbTtcbnByZWx1ZGUuZGl2ID0gTnVtLmRpdjtcbnByZWx1ZGUubW9kID0gTnVtLm1vZDtcbnByZWx1ZGUucmVjaXAgPSBOdW0ucmVjaXA7XG5wcmVsdWRlLnBpID0gTnVtLnBpO1xucHJlbHVkZS50YXUgPSBOdW0udGF1O1xucHJlbHVkZS5leHAgPSBOdW0uZXhwO1xucHJlbHVkZS5zcXJ0ID0gTnVtLnNxcnQ7XG5wcmVsdWRlLmxuID0gTnVtLmxuO1xucHJlbHVkZS5wb3cgPSBOdW0ucG93O1xucHJlbHVkZS5zaW4gPSBOdW0uc2luO1xucHJlbHVkZS50YW4gPSBOdW0udGFuO1xucHJlbHVkZS5jb3MgPSBOdW0uY29zO1xucHJlbHVkZS5hY29zID0gTnVtLmFjb3M7XG5wcmVsdWRlLmFzaW4gPSBOdW0uYXNpbjtcbnByZWx1ZGUuYXRhbiA9IE51bS5hdGFuO1xucHJlbHVkZS5hdGFuMiA9IE51bS5hdGFuMjtcbnByZWx1ZGUudHJ1bmNhdGUgPSBOdW0udHJ1bmNhdGU7XG5wcmVsdWRlLnJvdW5kID0gTnVtLnJvdW5kO1xucHJlbHVkZS5jZWlsaW5nID0gTnVtLmNlaWxpbmc7XG5wcmVsdWRlLmZsb29yID0gTnVtLmZsb29yO1xucHJlbHVkZS5pc0l0TmFOID0gTnVtLmlzSXROYU47XG5wcmVsdWRlLmV2ZW4gPSBOdW0uZXZlbjtcbnByZWx1ZGUub2RkID0gTnVtLm9kZDtcbnByZWx1ZGUuZ2NkID0gTnVtLmdjZDtcbnByZWx1ZGUubGNtID0gTnVtLmxjbTtcbnByZWx1ZGUuVkVSU0lPTiA9ICcxLjEuMSc7XG5tb2R1bGUuZXhwb3J0cyA9IHByZWx1ZGU7XG5mdW5jdGlvbiBjdXJyeSQoZiwgYm91bmQpe1xuICB2YXIgY29udGV4dCxcbiAgX2N1cnJ5ID0gZnVuY3Rpb24oYXJncykge1xuICAgIHJldHVybiBmLmxlbmd0aCA+IDEgPyBmdW5jdGlvbigpe1xuICAgICAgdmFyIHBhcmFtcyA9IGFyZ3MgPyBhcmdzLmNvbmNhdCgpIDogW107XG4gICAgICBjb250ZXh0ID0gYm91bmQgPyBjb250ZXh0IHx8IHRoaXMgOiB0aGlzO1xuICAgICAgcmV0dXJuIHBhcmFtcy5wdXNoLmFwcGx5KHBhcmFtcywgYXJndW1lbnRzKSA8XG4gICAgICAgICAgZi5sZW5ndGggJiYgYXJndW1lbnRzLmxlbmd0aCA/XG4gICAgICAgIF9jdXJyeS5jYWxsKGNvbnRleHQsIHBhcmFtcykgOiBmLmFwcGx5KGNvbnRleHQsIHBhcmFtcyk7XG4gICAgfSA6IGY7XG4gIH07XG4gIHJldHVybiBfY3VycnkoKTtcbn0iLCJ2YXIgc3RkLCBrR3Jhdml0eSwga1Rlcm1pbmFsU3BlZWQsIFplcm9BY2NlbGVyYXRvciwgQ29uc3RhbnRBY2NlbGVyYXRvciwgQmlkaXJlY3Rpb25hbEFjY2VsZXJhdG9yLCBGcmljdGlvbkFjY2VsZXJhdG9yLCBrWmVybywga0dyYXZpdHlBY2MsIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5zdGQgPSByZXF1aXJlKCdzdGQnKTtcbm91dCQua0dyYXZpdHkgPSBrR3Jhdml0eSA9IDAuMDAwNzgxMjU7XG5vdXQkLmtUZXJtaW5hbFNwZWVkID0ga1Rlcm1pbmFsU3BlZWQgPSAwLjI5OTgwNDY4NzU7XG5vdXQkLlplcm9BY2NlbGVyYXRvciA9IFplcm9BY2NlbGVyYXRvciA9IChmdW5jdGlvbigpe1xuICBaZXJvQWNjZWxlcmF0b3IuZGlzcGxheU5hbWUgPSAnWmVyb0FjY2VsZXJhdG9yJztcbiAgdmFyIHByb3RvdHlwZSA9IFplcm9BY2NlbGVyYXRvci5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gWmVyb0FjY2VsZXJhdG9yO1xuICBmdW5jdGlvbiBaZXJvQWNjZWxlcmF0b3IoKXt9XG4gIHByb3RvdHlwZS51cGRhdGVWZWxvY2l0eSA9IGZ1bmN0aW9uKCl7fTtcbiAgcmV0dXJuIFplcm9BY2NlbGVyYXRvcjtcbn0oKSk7XG5vdXQkLkNvbnN0YW50QWNjZWxlcmF0b3IgPSBDb25zdGFudEFjY2VsZXJhdG9yID0gKGZ1bmN0aW9uKCl7XG4gIENvbnN0YW50QWNjZWxlcmF0b3IuZGlzcGxheU5hbWUgPSAnQ29uc3RhbnRBY2NlbGVyYXRvcic7XG4gIHZhciBwcm90b3R5cGUgPSBDb25zdGFudEFjY2VsZXJhdG9yLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBDb25zdGFudEFjY2VsZXJhdG9yO1xuICBmdW5jdGlvbiBDb25zdGFudEFjY2VsZXJhdG9yKGFjYywgbWF4VmVsKXtcbiAgICB0aGlzLmFjYyA9IGFjYztcbiAgICB0aGlzLm1heFZlbCA9IG1heFZlbDtcbiAgICB0aGlzLnVwZGF0ZVZlbG9jaXR5ID0gdGhpcy5hY2MgPCAwXG4gICAgICA/IGZ1bmN0aW9uKGtpbmVtYXRpY3MsIGVsYXBzZWRUaW1lKXtcbiAgICAgICAgcmV0dXJuIGtpbmVtYXRpY3MudmVsb2NpdHkgPSBzdGQubWF4KGtpbmVtYXRpY3MudmVsb2NpdHkgKyB0aGlzLmFjYyAqIGVsYXBzZWRUaW1lLCB0aGlzLm1heFZlbCk7XG4gICAgICB9XG4gICAgICA6IGZ1bmN0aW9uKGtpbmVtYXRpY3MsIGVsYXBzZWRUaW1lKXtcbiAgICAgICAgcmV0dXJuIGtpbmVtYXRpY3MudmVsb2NpdHkgPSBzdGQubWluKGtpbmVtYXRpY3MudmVsb2NpdHkgKyB0aGlzLmFjYyAqIGVsYXBzZWRUaW1lLCB0aGlzLm1heFZlbCk7XG4gICAgICB9O1xuICB9XG4gIHJldHVybiBDb25zdGFudEFjY2VsZXJhdG9yO1xufSgpKTtcbm91dCQuQmlkaXJlY3Rpb25hbEFjY2VsZXJhdG9yID0gQmlkaXJlY3Rpb25hbEFjY2VsZXJhdG9yID0gKGZ1bmN0aW9uKCl7XG4gIEJpZGlyZWN0aW9uYWxBY2NlbGVyYXRvci5kaXNwbGF5TmFtZSA9ICdCaWRpcmVjdGlvbmFsQWNjZWxlcmF0b3InO1xuICB2YXIgcHJvdG90eXBlID0gQmlkaXJlY3Rpb25hbEFjY2VsZXJhdG9yLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBCaWRpcmVjdGlvbmFsQWNjZWxlcmF0b3I7XG4gIGZ1bmN0aW9uIEJpZGlyZWN0aW9uYWxBY2NlbGVyYXRvcihhY2MsIG1heFZlbCl7XG4gICAgdGhpcy5hY2MgPSBhY2M7XG4gICAgdGhpcy5tYXhWZWwgPSBtYXhWZWw7XG4gICAgdGhpcy5wb3NpdGl2ZSA9IG5ldyBDb25zdGFudEFjY2VsZXJhdG9yKHRoaXMuYWNjLCB0aGlzLm1heFZlbCk7XG4gICAgdGhpcy5uZWdhdGl2ZSA9IG5ldyBDb25zdGFudEFjY2VsZXJhdG9yKC10aGlzLmFjYywgLXRoaXMubWF4VmVsKTtcbiAgfVxuICByZXR1cm4gQmlkaXJlY3Rpb25hbEFjY2VsZXJhdG9yO1xufSgpKTtcbm91dCQuRnJpY3Rpb25BY2NlbGVyYXRvciA9IEZyaWN0aW9uQWNjZWxlcmF0b3IgPSAoZnVuY3Rpb24oKXtcbiAgRnJpY3Rpb25BY2NlbGVyYXRvci5kaXNwbGF5TmFtZSA9ICdGcmljdGlvbkFjY2VsZXJhdG9yJztcbiAgdmFyIHByb3RvdHlwZSA9IEZyaWN0aW9uQWNjZWxlcmF0b3IucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IEZyaWN0aW9uQWNjZWxlcmF0b3I7XG4gIGZ1bmN0aW9uIEZyaWN0aW9uQWNjZWxlcmF0b3IoZnJpY3Rpb24pe1xuICAgIHRoaXMuZnJpY3Rpb24gPSBmcmljdGlvbjtcbiAgfVxuICBwcm90b3R5cGUudXBkYXRlVmVsb2NpdHkgPSBmdW5jdGlvbihraW5lbWF0aWNzLCBlbGFwc2VkVGltZSl7XG4gICAgcmV0dXJuIGtpbmVtYXRpY3MudmVsb2NpdHkgPSBraW5lbWF0aWNzLnZlbG9jaXR5ID4gMFxuICAgICAgPyBzdGQubWF4KDAsIGtpbmVtYXRpY3MudmVsb2NpdHkgLSB0aGlzLmZyaWN0aW9uICogZWxhcHNlZFRpbWUpXG4gICAgICA6IHN0ZC5taW4oMCwga2luZW1hdGljcy52ZWxvY2l0eSArIHRoaXMuZnJpY3Rpb24gKiBlbGFwc2VkVGltZSk7XG4gIH07XG4gIHJldHVybiBGcmljdGlvbkFjY2VsZXJhdG9yO1xufSgpKTtcbm91dCQua1plcm8gPSBrWmVybyA9IG5ldyBaZXJvQWNjZWxlcmF0b3I7XG5vdXQkLmtHcmF2aXR5QWNjID0ga0dyYXZpdHlBY2MgPSBuZXcgQ29uc3RhbnRBY2NlbGVyYXRvcihrR3Jhdml0eSwga1Rlcm1pbmFsU3BlZWQpOyIsInZhciBzdGQsIHVuaXRzLCBrSGFsZlRpbGUsIHRweCwgdGlsZVRvR2FtZSwgZ2FtZVRvUHgsIFdBTExfVElMRSwgU3ByaXRlLCByZWYkLCBTcHJpdGVTdGF0ZSwgU3RhdGUsIFByb2plY3RpbGUsIFN0YXJQYXJ0aWNsZSwgV2FsbFBhcnRpY2xlLCBSZWN0LCBrQXJtc1Nwcml0ZVBhdGgsIGtTcHJpdGVXaWR0aCwga1Nwcml0ZUhlaWdodCwga1VwT2Zmc2V0LCBrRG93bk9mZnNldCwga0hvcml6b250YWxPZmZzZXQsIGtSaWdodE9mZnNldCwga0xlZnRPZmZzZXQsIFVQLCBET1dOLCBMRUZULCBSSUdIVCwgUG9sYXJTdGFyUHJvamVjdGlsZSwgUG9sYXJTdGFyLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG51bml0cyA9IHJlcXVpcmUoJy4vdW5pdHMnKTtcbmtIYWxmVGlsZSA9IHVuaXRzLmtIYWxmVGlsZSwgdHB4ID0gdW5pdHMudGlsZVRvUHgsIHRpbGVUb0dhbWUgPSB1bml0cy50aWxlVG9HYW1lLCBnYW1lVG9QeCA9IHVuaXRzLmdhbWVUb1B4O1xuV0FMTF9USUxFID0gcmVxdWlyZSgnLi9tYXAnKS5XQUxMX1RJTEU7XG5TcHJpdGUgPSByZXF1aXJlKCcuL3Nwcml0ZScpLlNwcml0ZTtcbnJlZiQgPSByZXF1aXJlKCcuL3Nwcml0ZXN0YXRlJyksIFNwcml0ZVN0YXRlID0gcmVmJC5TcHJpdGVTdGF0ZSwgU3RhdGUgPSByZWYkLlN0YXRlO1xuUHJvamVjdGlsZSA9IHJlcXVpcmUoJy4vcHJvamVjdGlsZScpLlByb2plY3RpbGU7XG5TdGFyUGFydGljbGUgPSByZXF1aXJlKCcuL3N0YXItcGFydGljbGUnKS5TdGFyUGFydGljbGU7XG5XYWxsUGFydGljbGUgPSByZXF1aXJlKCcuL3dhbGwtcGFydGljbGUnKS5XYWxsUGFydGljbGU7XG5SZWN0ID0gcmVxdWlyZSgnLi9yZWN0YW5nbGUnKS5SZWN0YW5nbGU7XG5rQXJtc1Nwcml0ZVBhdGggPSAnQXJtcyc7XG5rU3ByaXRlV2lkdGggPSAxLjU7XG5rU3ByaXRlSGVpZ2h0ID0gMS4wO1xua1VwT2Zmc2V0ID0gMjtcbmtEb3duT2Zmc2V0ID0gNDtcbmtIb3Jpem9udGFsT2Zmc2V0ID0gMDtcbmtSaWdodE9mZnNldCA9IDE7XG5rTGVmdE9mZnNldCA9IDA7XG5yZWYkID0gc3RkWydlbnVtJ10sIFVQID0gcmVmJFswXSwgRE9XTiA9IHJlZiRbMV0sIExFRlQgPSByZWYkWzJdLCBSSUdIVCA9IHJlZiRbM107XG5Qb2xhclN0YXJQcm9qZWN0aWxlID0gKGZ1bmN0aW9uKHN1cGVyY2xhc3Mpe1xuICB2YXIga0xpZmVzcGFucywga1NwZWVkcywga0NvbGxpc2lvbldpZHRocywga0NvbGxpc2lvbkhlaWdodHMsIGtEYW1hZ2VzLCBwcm90b3R5cGUgPSBleHRlbmQkKChpbXBvcnQkKFBvbGFyU3RhclByb2plY3RpbGUsIHN1cGVyY2xhc3MpLmRpc3BsYXlOYW1lID0gJ1BvbGFyU3RhclByb2plY3RpbGUnLCBQb2xhclN0YXJQcm9qZWN0aWxlKSwgc3VwZXJjbGFzcykucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IFBvbGFyU3RhclByb2plY3RpbGU7XG4gIGtMaWZlc3BhbnMgPSBbdGlsZVRvR2FtZSgzLjUpLCB0aWxlVG9HYW1lKDUpLCB0aWxlVG9HYW1lKDcpXTtcbiAga1NwZWVkcyA9IFswLjYsIDAuNiwgMC42XTtcbiAga0NvbGxpc2lvbldpZHRocyA9IFszMiwgMzIsIDMyXTtcbiAga0NvbGxpc2lvbkhlaWdodHMgPSBbNCwgOCwgMTZdO1xuICBrRGFtYWdlcyA9IFsxLCAyLCA0XTtcbiAgZnVuY3Rpb24gUG9sYXJTdGFyUHJvamVjdGlsZShzcHJpdGUsIHN0YXRlLCB4LCB5LCBndW5MZXZlbCl7XG4gICAgdGhpcy5zcHJpdGUgPSBzcHJpdGU7XG4gICAgdGhpcy5ndW5MZXZlbCA9IGd1bkxldmVsO1xuICAgIFBvbGFyU3RhclByb2plY3RpbGUuc3VwZXJjbGFzcy5jYWxsKHRoaXMsIGtEYW1hZ2VzW3RoaXMuZ3VuTGV2ZWwgLSAxXSk7XG4gICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgIHRoaXMubGlmZXNwYW4gPSBrTGlmZXNwYW5zW3RoaXMuZ3VuTGV2ZWwgLSAxXTtcbiAgICB0aGlzLmFsaXZlID0gdHJ1ZTtcbiAgICBzdGQubG9nKCdTRlg6IFBldyEnKTtcbiAgICBpZiAoc3RhdGUuSE9SSVpPTlRBTCkge1xuICAgICAgdGhpcy53aWR0aCA9IGtDb2xsaXNpb25XaWR0aHNbdGhpcy5ndW5MZXZlbCAtIDFdO1xuICAgICAgdGhpcy5oZWlnaHQgPSBrQ29sbGlzaW9uSGVpZ2h0c1t0aGlzLmd1bkxldmVsIC0gMV07XG4gICAgICB0aGlzLnZlcnRpY2FsID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2lkdGggPSBrQ29sbGlzaW9uSGVpZ2h0c1t0aGlzLmd1bkxldmVsIC0gMV07XG4gICAgICB0aGlzLmhlaWdodCA9IGtDb2xsaXNpb25XaWR0aHNbdGhpcy5ndW5MZXZlbCAtIDFdO1xuICAgICAgdGhpcy52ZXJ0aWNhbCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMubW9kZSA9IChmdW5jdGlvbigpe1xuICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICBjYXNlIHN0YXRlLlVQOlxuICAgICAgICByZXR1cm4gVVA7XG4gICAgICBjYXNlIHN0YXRlLkRPV046XG4gICAgICAgIHJldHVybiBET1dOO1xuICAgICAgY2FzZSBzdGF0ZS5MRUZUOlxuICAgICAgICByZXR1cm4gTEVGVDtcbiAgICAgIGNhc2Ugc3RhdGUuUklHSFQ6XG4gICAgICAgIHJldHVybiBSSUdIVDtcbiAgICAgIH1cbiAgICB9KCkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIHg6IHtcbiAgICAgICAgZ2V0OiAhc3RhdGUuSE9SSVpPTlRBTFxuICAgICAgICAgID8gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICAgIH1cbiAgICAgICAgICA6IHN0YXRlLkxFRlRcbiAgICAgICAgICAgID8gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgcmV0dXJuIHggLSB0aGlzLm9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogc3RhdGUuUklHSFQgPyBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICByZXR1cm4geCArIHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgfSA6IHZvaWQgOFxuICAgICAgfSxcbiAgICAgIHk6IHtcbiAgICAgICAgZ2V0OiBzdGF0ZS5IT1JJWk9OVEFMXG4gICAgICAgICAgPyBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIDogc3RhdGUuVVBcbiAgICAgICAgICAgID8gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgcmV0dXJuIHkgLSB0aGlzLm9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogc3RhdGUuRE9XTiA/IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIHJldHVybiB5ICsgdGhpcy5vZmZzZXQ7XG4gICAgICAgICAgICB9IDogdm9pZCA4XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcHJvdG90eXBlLmNvbGxpc2lvblJlY3RhbmdsZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIG5ldyBSZWN0KHRoaXMueCArIGtIYWxmVGlsZSAtIHRoaXMud2lkdGggLyAyLCB0aGlzLnkgKyBrSGFsZlRpbGUgLSB0aGlzLmhlaWdodCAvIDIsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgfTtcbiAgcHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGVsYXBzZWRUaW1lLCBtYXAsIHB0b29scyl7XG4gICAgdmFyIGkkLCByZWYkLCBsZW4kLCB0aWxlLCB0aWxlUmVjdCwgcGFydGljbGVYLCBwYXJ0aWNsZVk7XG4gICAgdGhpcy5vZmZzZXQgKz0ga1NwZWVkc1t0aGlzLmd1bkxldmVsIC0gMV0gKiBlbGFwc2VkVGltZTtcbiAgICBmb3IgKGkkID0gMCwgbGVuJCA9IChyZWYkID0gbWFwLmdldENvbGxpZGluZ1RpbGVzKHRoaXMuY29sbGlzaW9uUmVjdGFuZ2xlKCkpKS5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgICAgdGlsZSA9IHJlZiRbaSRdO1xuICAgICAgaWYgKHRpbGUudHlwZSA9PT0gV0FMTF9USUxFKSB7XG4gICAgICAgIHRpbGVSZWN0ID0gbmV3IFJlY3QodGlsZVRvR2FtZSh0aWxlLmNvbCksIHRpbGVUb0dhbWUodGlsZS5yb3cpLCB0aWxlVG9HYW1lKDEpLCB0aWxlVG9HYW1lKDEpKTtcbiAgICAgICAgcGFydGljbGVYID0gdGhpcy54O1xuICAgICAgICBwYXJ0aWNsZVkgPSB0aGlzLnk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgICAgIGNhc2UgVVA6XG4gICAgICAgICAgcGFydGljbGVZID0gdGlsZVJlY3QuYm90dG9tIC0ga0hhbGZUaWxlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIERPV046XG4gICAgICAgICAgcGFydGljbGVZID0gdGlsZVJlY3QudG9wIC0ga0hhbGZUaWxlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIExFRlQ6XG4gICAgICAgICAgcGFydGljbGVYID0gdGlsZVJlY3QucmlnaHQgLSBrSGFsZlRpbGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUklHSFQ6XG4gICAgICAgICAgcGFydGljbGVYID0gdGlsZVJlY3QubGVmdCAtIGtIYWxmVGlsZTtcbiAgICAgICAgfVxuICAgICAgICBwdG9vbHMuZnJvbnRTeXN0ZW0uYWRkTmV3UGFydGljbGUobmV3IFdhbGxQYXJ0aWNsZShwdG9vbHMuZ3JhcGhpY3MsIHBhcnRpY2xlWCwgcGFydGljbGVZKSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLmFsaXZlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9mZnNldCA+PSB0aGlzLmxpZmVzcGFuKSB7XG4gICAgICBwdG9vbHMuZnJvbnRTeXN0ZW0uYWRkTmV3UGFydGljbGUobmV3IFN0YXJQYXJ0aWNsZShwdG9vbHMuZ3JhcGhpY3MsIHRoaXMueCwgdGhpcy55KSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcbiAgcHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihncmFwaGljcyl7XG4gICAgdGhpcy5zcHJpdGUuZHJhdyhncmFwaGljcywgdGhpcy54LCB0aGlzLnkpO1xuICAgIHJldHVybiBncmFwaGljcy52aXN1YWxpc2VSZWN0KHRoaXMuY29sbGlzaW9uUmVjdGFuZ2xlKCkpO1xuICB9O1xuICBwcm90b3R5cGUuY29sbGlkZVdpdGhFbmVteSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuYWxpdmUgPSBmYWxzZTtcbiAgfTtcbiAgcmV0dXJuIFBvbGFyU3RhclByb2plY3RpbGU7XG59KFByb2plY3RpbGUpKTtcbm91dCQuUG9sYXJTdGFyID0gUG9sYXJTdGFyID0gKGZ1bmN0aW9uKCl7XG4gIFBvbGFyU3Rhci5kaXNwbGF5TmFtZSA9ICdQb2xhclN0YXInO1xuICB2YXIga0V4cGVyaWVuY2VzLCBrUG9sYXJTdGFySW5kZXgsIGtQcm9qZWN0aWxlU3JjWXMsIGtQcm9qZWN0aWxlU3JjWHMsIGtOb3p6bGVIb3JpelksIGtOb3p6bGVIb3JpekxlZnRYLCBrTm96emxlSG9yaXpSaWdodFgsIGtOb3p6bGVVcFksIGtOb3p6bGVVcExlZnRYLCBrTm96emxlVXBSaWdodFgsIGtOb3p6bGVEb3duWSwga05venpsZURvd25MZWZ0WCwga05venpsZURvd25SaWdodFgsIHByb3RvdHlwZSA9IFBvbGFyU3Rhci5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gUG9sYXJTdGFyO1xuICBrRXhwZXJpZW5jZXMgPSBbMCwgMTAsIDMwLCA0MF07XG4gIGtQb2xhclN0YXJJbmRleCA9IDI7XG4gIGtQcm9qZWN0aWxlU3JjWXMgPSBbMiwgMiwgM107XG4gIGtQcm9qZWN0aWxlU3JjWHMgPSBbOCwgMTAsIDhdO1xuICBrTm96emxlSG9yaXpZID0gMjM7XG4gIGtOb3p6bGVIb3JpekxlZnRYID0gMTA7XG4gIGtOb3p6bGVIb3JpelJpZ2h0WCA9IDM4O1xuICBrTm96emxlVXBZID0gNDtcbiAga05venpsZVVwTGVmdFggPSAyNztcbiAga05venpsZVVwUmlnaHRYID0gMjE7XG4gIGtOb3p6bGVEb3duWSA9IDI4O1xuICBrTm96emxlRG93bkxlZnRYID0gMjk7XG4gIGtOb3p6bGVEb3duUmlnaHRYID0gMTk7XG4gIGZ1bmN0aW9uIFBvbGFyU3RhcihncmFwaGljcyl7XG4gICAgdmFyIHJlcyQsIGkkLCB0byQsIGx2bDtcbiAgICB0aGlzLnByb2plY3RpbGVBID0gbnVsbDtcbiAgICB0aGlzLnByb2plY3RpbGVCID0gbnVsbDtcbiAgICB0aGlzLnNwcml0ZXMgPSB0aGlzLmluaXRpYWxpc2VTcHJpdGVzKGdyYXBoaWNzKTtcbiAgICB0aGlzLmN1cnJlbnRFeHBlcmllbmNlID0gMDtcbiAgICByZXMkID0gW107XG4gICAgZm9yIChpJCA9IDAsIHRvJCA9IHVuaXRzLmtNYXhHdW5MZXZlbDsgaSQgPD0gdG8kOyArK2kkKSB7XG4gICAgICBsdmwgPSBpJDtcbiAgICAgIHJlcyQucHVzaChuZXcgU3ByaXRlKGdyYXBoaWNzLCAnYnVsbGV0JywgdHB4KGtQcm9qZWN0aWxlU3JjWHNbbHZsXSksIHRweChrUHJvamVjdGlsZVNyY1lzW2x2bF0pLCB0cHgoMSksIHRweCgxKSkpO1xuICAgIH1cbiAgICB0aGlzLmhwU3ByaXRlcyA9IHJlcyQ7XG4gICAgcmVzJCA9IFtdO1xuICAgIGZvciAoaSQgPSAwLCB0byQgPSB1bml0cy5rTWF4R3VuTGV2ZWw7IGkkIDw9IHRvJDsgKytpJCkge1xuICAgICAgbHZsID0gaSQ7XG4gICAgICByZXMkLnB1c2gobmV3IFNwcml0ZShncmFwaGljcywgJ2J1bGxldCcsIHRweChrUHJvamVjdGlsZVNyY1hzW2x2bF0gKyAxKSwgdHB4KGtQcm9qZWN0aWxlU3JjWXNbbHZsXSksIHRweCgxKSwgdHB4KDEpKSk7XG4gICAgfVxuICAgIHRoaXMudnBTcHJpdGVzID0gcmVzJDtcbiAgfVxuICBwcm90b3R5cGUuY29sbGVjdEV4cGVyaWVuY2UgPSBmdW5jdGlvbihleHBlcmllbmNlKXtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50RXhwZXJpZW5jZSA9IHN0ZC5taW4oa0V4cGVyaWVuY2VzW3VuaXRzLmtNYXhHdW5MZXZlbF0sIHRoaXMuY3VycmVudEV4cGVyaWVuY2UgKyBleHBlcmllbmNlKTtcbiAgfTtcbiAgcHJvdG90eXBlLmN1cnJlbnRMZXZlbCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGkkLCByZWYkLCBsZXZlbCwgZXhwO1xuICAgIGZvciAoaSQgPSAocmVmJCA9IGtFeHBlcmllbmNlcykubGVuZ3RoIC0gMTsgaSQgPj0gMDsgLS1pJCkge1xuICAgICAgbGV2ZWwgPSBpJDtcbiAgICAgIGV4cCA9IHJlZiRbaSRdO1xuICAgICAgaWYgKHRoaXMuY3VycmVudEV4cGVyaWVuY2UgPj0ga0V4cGVyaWVuY2VzW2xldmVsIC0gMV0pIHtcbiAgICAgICAgcmV0dXJuIGxldmVsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMTtcbiAgfTtcbiAgcHJvdG90eXBlLmluaXRpYWxpc2VTcHJpdGVzID0gZnVuY3Rpb24oZ3JhcGhpY3Mpe1xuICAgIHJldHVybiBTcHJpdGVTdGF0ZS5nZW5lcmF0ZVdpdGgoZnVuY3Rpb24oc3RhdGUpe1xuICAgICAgdmFyIHRpbGVZO1xuICAgICAgdGlsZVkgPSBzdGF0ZS5MRUZUID8ga0xlZnRPZmZzZXQgOiBrUmlnaHRPZmZzZXQ7XG4gICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgIGNhc2Ugc3RhdGUuSE9SSVpPTlRBTDpcbiAgICAgICAgdGlsZVkgKz0ga0hvcml6b250YWxPZmZzZXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBzdGF0ZS5VUDpcbiAgICAgICAgdGlsZVkgKz0ga1VwT2Zmc2V0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugc3RhdGUuRE9XTjpcbiAgICAgICAgdGlsZVkgKz0ga0Rvd25PZmZzZXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFNwcml0ZShncmFwaGljcywga0FybXNTcHJpdGVQYXRoLCB0cHgoa1BvbGFyU3RhckluZGV4ICoga1Nwcml0ZVdpZHRoKSwgdHB4KHRpbGVZKSwgdHB4KGtTcHJpdGVXaWR0aCksIHRweChrU3ByaXRlSGVpZ2h0KSk7XG4gICAgfSk7XG4gIH07XG4gIHByb3RvdHlwZS5zdGFydEZpcmUgPSBmdW5jdGlvbihzdGF0ZSwgcGxheWVyWCwgcGxheWVyWSl7XG4gICAgdmFyIGJ1bGxldFgsIGJ1bGxldFksIHNwcml0ZTtcbiAgICBpZiAodGhpcy5wcm9qZWN0aWxlQSAmJiB0aGlzLnByb2plY3RpbGVCKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGJ1bGxldFggPSB0aGlzLmd1blgoc3RhdGUsIHBsYXllclgpIC0ga0hhbGZUaWxlO1xuICAgIGJ1bGxldFkgPSB0aGlzLmd1blkoc3RhdGUsIHBsYXllclkpIC0ga0hhbGZUaWxlO1xuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgIGNhc2Ugc3RhdGUuSE9SSVpPTlRBTDpcbiAgICAgIGJ1bGxldFkgKz0ga05venpsZUhvcml6WTtcbiAgICAgIGJ1bGxldFggKz0gc3RhdGUuTEVGVCA/IGtOb3p6bGVIb3JpekxlZnRYIDoga05venpsZUhvcml6UmlnaHRYO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBzdGF0ZS5VUDpcbiAgICAgIGJ1bGxldFkgKz0ga05venpsZVVwWTtcbiAgICAgIGJ1bGxldFggKz0gc3RhdGUuTEVGVCA/IGtOb3p6bGVVcExlZnRYIDoga05venpsZVVwUmlnaHRYO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBzdGF0ZS5ET1dOOlxuICAgICAgYnVsbGV0WSArPSBrTm96emxlRG93blk7XG4gICAgICBidWxsZXRYICs9IHN0YXRlLkxFRlQgPyBrTm96emxlRG93bkxlZnRYIDoga05venpsZURvd25SaWdodFg7XG4gICAgfVxuICAgIHNwcml0ZSA9IHN0YXRlLkhPUklaT05UQUxcbiAgICAgID8gdGhpcy5ocFNwcml0ZXNbdGhpcy5jdXJyZW50TGV2ZWwoKSAtIDFdXG4gICAgICA6IHRoaXMudnBTcHJpdGVzW3RoaXMuY3VycmVudExldmVsKCkgLSAxXTtcbiAgICBpZiAoIXRoaXMucHJvamVjdGlsZUEpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb2plY3RpbGVBID0gbmV3IFBvbGFyU3RhclByb2plY3RpbGUoc3ByaXRlLCBzdGF0ZSwgYnVsbGV0WCwgYnVsbGV0WSwgdGhpcy5jdXJyZW50TGV2ZWwoKSk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5wcm9qZWN0aWxlQikge1xuICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlsZUIgPSBuZXcgUG9sYXJTdGFyUHJvamVjdGlsZShzcHJpdGUsIHN0YXRlLCBidWxsZXRYLCBidWxsZXRZLCB0aGlzLmN1cnJlbnRMZXZlbCgpKTtcbiAgICB9XG4gIH07XG4gIHByb3RvdHlwZS5zdG9wRmlyZSA9IGZ1bmN0aW9uKCl7fTtcbiAgcHJvdG90eXBlLmd1blggPSBmdW5jdGlvbihzdGF0ZSwgcGxheWVyWCl7XG4gICAgaWYgKHN0YXRlLkxFRlQpIHtcbiAgICAgIHJldHVybiBwbGF5ZXJYIC0ga0hhbGZUaWxlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGxheWVyWDtcbiAgICB9XG4gIH07XG4gIHByb3RvdHlwZS5ndW5ZID0gZnVuY3Rpb24oc3RhdGUsIHBsYXllclkpe1xuICAgIGlmIChzdGF0ZS5VUCkge1xuICAgICAgcGxheWVyWSAtPSBrSGFsZlRpbGUgLyAyO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuRE9XTikge1xuICAgICAgcGxheWVyWSArPSBrSGFsZlRpbGUgLyAyO1xuICAgIH1cbiAgICByZXR1cm4gcGxheWVyWSArIHRoaXMuZ3VuQm9iKHN0YXRlKTtcbiAgfTtcbiAgcHJvdG90eXBlLmd1bkJvYiA9IGZ1bmN0aW9uKHN0YXRlKXtcbiAgICBpZiAoc3RhdGUuV0FMS0lORyAmJiAoc3RhdGUuU1RSSURFX0xFRlQgfHwgc3RhdGUuU1RSSURFX1JJR0hUKSkge1xuICAgICAgcmV0dXJuIC0yO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH07XG4gIHByb3RvdHlwZS5nZXRQcm9qZWN0aWxlcyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHByb2plY3RpbGVzLCB0aGF0O1xuICAgIHByb2plY3RpbGVzID0gW107XG4gICAgaWYgKHRoYXQgPSB0aGlzLnByb2plY3RpbGVBKSB7XG4gICAgICBwcm9qZWN0aWxlcy5wdXNoKHRoYXQpO1xuICAgIH1cbiAgICBpZiAodGhhdCA9IHRoaXMucHJvamVjdGlsZUIpIHtcbiAgICAgIHByb2plY3RpbGVzLnB1c2godGhhdCk7XG4gICAgfVxuICAgIHJldHVybiBwcm9qZWN0aWxlcztcbiAgfTtcbiAgcHJvdG90eXBlLnVwZGF0ZVByb2plY3RpbGVzID0gZnVuY3Rpb24oZWxhcHNlZFRpbWUsIG1hcCwgcHRvb2xzKXtcbiAgICB2YXIgcmVmJDtcbiAgICBpZiAoISgocmVmJCA9IHRoaXMucHJvamVjdGlsZUEpICE9IG51bGwgJiYgcmVmJC51cGRhdGUoZWxhcHNlZFRpbWUsIG1hcCwgcHRvb2xzKSkpIHtcbiAgICAgIHRoaXMucHJvamVjdGlsZUEgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoISgocmVmJCA9IHRoaXMucHJvamVjdGlsZUIpICE9IG51bGwgJiYgcmVmJC51cGRhdGUoZWxhcHNlZFRpbWUsIG1hcCwgcHRvb2xzKSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb2plY3RpbGVCID0gbnVsbDtcbiAgICB9XG4gIH07XG4gIHByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZ3JhcGhpY3MsIHBsYXllclgsIHBsYXllclksIHN0YXRlKXtcbiAgICB2YXIgZ3VuWCwgZ3VuWSwgcmVmJDtcbiAgICBndW5YID0gdGhpcy5ndW5YKHN0YXRlLCBwbGF5ZXJYKTtcbiAgICBndW5ZID0gdGhpcy5ndW5ZKHN0YXRlLCBwbGF5ZXJZKTtcbiAgICB0aGlzLnNwcml0ZXNbc3RhdGUua2V5XS5kcmF3KGdyYXBoaWNzLCBndW5YLCBndW5ZKTtcbiAgICBpZiAoKHJlZiQgPSB0aGlzLnByb2plY3RpbGVBKSAhPSBudWxsKSB7XG4gICAgICByZWYkLmRyYXcoZ3JhcGhpY3MpO1xuICAgIH1cbiAgICByZXR1cm4gKHJlZiQgPSB0aGlzLnByb2plY3RpbGVCKSAhPSBudWxsID8gcmVmJC5kcmF3KGdyYXBoaWNzKSA6IHZvaWQgODtcbiAgfTtcbiAgcHJvdG90eXBlLmRyYXdIdWQgPSBmdW5jdGlvbihncmFwaGljcywgaHVkKXtcbiAgICB2YXIgbGV2ZWw7XG4gICAgbGV2ZWwgPSB0aGlzLmN1cnJlbnRMZXZlbCgpO1xuICAgIHJldHVybiBodWQuZHJhdyhncmFwaGljcywgbGV2ZWwsIHRoaXMuY3VycmVudEV4cGVyaWVuY2UgLSBrRXhwZXJpZW5jZXNbbGV2ZWwgLSAxXSwga0V4cGVyaWVuY2VzW2xldmVsXSAtIGtFeHBlcmllbmNlc1tsZXZlbCAtIDFdKTtcbiAgfTtcbiAgcmV0dXJuIFBvbGFyU3Rhcjtcbn0oKSk7XG5mdW5jdGlvbiBleHRlbmQkKHN1Yiwgc3VwKXtcbiAgZnVuY3Rpb24gZnVuKCl7fSBmdW4ucHJvdG90eXBlID0gKHN1Yi5zdXBlcmNsYXNzID0gc3VwKS5wcm90b3R5cGU7XG4gIChzdWIucHJvdG90eXBlID0gbmV3IGZ1bikuY29uc3RydWN0b3IgPSBzdWI7XG4gIGlmICh0eXBlb2Ygc3VwLmV4dGVuZGVkID09ICdmdW5jdGlvbicpIHN1cC5leHRlbmRlZChzdWIpO1xuICByZXR1cm4gc3ViO1xufVxuZnVuY3Rpb24gaW1wb3J0JChvYmosIHNyYyl7XG4gIHZhciBvd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbiAgZm9yICh2YXIga2V5IGluIHNyYykgaWYgKG93bi5jYWxsKHNyYywga2V5KSkgb2JqW2tleV0gPSBzcmNba2V5XTtcbiAgcmV0dXJuIG9iajtcbn0iLCJ2YXIgc3RkLCBTREwsIHVuaXRzLCBjb25maWcsIGtTY3JlZW5XaWR0aCwga1NjcmVlbkhlaWdodCwga0JhY2tncm91bmRTaXplLCBGaXhlZEJhY2tkcm9wLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG5TREwgPSByZXF1aXJlKCdTREwnKTtcbnVuaXRzID0gcmVxdWlyZSgnLi91bml0cycpO1xuY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcbmtTY3JlZW5XaWR0aCA9IGNvbmZpZy5rU2NyZWVuV2lkdGgsIGtTY3JlZW5IZWlnaHQgPSBjb25maWcua1NjcmVlbkhlaWdodDtcbmtCYWNrZ3JvdW5kU2l6ZSA9IDQ7XG5vdXQkLkZpeGVkQmFja2Ryb3AgPSBGaXhlZEJhY2tkcm9wID0gKGZ1bmN0aW9uKCl7XG4gIEZpeGVkQmFja2Ryb3AuZGlzcGxheU5hbWUgPSAnRml4ZWRCYWNrZHJvcCc7XG4gIHZhciBwcm90b3R5cGUgPSBGaXhlZEJhY2tkcm9wLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBGaXhlZEJhY2tkcm9wO1xuICBmdW5jdGlvbiBGaXhlZEJhY2tkcm9wKHBhdGgsIGdyYXBoaWNzKXtcbiAgICB0aGlzLnN1cmZhY2UgPSBncmFwaGljcy5sb2FkSW1hZ2UocGF0aCk7XG4gIH1cbiAgcHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihncmFwaGljcyl7XG4gICAgdmFyIGkkLCBzdGVwJCwgdG8kLCB4LCBscmVzdWx0JCwgaiQsIHN0ZXAxJCwgdG8xJCwgeSwgZGVzdFJlY3QsIHJlc3VsdHMkID0gW107XG4gICAgZm9yIChpJCA9IDAsIHRvJCA9IHVuaXRzLnRpbGVUb1B4KGtTY3JlZW5XaWR0aCArIGtCYWNrZ3JvdW5kU2l6ZSksIHN0ZXAkID0gdW5pdHMudGlsZVRvUHgoa0JhY2tncm91bmRTaXplKTsgc3RlcCQgPCAwID8gaSQgPj0gdG8kIDogaSQgPD0gdG8kOyBpJCArPSBzdGVwJCkge1xuICAgICAgeCA9IGkkO1xuICAgICAgbHJlc3VsdCQgPSBbXTtcbiAgICAgIGZvciAoaiQgPSAwLCB0bzEkID0gdW5pdHMudGlsZVRvUHgoa1NjcmVlbkhlaWdodCArIGtCYWNrZ3JvdW5kU2l6ZSksIHN0ZXAxJCA9IHVuaXRzLnRpbGVUb1B4KGtCYWNrZ3JvdW5kU2l6ZSk7IHN0ZXAxJCA8IDAgPyBqJCA+PSB0bzEkIDogaiQgPD0gdG8xJDsgaiQgKz0gc3RlcDEkKSB7XG4gICAgICAgIHkgPSBqJDtcbiAgICAgICAgZGVzdFJlY3QgPSBuZXcgU0RMLlJlY3QoeCwgeSwgdW5pdHMudGlsZVRvUHgoa0JhY2tncm91bmRTaXplKSwgdW5pdHMudGlsZVRvUHgoa0JhY2tncm91bmRTaXplKSk7XG4gICAgICAgIGxyZXN1bHQkLnB1c2goZ3JhcGhpY3MuYmxpdFN1cmZhY2UodGhpcy5zdXJmYWNlLCBudWxsLCBkZXN0UmVjdCkpO1xuICAgICAgfVxuICAgICAgcmVzdWx0cyQucHVzaChscmVzdWx0JCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzJDtcbiAgfTtcbiAgcmV0dXJuIEZpeGVkQmFja2Ryb3A7XG59KCkpOyIsInZhciBzdGQsIHVuaXRzLCBSZWN0LCBDb2xsaXNpb25SZWN0YW5nbGUsIFNpbXBsZUNvbGxpc2lvblJlY3RhbmdsZSwgQ29tcG9zaXRlQ29sbGlzaW9uUmVjdGFuZ2xlLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG51bml0cyA9IHJlcXVpcmUoJy4vdW5pdHMnKTtcblJlY3QgPSByZXF1aXJlKCcuL3JlY3RhbmdsZScpLlJlY3RhbmdsZTtcbkNvbGxpc2lvblJlY3RhbmdsZSA9IChmdW5jdGlvbigpe1xuICBDb2xsaXNpb25SZWN0YW5nbGUuZGlzcGxheU5hbWUgPSAnQ29sbGlzaW9uUmVjdGFuZ2xlJztcbiAgdmFyIHByb3RvdHlwZSA9IENvbGxpc2lvblJlY3RhbmdsZS5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gQ29sbGlzaW9uUmVjdGFuZ2xlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCAnYm91bmRpbmdCb3gnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpe30sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG4gIHByb3RvdHlwZS50b3BDb2xsaXNpb24gPSBmdW5jdGlvbih4LCB5LCDOlCl7fTtcbiAgcHJvdG90eXBlLmxlZnRDb2xsaXNpb24gPSBmdW5jdGlvbih4LCB5LCDOlCl7fTtcbiAgcHJvdG90eXBlLnJpZ2h0Q29sbGlzaW9uID0gZnVuY3Rpb24oeCwgeSwgzpQpe307XG4gIHByb3RvdHlwZS5ib3R0b21Db2xsaXNpb24gPSBmdW5jdGlvbih4LCB5LCDOlCl7fTtcbiAgZnVuY3Rpb24gQ29sbGlzaW9uUmVjdGFuZ2xlKCl7fVxuICByZXR1cm4gQ29sbGlzaW9uUmVjdGFuZ2xlO1xufSgpKTtcbm91dCQuU2ltcGxlQ29sbGlzaW9uUmVjdGFuZ2xlID0gU2ltcGxlQ29sbGlzaW9uUmVjdGFuZ2xlID0gKGZ1bmN0aW9uKHN1cGVyY2xhc3Mpe1xuICB2YXIga0V4dHJhT2Zmc2V0LCBwcm90b3R5cGUgPSBleHRlbmQkKChpbXBvcnQkKFNpbXBsZUNvbGxpc2lvblJlY3RhbmdsZSwgc3VwZXJjbGFzcykuZGlzcGxheU5hbWUgPSAnU2ltcGxlQ29sbGlzaW9uUmVjdGFuZ2xlJywgU2ltcGxlQ29sbGlzaW9uUmVjdGFuZ2xlKSwgc3VwZXJjbGFzcykucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IFNpbXBsZUNvbGxpc2lvblJlY3RhbmdsZTtcbiAga0V4dHJhT2Zmc2V0ID0gMC4wMDE7XG4gIGZ1bmN0aW9uIFNpbXBsZUNvbGxpc2lvblJlY3RhbmdsZShyZWN0KXtcbiAgICB0aGlzLnJlY3QgPSByZWN0O1xuICB9XG4gIHByb3RvdHlwZS5jb2xsaWRlc1dpdGggPSBmdW5jdGlvbihyZWN0KXtcbiAgICByZXR1cm4gdGhpcy5yZWN0LmNvbGxpZGVzV2l0aChyZWN0KTtcbiAgfTtcbiAgcHJvdG90eXBlLmxlZnRDb2xsaXNpb24gPSBmdW5jdGlvbih4LCB5LCDOlCl7XG4gICAgcmV0dXJuIG5ldyBSZWN0KHggKyB0aGlzLnJlY3QubGVmdCArIM6ULCB5ICsgdGhpcy5yZWN0LnRvcCwgdGhpcy5yZWN0LncgLSDOlCwgdGhpcy5yZWN0LmgpO1xuICB9O1xuICBwcm90b3R5cGUucmlnaHRDb2xsaXNpb24gPSBmdW5jdGlvbih4LCB5LCDOlCl7XG4gICAgcmV0dXJuIG5ldyBSZWN0KHggKyB0aGlzLnJlY3QubGVmdCwgeSArIHRoaXMucmVjdC50b3AsIHRoaXMucmVjdC53ICsgzpQsIHRoaXMucmVjdC5oKTtcbiAgfTtcbiAgcHJvdG90eXBlLnRvcENvbGxpc2lvbiA9IGZ1bmN0aW9uKHgsIHksIM6UKXtcbiAgICByZXR1cm4gbmV3IFJlY3QoeCArIHRoaXMucmVjdC5sZWZ0LCB5ICsgdGhpcy5yZWN0LnRvcCArIM6ULCB0aGlzLnJlY3QudywgdGhpcy5yZWN0LmggLSDOlCk7XG4gIH07XG4gIHByb3RvdHlwZS5ib3R0b21Db2xsaXNpb24gPSBmdW5jdGlvbih4LCB5LCDOlCl7XG4gICAgcmV0dXJuIG5ldyBSZWN0KHggKyB0aGlzLnJlY3QubGVmdCwgeSArIHRoaXMucmVjdC50b3AsIHRoaXMucmVjdC53LCB0aGlzLnJlY3QuaCArIM6UKTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgJ2JvdW5kaW5nQm94Jywge1xuICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBuZXcgUmVjdCh0aGlzLnJlY3QubGVmdCAtIGtFeHRyYU9mZnNldCwgdGhpcy5yZWN0LnRvcCAtIGtFeHRyYU9mZnNldCwgdGhpcy5yZWN0LncgKyAyICoga0V4dHJhT2Zmc2V0LCB0aGlzLnJlY3QuaCArIDIgKiBrRXh0cmFPZmZzZXQpO1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBTaW1wbGVDb2xsaXNpb25SZWN0YW5nbGU7XG59KENvbGxpc2lvblJlY3RhbmdsZSkpO1xub3V0JC5Db21wb3NpdGVDb2xsaXNpb25SZWN0YW5nbGUgPSBDb21wb3NpdGVDb2xsaXNpb25SZWN0YW5nbGUgPSAoZnVuY3Rpb24oc3VwZXJjbGFzcyl7XG4gIHZhciBwcm90b3R5cGUgPSBleHRlbmQkKChpbXBvcnQkKENvbXBvc2l0ZUNvbGxpc2lvblJlY3RhbmdsZSwgc3VwZXJjbGFzcykuZGlzcGxheU5hbWUgPSAnQ29tcG9zaXRlQ29sbGlzaW9uUmVjdGFuZ2xlJywgQ29tcG9zaXRlQ29sbGlzaW9uUmVjdGFuZ2xlKSwgc3VwZXJjbGFzcykucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IENvbXBvc2l0ZUNvbGxpc2lvblJlY3RhbmdsZTtcbiAgZnVuY3Rpb24gQ29tcG9zaXRlQ29sbGlzaW9uUmVjdGFuZ2xlKHRvcCwgYm90dG9tLCBsZWZ0LCByaWdodCl7XG4gICAgdGhpcy50b3AgPSB0b3A7XG4gICAgdGhpcy5ib3R0b20gPSBib3R0b207XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gIH1cbiAgcHJvdG90eXBlLmxlZnRDb2xsaXNpb24gPSBmdW5jdGlvbih4LCB5LCDOlCl7XG4gICAgcmV0dXJuIG5ldyBSZWN0KHggKyB0aGlzLmxlZnQubGVmdCArIM6ULCB5ICsgdGhpcy5sZWZ0LnRvcCwgdGhpcy5sZWZ0LncgLSDOlCwgdGhpcy5sZWZ0LmgpO1xuICB9O1xuICBwcm90b3R5cGUucmlnaHRDb2xsaXNpb24gPSBmdW5jdGlvbih4LCB5LCDOlCl7XG4gICAgcmV0dXJuIG5ldyBSZWN0KHggKyB0aGlzLnJpZ2h0LmxlZnQsIHkgKyB0aGlzLnJpZ2h0LnRvcCwgdGhpcy5yaWdodC53ICsgzpQsIHRoaXMucmlnaHQuaCk7XG4gIH07XG4gIHByb3RvdHlwZS50b3BDb2xsaXNpb24gPSBmdW5jdGlvbih4LCB5LCDOlCl7XG4gICAgcmV0dXJuIG5ldyBSZWN0KHggKyB0aGlzLnRvcC5sZWZ0LCB5ICsgdGhpcy50b3AudG9wICsgzpQsIHRoaXMudG9wLncsIHRoaXMudG9wLmggLSDOlCk7XG4gIH07XG4gIHByb3RvdHlwZS5ib3R0b21Db2xsaXNpb24gPSBmdW5jdGlvbih4LCB5LCDOlCl7XG4gICAgcmV0dXJuIG5ldyBSZWN0KHggKyB0aGlzLmJvdHRvbS5sZWZ0LCB5ICsgdGhpcy5ib3R0b20udG9wLCB0aGlzLmJvdHRvbS53LCB0aGlzLmJvdHRvbS5oICsgzpQpO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCAnYm91bmRpbmdCb3gnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIG5ldyBSZWN0KHRoaXMubGVmdC5sZWZ0LCB0aGlzLnRvcC50b3AsIHRoaXMubGVmdC53ICsgdGhpcy5yaWdodC53LCB0aGlzLnRvcC5oICsgdGhpcy5ib3R0b20uaCk7XG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIENvbXBvc2l0ZUNvbGxpc2lvblJlY3RhbmdsZTtcbn0oQ29sbGlzaW9uUmVjdGFuZ2xlKSk7XG5mdW5jdGlvbiBleHRlbmQkKHN1Yiwgc3VwKXtcbiAgZnVuY3Rpb24gZnVuKCl7fSBmdW4ucHJvdG90eXBlID0gKHN1Yi5zdXBlcmNsYXNzID0gc3VwKS5wcm90b3R5cGU7XG4gIChzdWIucHJvdG90eXBlID0gbmV3IGZ1bikuY29uc3RydWN0b3IgPSBzdWI7XG4gIGlmICh0eXBlb2Ygc3VwLmV4dGVuZGVkID09ICdmdW5jdGlvbicpIHN1cC5leHRlbmRlZChzdWIpO1xuICByZXR1cm4gc3ViO1xufVxuZnVuY3Rpb24gaW1wb3J0JChvYmosIHNyYyl7XG4gIHZhciBvd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbiAgZm9yICh2YXIga2V5IGluIHNyYykgaWYgKG93bi5jYWxsKHNyYywga2V5KSkgb2JqW2tleV0gPSBzcmNba2V5XTtcbiAgcmV0dXJuIG9iajtcbn0iLCJ2YXIga1NjcmVlbldpZHRoLCBrU2NyZWVuSGVpZ2h0LCBrRnBzLCBrTWF4RnJhbWVUaW1lLCBrR3JhcGhpY3NRdWFsaXR5LCBkZWJ1Z0ZlYXR1cmVzLCB0aGF0LCBzaG93Q29sbGlzaW9ucywgc2hvd1Nwcml0ZXNoZWV0cywgc2hvd1JlYWRvdXQsIGFzc2V0UGF0aCwgZmlsZUV4dCwgZmluZEFzc2V0LCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xub3V0JC5rU2NyZWVuV2lkdGggPSBrU2NyZWVuV2lkdGggPSAyMDtcbm91dCQua1NjcmVlbkhlaWdodCA9IGtTY3JlZW5IZWlnaHQgPSAxNTtcbm91dCQua0ZwcyA9IGtGcHMgPSA2MDtcbm91dCQua01heEZyYW1lVGltZSA9IGtNYXhGcmFtZVRpbWUgPSA1ICogMTAwMCAvIGtGcHM7XG5vdXQkLmtHcmFwaGljc1F1YWxpdHkgPSBrR3JhcGhpY3NRdWFsaXR5ID0gMzI7XG5vdXQkLmRlYnVnRmVhdHVyZXMgPSBkZWJ1Z0ZlYXR1cmVzID0gKHRoYXQgPSBFTkFCTEVfREVCVUdfRkVBVFVSRVMpICE9IG51bGwgPyB0aGF0IDogZmFsc2U7XG5vdXQkLnNob3dDb2xsaXNpb25zID0gc2hvd0NvbGxpc2lvbnMgPSBkZWJ1Z0ZlYXR1cmVzO1xub3V0JC5zaG93U3ByaXRlc2hlZXRzID0gc2hvd1Nwcml0ZXNoZWV0cyA9IGRlYnVnRmVhdHVyZXM7XG5vdXQkLnNob3dSZWFkb3V0ID0gc2hvd1JlYWRvdXQgPSBkZWJ1Z0ZlYXR1cmVzO1xuc3dpdGNoIChrR3JhcGhpY3NRdWFsaXR5KSB7XG5jYXNlIDE2OlxuICBvdXQkLmFzc2V0UGF0aCA9IGFzc2V0UGF0aCA9ICdkYXRhLzE2eDE2Lyc7XG4gIG91dCQuZmlsZUV4dCA9IGZpbGVFeHQgPSAnLmJtcCc7XG4gIGJyZWFrO1xuY2FzZSAzMjpcbiAgb3V0JC5hc3NldFBhdGggPSBhc3NldFBhdGggPSAnZGF0YS8zMngzMi8nO1xuICBvdXQkLmZpbGVFeHQgPSBmaWxlRXh0ID0gJy5ibXAnO1xufVxub3V0JC5maW5kQXNzZXQgPSBmaW5kQXNzZXQgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gKGZ1bmN0aW9uKGl0KXtcbiAgICByZXR1cm4gYXNzZXRQYXRoICsgaXQ7XG4gIH0pKChmdW5jdGlvbihpdCl7XG4gICAgcmV0dXJuIGl0ICsgZmlsZUV4dDtcbiAgfSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG59OyIsInZhciBzdGQsIHVuaXRzLCBUaW1lciwgTnVtYmVyU3ByaXRlLCBrVmVsb2NpdHksIGtWYW5pc2hUaW1lLCBEYW1hZ2VUZXh0LCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG51bml0cyA9IHJlcXVpcmUoJy4vdW5pdHMnKTtcblRpbWVyID0gcmVxdWlyZSgnLi90aW1lcicpLlRpbWVyO1xuTnVtYmVyU3ByaXRlID0gcmVxdWlyZSgnLi9zcHJpdGUnKS5OdW1iZXJTcHJpdGU7XG5rVmVsb2NpdHkgPSAtdW5pdHMua0hhbGZUaWxlIC8gMjUwO1xua1ZhbmlzaFRpbWUgPSAyMDAwO1xub3V0JC5EYW1hZ2VUZXh0ID0gRGFtYWdlVGV4dCA9IChmdW5jdGlvbigpe1xuICBEYW1hZ2VUZXh0LmRpc3BsYXlOYW1lID0gJ0RhbWFnZVRleHQnO1xuICB2YXIgcHJvdG90eXBlID0gRGFtYWdlVGV4dC5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gRGFtYWdlVGV4dDtcbiAgZnVuY3Rpb24gRGFtYWdlVGV4dChncmFwaGljcywgY2VudGVyWCwgY2VudGVyWSl7XG4gICAgdGhpcy5jZW50ZXJYID0gY2VudGVyWDtcbiAgICB0aGlzLmNlbnRlclkgPSBjZW50ZXJZO1xuICAgIHRoaXMudGltZXIgPSBuZXcgVGltZXIoa1ZhbmlzaFRpbWUpO1xuICAgIHRoaXMuZGFtYWdlID0gMDtcbiAgICB0aGlzLm9mZnNldFkgPSAwO1xuICAgIHRoaXMuc2hvdWxkUmlzZSA9IGZhbHNlO1xuICB9XG4gIHByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHgsIHkpe1xuICAgIHRoaXMuY2VudGVyWCA9IHg7XG4gICAgcmV0dXJuIHRoaXMuY2VudGVyWSA9IHkgKyB0aGlzLm9mZnNldFk7XG4gIH07XG4gIHByb3RvdHlwZS5zZXREYW1hZ2UgPSBmdW5jdGlvbihkYW1hZ2Upe1xuICAgIHRoaXMuc2hvdWxkUmlzZSA9IHRoaXMuZGFtYWdlID09PSAwO1xuICAgIGlmICh0aGlzLnNob3VsZFJpc2UpIHtcbiAgICAgIHRoaXMub2Zmc2V0WSA9IDA7XG4gICAgfVxuICAgIHRoaXMuZGFtYWdlICs9IGRhbWFnZTtcbiAgICByZXR1cm4gdGhpcy50aW1lci5yZXNldCgpO1xuICB9O1xuICBwcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oZWxhcHNlZFRpbWUpe1xuICAgIGlmICh0aGlzLnRpbWVyLmlzRXhwaXJlZCkge1xuICAgICAgdGhpcy5kYW1hZ2UgPSAwO1xuICAgIH1cbiAgICBpZiAodGhpcy5zaG91bGRSaXNlKSB7XG4gICAgICB0aGlzLm9mZnNldFkgPSBzdGQubWF4KHVuaXRzLnRpbGVUb0dhbWUoLTEpLCB0aGlzLm9mZnNldFkgKyBrVmVsb2NpdHkgKiBlbGFwc2VkVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmV4cGlyZWQ7XG4gIH07XG4gIHByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZ3JhcGhpY3Mpe1xuICAgIGlmICh0aGlzLnRpbWVyLmlzQWN0aXZlICYmIHRoaXMuZGFtYWdlID4gMCkge1xuICAgICAgcmV0dXJuIG5ldyBOdW1iZXJTcHJpdGUuRGFtYWdlTnVtYmVyKGdyYXBoaWNzLCB0aGlzLmRhbWFnZSkuZHJhd0NlbnRlcmVkKGdyYXBoaWNzLCB0aGlzLmNlbnRlclgsIHRoaXMuY2VudGVyWSk7XG4gICAgfVxuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCAnZXhwaXJlZCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy50aW1lci5pc0V4cGlyZWQ7XG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIERhbWFnZVRleHQ7XG59KCkpOyIsInZhciBzdGQsIGFsbFRleHRzLCBvd25lcnMsIHJlamVjdCwgRGFtYWdlVGV4dHMsIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5zdGQgPSByZXF1aXJlKCdzdGQnKTtcbmFsbFRleHRzID0gW107XG5vd25lcnMgPSBuZXcgV2Vha01hcDtcbnJlamVjdCA9IHN0ZC5mbGlwKHN0ZC5yZWplY3QpKGFsbFRleHRzKTtcbm91dCQuRGFtYWdlVGV4dHMgPSBEYW1hZ2VUZXh0cyA9IHtcbiAgYWRkRGFtYWdlYWJsZTogZnVuY3Rpb24oZGFtYWdlYWJsZSl7XG4gICAgdmFyIHRleHQ7XG4gICAgdGV4dCA9IGRhbWFnZWFibGUuZ2V0RGFtYWdlVGV4dCgpO1xuICAgIGFsbFRleHRzLnB1c2godGV4dCk7XG4gICAgcmV0dXJuIG93bmVycy5zZXQodGV4dCwgZGFtYWdlYWJsZSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24oZWxhcHNlZFRpbWUpe1xuICAgIHJldHVybiBhbGxUZXh0cyA9IHJlamVjdChmdW5jdGlvbih0ZXh0KXtcbiAgICAgIHZhciBvd25lcjtcbiAgICAgIGlmICghdGV4dC5leHBpcmVkKSB7XG4gICAgICAgIG93bmVyID0gb3duZXJzLmdldCh0ZXh0KTtcbiAgICAgICAgdGV4dC5zZXRQb3NpdGlvbihvd25lci5jZW50ZXJYLCBvd25lci5jZW50ZXJZKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZXh0LnVwZGF0ZShlbGFwc2VkVGltZSk7XG4gICAgfSk7XG4gIH0sXG4gIGRyYXc6IGZ1bmN0aW9uKGdyYXBoaWNzKXtcbiAgICB2YXIgaSQsIHJlZiQsIGxlbiQsIHRleHQsIHJlc3VsdHMkID0gW107XG4gICAgZm9yIChpJCA9IDAsIGxlbiQgPSAocmVmJCA9IGFsbFRleHRzKS5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgICAgdGV4dCA9IHJlZiRbaSRdO1xuICAgICAgcmVzdWx0cyQucHVzaCh0ZXh0LmRyYXcoZ3JhcGhpY3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHMkO1xuICB9XG59OyIsInZhciBzdGQsIEludGVyZmFjZUVycm9yLCBEYW1hZ2VhYmxlLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG5JbnRlcmZhY2VFcnJvciA9IHN0ZC5JbnRlcmZhY2VFcnJvcjtcbm91dCQuRGFtYWdlYWJsZSA9IERhbWFnZWFibGUgPSAoZnVuY3Rpb24oKXtcbiAgRGFtYWdlYWJsZS5kaXNwbGF5TmFtZSA9ICdEYW1hZ2VhYmxlJztcbiAgdmFyIHByb3RvdHlwZSA9IERhbWFnZWFibGUucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IERhbWFnZWFibGU7XG4gIHByb3RvdHlwZS5jZW50ZXJYID0gMDtcbiAgcHJvdG90eXBlLmNlbnRlclkgPSAwO1xuICBwcm90b3R5cGUuZ2V0RGFtYWdlVGV4dCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhyb3cgbmV3IEludGVyZmFjZUVycm9yKFwiRGFtYWdlYWJsZSAtIGBnZXQtZGFtYWdlLXRleHRgIG1ldGhvZCBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH07XG4gIGZ1bmN0aW9uIERhbWFnZWFibGUoKXt9XG4gIHJldHVybiBEYW1hZ2VhYmxlO1xufSgpKTsiLCJ2YXIgc3RkLCB1bml0cywga0hhbGZUaWxlLCB0cHgsIFBvbGFyVmVjdG9yLCBBbmltYXRlZFNwcml0ZSwga0Jhc2VWZWxvY2l0eSwgRGVhdGhDbG91ZFBhcnRpY2xlLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG51bml0cyA9IHJlcXVpcmUoJy4vdW5pdHMnKTtcbmtIYWxmVGlsZSA9IHVuaXRzLmtIYWxmVGlsZSwgdHB4ID0gdW5pdHMudGlsZVRvUHg7XG5Qb2xhclZlY3RvciA9IHJlcXVpcmUoJy4vcG9sYXInKS5Qb2xhclZlY3RvcjtcbkFuaW1hdGVkU3ByaXRlID0gcmVxdWlyZSgnLi9zcHJpdGUnKS5BbmltYXRlZFNwcml0ZTtcbmtCYXNlVmVsb2NpdHkgPSAwLjEyO1xub3V0JC5EZWF0aENsb3VkUGFydGljbGUgPSBEZWF0aENsb3VkUGFydGljbGUgPSAoZnVuY3Rpb24oKXtcbiAgRGVhdGhDbG91ZFBhcnRpY2xlLmRpc3BsYXlOYW1lID0gJ0RlYXRoQ2xvdWRQYXJ0aWNsZSc7XG4gIHZhciBwcm90b3R5cGUgPSBEZWF0aENsb3VkUGFydGljbGUucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IERlYXRoQ2xvdWRQYXJ0aWNsZTtcbiAgZnVuY3Rpb24gRGVhdGhDbG91ZFBhcnRpY2xlKGdyYXBoaWNzLCBjZW50ZXJYLCBjZW50ZXJZLCBzcGVlZCwgYW5nbGUpe1xuICAgIHRoaXMuY2VudGVyWCA9IGNlbnRlclg7XG4gICAgdGhpcy5jZW50ZXJZID0gY2VudGVyWTtcbiAgICB0aGlzLnNwZWVkID0gc3BlZWQ7XG4gICAgdGhpcy5vZmZzZXQgPSBuZXcgUG9sYXJWZWN0b3IoMCwgYW5nbGUpO1xuICAgIHRoaXMuc3ByaXRlID0gbmV3IEFuaW1hdGVkU3ByaXRlKGdyYXBoaWNzLCAnTnBjL05wY1N5bScsIHRweCgxKSwgdHB4KDApLCB0cHgoMSksIHRweCgxKSwgMTgsIDcpO1xuICB9XG4gIHByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihlbGFwc2VkVGltZSl7XG4gICAgdGhpcy5zcHJpdGUudXBkYXRlKGVsYXBzZWRUaW1lKTtcbiAgICB0aGlzLm9mZnNldC5tYWcgKz0gZWxhcHNlZFRpbWUgKiB0aGlzLnNwZWVkO1xuICAgIHJldHVybiB0aGlzLnNwcml0ZS5udW1Db21wbGV0ZWRMb29wcyA9PT0gMDtcbiAgfTtcbiAgcHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihncmFwaGljcyl7XG4gICAgcmV0dXJuIHRoaXMuc3ByaXRlLmRyYXcoZ3JhcGhpY3MsIHRoaXMuY2VudGVyWCArIHRoaXMub2Zmc2V0LnggLSBrSGFsZlRpbGUsIHRoaXMuY2VudGVyWSArIHRoaXMub2Zmc2V0LnkgLSBrSGFsZlRpbGUpO1xuICB9O1xuICBEZWF0aENsb3VkUGFydGljbGUuY3JlYXRlUmFuZG9tRGVhdGhDbG91ZHMgPSBmdW5jdGlvbihwdG9vbHMsIGNlbnRlclgsIGNlbnRlclksIG51bSl7XG4gICAgdmFyIGkkLCBpeCwgcmFuZG9tQW5nbGUsIHJhbmRvbVNwZWVkLCByZXN1bHRzJCA9IFtdO1xuICAgIGZvciAoaSQgPSAwOyBpJCA8IG51bTsgKytpJCkge1xuICAgICAgaXggPSBpJDtcbiAgICAgIHJhbmRvbUFuZ2xlID0gc3RkLnJhbmQoMCwgc3RkLnRhdSk7XG4gICAgICByYW5kb21TcGVlZCA9IGtCYXNlVmVsb2NpdHkgKiBzdGQucmFuZCgwLCAyKTtcbiAgICAgIHJlc3VsdHMkLnB1c2gocHRvb2xzLmVudGl0eVN5c3RlbS5hZGROZXdQYXJ0aWNsZShuZXcgRGVhdGhDbG91ZFBhcnRpY2xlKHB0b29scy5ncmFwaGljcywgY2VudGVyWCwgY2VudGVyWSwgcmFuZG9tU3BlZWQsIHJhbmRvbUFuZ2xlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cyQ7XG4gIH07XG4gIHJldHVybiBEZWF0aENsb3VkUGFydGljbGU7XG59KCkpOyIsInZhciBzdGQsIHVuaXRzLCBjb25maWcsIHRweCwgdGlsZVRvR2FtZSwga0hhbGZUaWxlLCBEYW1hZ2VhYmxlLCBEYW1hZ2VUZXh0LCBEYW1hZ2VUZXh0cywgcmVmJCwgU3ByaXRlLCBBbmltYXRlZFNwcml0ZSwgUmVjdCwgUklHSFQsIExFRlQsIGtBbmd1bGFyVmVsb2NpdHksIGtGbHlGcHMsIGtOdW1GbHlGcmFtZXMsIGtDb250YWN0RGFtYWdlLCBTcHJpdGVTdGF0ZSwgRmlyc3RDYXZlQmF0LCBzbGljZSQgPSBbXS5zbGljZSwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcbnN0ZCA9IHJlcXVpcmUoJ3N0ZCcpO1xudW5pdHMgPSByZXF1aXJlKCcuL3VuaXRzJyk7XG5jb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xudHB4ID0gdW5pdHMudGlsZVRvUHgsIHRpbGVUb0dhbWUgPSB1bml0cy50aWxlVG9HYW1lLCBrSGFsZlRpbGUgPSB1bml0cy5rSGFsZlRpbGU7XG5EYW1hZ2VhYmxlID0gcmVxdWlyZSgnLi9kYW1hZ2VhYmxlJykuRGFtYWdlYWJsZTtcbkRhbWFnZVRleHQgPSByZXF1aXJlKCcuL2RhbWFnZS10ZXh0JykuRGFtYWdlVGV4dDtcbkRhbWFnZVRleHRzID0gcmVxdWlyZSgnLi9kYW1hZ2UtdGV4dHMnKS5EYW1hZ2VUZXh0cztcbnJlZiQgPSByZXF1aXJlKCcuL3Nwcml0ZScpLCBTcHJpdGUgPSByZWYkLlNwcml0ZSwgQW5pbWF0ZWRTcHJpdGUgPSByZWYkLkFuaW1hdGVkU3ByaXRlO1xuUmVjdCA9IHJlcXVpcmUoJy4vcmVjdGFuZ2xlJykuUmVjdGFuZ2xlO1xuUklHSFQgPSBcIlJcIjtcbkxFRlQgPSBcIkxcIjtcbmtBbmd1bGFyVmVsb2NpdHkgPSAxMjAgLyAxMDAwO1xua0ZseUZwcyA9IDE1O1xua051bUZseUZyYW1lcyA9IDM7XG5rQ29udGFjdERhbWFnZSA9IDE7XG5TcHJpdGVTdGF0ZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBhcmdzO1xuICBhcmdzID0gc2xpY2UkLmNhbGwoYXJndW1lbnRzKTtcbiAgcmV0dXJuIFN0cmluZyhhcmdzLmpvaW4oJy0nKSk7XG59O1xub3V0JC5GaXJzdENhdmVCYXQgPSBGaXJzdENhdmVCYXQgPSAoZnVuY3Rpb24oc3VwZXJjbGFzcyl7XG4gIHZhciBwcm90b3R5cGUgPSBleHRlbmQkKChpbXBvcnQkKEZpcnN0Q2F2ZUJhdCwgc3VwZXJjbGFzcykuZGlzcGxheU5hbWUgPSAnRmlyc3RDYXZlQmF0JywgRmlyc3RDYXZlQmF0KSwgc3VwZXJjbGFzcykucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IEZpcnN0Q2F2ZUJhdDtcbiAgZnVuY3Rpb24gRmlyc3RDYXZlQmF0KGdyYXBoaWNzLCB4LCBmbGlnaHRDZW50ZXJZKXtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMuZmxpZ2h0Q2VudGVyWSA9IGZsaWdodENlbnRlclk7XG4gICAgdGhpcy55ID0gdGhpcy5mbGlnaHRDZW50ZXJZO1xuICAgIHRoaXMuZmxpZ2h0QW5nbGUgPSAwO1xuICAgIHRoaXMuYWxpdmUgPSB0cnVlO1xuICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5ID0ga0FuZ3VsYXJWZWxvY2l0eTtcbiAgICB0aGlzLnNwcml0ZXMgPSB0aGlzLmluaXRpYWxpc2VTcHJpdGVzKGdyYXBoaWNzKTtcbiAgICB0aGlzLmRhbWFnZVRleHQgPSBuZXcgRGFtYWdlVGV4dChncmFwaGljcyk7XG4gICAgdGhpcy5jb250YWN0RGFtYWdlID0ga0NvbnRhY3REYW1hZ2U7XG4gICAgRGFtYWdlVGV4dHMuYWRkRGFtYWdlYWJsZSh0aGlzKTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCAnc3ByaXRlc3RhdGUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIFNwcml0ZVN0YXRlKHRoaXMuaG9yaXpvbnRhbEZhY2luZyk7XG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KTtcbiAgcHJvdG90eXBlLmluaXRpYWxpc2VTcHJpdGUgPSBmdW5jdGlvbihncmFwaGljcywgZmFjaW5nKXtcbiAgICB2YXIgZmFjaW5nT2Zmc2V0O1xuICAgIGZhY2luZ09mZnNldCA9IGZhY2luZyA9PT0gUklHSFQgPyAxIDogMDtcbiAgICByZXR1cm4gbmV3IEFuaW1hdGVkU3ByaXRlKGdyYXBoaWNzLCAnTnBjL05wY0NlbWV0JywgdHB4KDIpLCB0cHgoMiArIGZhY2luZ09mZnNldCksIHRweCgxKSwgdHB4KDEpLCBrRmx5RnBzLCBrTnVtRmx5RnJhbWVzKTtcbiAgfTtcbiAgcHJvdG90eXBlLmluaXRpYWxpc2VTcHJpdGVzID0gZnVuY3Rpb24oZ3JhcGhpY3MsIHNwcml0ZU1hcCl7XG4gICAgdmFyIGkkLCByZWYkLCBsZW4kLCBmYWNpbmc7XG4gICAgc3ByaXRlTWFwID09IG51bGwgJiYgKHNwcml0ZU1hcCA9IHt9KTtcbiAgICBmb3IgKGkkID0gMCwgbGVuJCA9IChyZWYkID0gW0xFRlQsIFJJR0hUXSkubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICAgIGZhY2luZyA9IHJlZiRbaSRdO1xuICAgICAgc3ByaXRlTWFwW1Nwcml0ZVN0YXRlKGZhY2luZyldID0gdGhpcy5pbml0aWFsaXNlU3ByaXRlKGdyYXBoaWNzLCBmYWNpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gc3ByaXRlTWFwO1xuICB9O1xuICBwcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oZWxhcHNlZFRpbWUsIHBsYXllclgpe1xuICAgIHRoaXMuaG9yaXpvbnRhbEZhY2luZyA9IHBsYXllclggPCB0aGlzLnggPyBMRUZUIDogUklHSFQ7XG4gICAgdGhpcy5mbGlnaHRBbmdsZSArPSB0aGlzLmFuZ3VsYXJWZWxvY2l0eSAqIGVsYXBzZWRUaW1lO1xuICAgIHRoaXMueSA9IHRoaXMuZmxpZ2h0Q2VudGVyWSArIHVuaXRzLnRpbGVUb0dhbWUoNSkgLyAyICogc3RkLnNpbih1bml0cy5kZWdUb1JhZCh0aGlzLmZsaWdodEFuZ2xlKSk7XG4gICAgdGhpcy5zcHJpdGVzW3RoaXMuc3ByaXRlc3RhdGVdLnVwZGF0ZShlbGFwc2VkVGltZSk7XG4gICAgcmV0dXJuIHRoaXMuYWxpdmU7XG4gIH07XG4gIHByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZ3JhcGhpY3Mpe1xuICAgIGlmIChjb25maWcuc2hvd0NvbGxpc2lvbnMpIHtcbiAgICAgIGdyYXBoaWNzLnZpc3VhbGlzZVJlY3QodGhpcy5jb2xsaXNpb25SZWN0YW5nbGUoKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNwcml0ZXNbdGhpcy5zcHJpdGVzdGF0ZV0uZHJhdyhncmFwaGljcywgdGhpcy54LCB0aGlzLnkpO1xuICB9O1xuICBwcm90b3R5cGUuZGFtYWdlQ29sbGlzaW9uID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmV3IFJlY3QodGhpcy5jZW50ZXJYLCB0aGlzLmNlbnRlclksIDEsIDEpO1xuICB9O1xuICBwcm90b3R5cGUuY29sbGlzaW9uUmVjdGFuZ2xlID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmV3IFJlY3QodGhpcy54LCB0aGlzLnksIHRpbGVUb0dhbWUoMSksIHRpbGVUb0dhbWUoMSkpO1xuICB9O1xuICBwcm90b3R5cGUudGFrZURhbWFnZSA9IGZ1bmN0aW9uKGRhbWFnZSl7XG4gICAgdGhpcy5kYW1hZ2VUZXh0LnNldERhbWFnZShkYW1hZ2UpO1xuICAgIHJldHVybiB0aGlzLmFsaXZlID0gZmFsc2U7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsICdjZW50ZXJYJywge1xuICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLnggKyBrSGFsZlRpbGU7XG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgJ2NlbnRlclknLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMueSArIGtIYWxmVGlsZTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xuICBwcm90b3R5cGUuZ2V0RGFtYWdlVGV4dCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuZGFtYWdlVGV4dDtcbiAgfTtcbiAgcmV0dXJuIEZpcnN0Q2F2ZUJhdDtcbn0oRGFtYWdlYWJsZSkpO1xuZnVuY3Rpb24gZXh0ZW5kJChzdWIsIHN1cCl7XG4gIGZ1bmN0aW9uIGZ1bigpe30gZnVuLnByb3RvdHlwZSA9IChzdWIuc3VwZXJjbGFzcyA9IHN1cCkucHJvdG90eXBlO1xuICAoc3ViLnByb3RvdHlwZSA9IG5ldyBmdW4pLmNvbnN0cnVjdG9yID0gc3ViO1xuICBpZiAodHlwZW9mIHN1cC5leHRlbmRlZCA9PSAnZnVuY3Rpb24nKSBzdXAuZXh0ZW5kZWQoc3ViKTtcbiAgcmV0dXJuIHN1Yjtcbn1cbmZ1bmN0aW9uIGltcG9ydCQob2JqLCBzcmMpe1xuICB2YXIgb3duID0ge30uaGFzT3duUHJvcGVydHk7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIGlmIChvd24uY2FsbChzcmMsIGtleSkpIG9ialtrZXldID0gc3JjW2tleV07XG4gIHJldHVybiBvYmo7XG59IiwidmFyIHN0ZCwgU0RMLCBpbnB1dCwgdW5pdHMsIGNvbmZpZywgcmVhZG91dCwgZ3JhcGhpY3MsIE1hcCwgdGlsZVRvR2FtZSwgVGltZXIsIFBsYXllciwgUGlja3VwcywgUmVjdGFuZ2xlLCBGaXJzdENhdmVCYXQsIEZpeGVkQmFja2Ryb3AsIERhbWFnZVRleHRzLCBQYXJ0aWNsZVRvb2xzLCBTdGFyUGFydGljbGUsIERlYXRoQ2xvdWRQYXJ0aWNsZSwgcmVmJCwgUG93ZXJEb3JpdG8sIFBpY2t1cCwga1NjcmVlbldpZHRoLCBrU2NyZWVuSGVpZ2h0LCBrRnBzLCBrTWF4RnJhbWVUaW1lLCBrRGVidWdNb2RlLCBydW5uaW5nLCBwbGF5ZXIsIGJhdCwgbWFwLCBwdG9vbHMsIHBpY2t1cHMsIHRpbWVGYWN0b3IsIGxhc3RGcmFtZVRpbWUsIGFueUtleXNQcmVzc2VkLCBldmVudExvb3AsIHVwZGF0ZSwgZHJhdywgY3JlYXRlVGVzdFdvcmxkLCBzdGFydCwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcbnN0ZCA9IHJlcXVpcmUoJ3N0ZCcpO1xuU0RMID0gcmVxdWlyZSgnU0RMJyk7XG5pbnB1dCA9IHJlcXVpcmUoJy4vaW5wdXQnKTtcbnVuaXRzID0gcmVxdWlyZSgnLi91bml0cycpO1xuY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcbnJlYWRvdXQgPSByZXF1aXJlKCcuL3JlYWRvdXQnKTtcbmdyYXBoaWNzID0gcmVxdWlyZSgnLi9ncmFwaGljcycpO1xuTWFwID0gcmVxdWlyZSgnLi9tYXAnKTtcbnRpbGVUb0dhbWUgPSB1bml0cy50aWxlVG9HYW1lO1xuVGltZXIgPSByZXF1aXJlKCcuL3RpbWVyJykuVGltZXI7XG5QbGF5ZXIgPSByZXF1aXJlKCcuL3BsYXllcicpLlBsYXllcjtcblBpY2t1cHMgPSByZXF1aXJlKCcuL3BpY2t1cHMnKS5QaWNrdXBzO1xuUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi9yZWN0YW5nbGUnKS5SZWN0YW5nbGU7XG5GaXJzdENhdmVCYXQgPSByZXF1aXJlKCcuL2ZpcnN0LWNhdmUtYmF0JykuRmlyc3RDYXZlQmF0O1xuRml4ZWRCYWNrZHJvcCA9IHJlcXVpcmUoJy4vYmFja2Ryb3AnKS5GaXhlZEJhY2tkcm9wO1xuRGFtYWdlVGV4dHMgPSByZXF1aXJlKCcuL2RhbWFnZS10ZXh0cycpLkRhbWFnZVRleHRzO1xuUGFydGljbGVUb29scyA9IHJlcXVpcmUoJy4vcGFydGljbGUtc3lzdGVtJykuUGFydGljbGVUb29scztcblN0YXJQYXJ0aWNsZSA9IHJlcXVpcmUoJy4vc3Rhci1wYXJ0aWNsZScpLlN0YXJQYXJ0aWNsZTtcbkRlYXRoQ2xvdWRQYXJ0aWNsZSA9IHJlcXVpcmUoJy4vZGVhdGgtY2xvdWQtcGFydGljbGUnKS5EZWF0aENsb3VkUGFydGljbGU7XG5yZWYkID0gcmVxdWlyZSgnLi9waWNrdXAnKSwgUG93ZXJEb3JpdG8gPSByZWYkLlBvd2VyRG9yaXRvLCBQaWNrdXAgPSByZWYkLlBpY2t1cDtcbmtTY3JlZW5XaWR0aCA9IGNvbmZpZy5rU2NyZWVuV2lkdGgsIGtTY3JlZW5IZWlnaHQgPSBjb25maWcua1NjcmVlbkhlaWdodCwga0ZwcyA9IGNvbmZpZy5rRnBzLCBrTWF4RnJhbWVUaW1lID0gY29uZmlnLmtNYXhGcmFtZVRpbWUsIGtEZWJ1Z01vZGUgPSBjb25maWcua0RlYnVnTW9kZTtcbnJ1bm5pbmcgPSB0cnVlO1xucGxheWVyID0gbnVsbDtcbmJhdCA9IG51bGw7XG5tYXAgPSBudWxsO1xucHRvb2xzID0gbnVsbDtcbnBpY2t1cHMgPSBudWxsO1xudGltZUZhY3RvciA9IDE7XG5sYXN0RnJhbWVUaW1lID0gMDtcbmFueUtleXNQcmVzc2VkID0gZmFsc2U7XG5ldmVudExvb3AgPSBmdW5jdGlvbigpe1xuICB2YXIgc3RhcnRUaW1lLCBldmVudCwgzpR0LCBlbGFwc2VkVGltZTtcbiAgc3RhcnRUaW1lID0gU0RMLmdldFRpY2tzKCk7XG4gIGlucHV0LmJlZ2luTmV3RnJhbWUoKTtcbiAgd2hpbGUgKGV2ZW50ID0gU0RMLnBvbGxFdmVudCgpKSB7XG4gICAgYW55S2V5c1ByZXNzZWQgPSB0cnVlO1xuICAgIHJlYWRvdXQudXBkYXRlKCd3aWxsc3RvcCcsIGZhbHNlKTtcbiAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICBjYXNlIFNETC5LRVlET1dOOlxuICAgICAgaW5wdXQua2V5RG93bkV2ZW50KGV2ZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU0RMLktFWVVQOlxuICAgICAgaW5wdXQua2V5VXBFdmVudChldmVudCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogXCJVbmtub3duIGV2ZW50IHR5cGU6IFwiICsgZXZlbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoaW5wdXQud2FzS2V5UHJlc3NlZChTREwuS0VZLkVTQ0FQRSkpIHtcbiAgICBydW5uaW5nID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlucHV0LmlzS2V5SGVsZChTREwuS0VZLkxFRlQpICYmIGlucHV0LmlzS2V5SGVsZChTREwuS0VZLlJJR0hUKSkge1xuICAgIHBsYXllci5zdG9wTW92aW5nKCk7XG4gIH0gZWxzZSBpZiAoaW5wdXQuaXNLZXlIZWxkKFNETC5LRVkuTEVGVCkpIHtcbiAgICBwbGF5ZXIuc3RhcnRNb3ZpbmdMZWZ0KCk7XG4gIH0gZWxzZSBpZiAoaW5wdXQuaXNLZXlIZWxkKFNETC5LRVkuUklHSFQpKSB7XG4gICAgcGxheWVyLnN0YXJ0TW92aW5nUmlnaHQoKTtcbiAgfSBlbHNlIHtcbiAgICBwbGF5ZXIuc3RvcE1vdmluZygpO1xuICB9XG4gIGlmIChpbnB1dC53YXNLZXlQcmVzc2VkKFNETC5LRVkuWikpIHtcbiAgICBwbGF5ZXIuc3RhcnRKdW1wKCk7XG4gIH0gZWxzZSBpZiAoaW5wdXQud2FzS2V5UmVsZWFzZWQoU0RMLktFWS5aKSkge1xuICAgIHBsYXllci5zdG9wSnVtcCgpO1xuICB9XG4gIGlmIChpbnB1dC53YXNLZXlQcmVzc2VkKFNETC5LRVkuWCkpIHtcbiAgICBwbGF5ZXIuc3RhcnRGaXJlKCk7XG4gIH0gZWxzZSBpZiAoaW5wdXQud2FzS2V5UmVsZWFzZWQoU0RMLktFWS5YKSkge1xuICAgIHBsYXllci5zdG9wRmlyZSgpO1xuICB9XG4gIGlmIChpbnB1dC5pc0tleUhlbGQoU0RMLktFWS5VUCkgJiYgaW5wdXQuaXNLZXlIZWxkKFNETC5LRVkuRE9XTikpIHtcbiAgICBwbGF5ZXIubG9va0hvcml6b250YWwoKTtcbiAgfSBlbHNlIGlmIChpbnB1dC5pc0tleUhlbGQoU0RMLktFWS5VUCkpIHtcbiAgICBwbGF5ZXIubG9va1VwKCk7XG4gIH0gZWxzZSBpZiAoaW5wdXQuaXNLZXlIZWxkKFNETC5LRVkuRE9XTikpIHtcbiAgICBwbGF5ZXIubG9va0Rvd24oKTtcbiAgfSBlbHNlIHtcbiAgICBwbGF5ZXIubG9va0hvcml6b250YWwoKTtcbiAgfVxuICBpZiAoaW5wdXQud2FzS2V5UHJlc3NlZChTREwuS0VZLk9ORSkpIHtcbiAgICB0aW1lRmFjdG9yID0gMTtcbiAgfVxuICBpZiAoaW5wdXQud2FzS2V5UHJlc3NlZChTREwuS0VZLlRXTykpIHtcbiAgICB0aW1lRmFjdG9yID0gMjtcbiAgfVxuICBpZiAoaW5wdXQud2FzS2V5UHJlc3NlZChTREwuS0VZLlRIUkVFKSkge1xuICAgIHRpbWVGYWN0b3IgPSAzO1xuICB9XG4gIGlmIChpbnB1dC53YXNLZXlQcmVzc2VkKFNETC5LRVkuRk9VUikpIHtcbiAgICB0aW1lRmFjdG9yID0gNDtcbiAgfVxuICDOlHQgPSBzdGQubWluKFNETC5nZXRUaWNrcygpIC0gbGFzdEZyYW1lVGltZSwga01heEZyYW1lVGltZSk7XG4gIHVwZGF0ZSjOlHQgLyB0aW1lRmFjdG9yKTtcbiAgZHJhdygpO1xuICBpZiAocnVubmluZykge1xuICAgIGxhc3RGcmFtZVRpbWUgPSBTREwuZ2V0VGlja3MoKTtcbiAgICBlbGFwc2VkVGltZSA9IGxhc3RGcmFtZVRpbWUgLSBzdGFydFRpbWU7XG4gICAgcmVhZG91dC51cGRhdGUoJ2ZyYW1ldGltZScsIHN0ZC5mbG9vcigxMDAwIC8gzpR0KSk7XG4gICAgcmVhZG91dC51cGRhdGUoJ2RyYXd0aW1lJywgZWxhcHNlZFRpbWUpO1xuICAgIHJldHVybiBTREwuZGVsYXkoMTAwMCAvIGtGcHMgLSBlbGFwc2VkVGltZSwgZXZlbnRMb29wKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RkLmxvZygnR2FtZSBzdG9wcGVkLicpO1xuICB9XG59O1xudXBkYXRlID0gZnVuY3Rpb24oZWxhcHNlZFRpbWUpe1xuICB2YXIgaSQsIHJlZiQsIGxlbiQsIHByb2plY3RpbGU7XG4gIFRpbWVyLnVwZGF0ZUFsbChlbGFwc2VkVGltZSk7XG4gIHBsYXllci51cGRhdGUoZWxhcHNlZFRpbWUsIG1hcCk7XG4gIGlmIChiYXQgJiYgIShiYXQgIT0gbnVsbCAmJiBiYXQudXBkYXRlKGVsYXBzZWRUaW1lLCBwbGF5ZXIueCkpKSB7XG4gICAgcGlja3Vwcy5hZGQobmV3IFBvd2VyRG9yaXRvKGdyYXBoaWNzLCBiYXQuY2VudGVyWCwgYmF0LmNlbnRlclksIFBpY2t1cC5TTUFMTCkpO1xuICAgIERlYXRoQ2xvdWRQYXJ0aWNsZS5jcmVhdGVSYW5kb21EZWF0aENsb3VkcyhwdG9vbHMsIGJhdC5jZW50ZXJYLCBiYXQuY2VudGVyWSwgMyk7XG4gICAgYmF0ID0gbnVsbDtcbiAgfVxuICBmb3IgKGkkID0gMCwgbGVuJCA9IChyZWYkID0gcGxheWVyLmdldFByb2plY3RpbGVzKCkpLmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgcHJvamVjdGlsZSA9IHJlZiRbaSRdO1xuICAgIGlmIChiYXQgIT0gbnVsbCAmJiBiYXQuY29sbGlzaW9uUmVjdGFuZ2xlKCkuY29sbGlkZXNXaXRoKHByb2plY3RpbGUuY29sbGlzaW9uUmVjdGFuZ2xlKCkpKSB7XG4gICAgICBwcm9qZWN0aWxlLmNvbGxpZGVXaXRoRW5lbXkoKTtcbiAgICAgIGJhdC50YWtlRGFtYWdlKHByb2plY3RpbGUuY29udGFjdERhbWFnZSk7XG4gICAgfVxuICB9XG4gIHBpY2t1cHMuaGFuZGxlQ29sbGlzaW9ucyhwbGF5ZXIpO1xuICBpZiAoYmF0ICE9IG51bGwgJiYgYmF0LmRhbWFnZUNvbGxpc2lvbigpLmNvbGxpZGVzV2l0aChwbGF5ZXIuZGFtYWdlQ29sbGlzaW9uKCkpKSB7XG4gICAgcGxheWVyLnRha2VEYW1hZ2UoYmF0LmNvbnRhY3REYW1hZ2UpO1xuICB9XG4gIERhbWFnZVRleHRzLnVwZGF0ZShlbGFwc2VkVGltZSk7XG4gIHBpY2t1cHMudXBkYXRlKGVsYXBzZWRUaW1lLCBtYXApO1xuICByZXR1cm4gcHRvb2xzLnVwZGF0ZShlbGFwc2VkVGltZSk7XG59O1xuZHJhdyA9IGZ1bmN0aW9uKCl7XG4gIGdyYXBoaWNzLmNsZWFyKCk7XG4gIG1hcC5kcmF3QmFja2dyb3VuZChncmFwaGljcyk7XG4gIGlmIChiYXQgIT0gbnVsbCkge1xuICAgIGJhdC5kcmF3KGdyYXBoaWNzKTtcbiAgfVxuICBwdG9vbHMuZW50aXR5U3lzdGVtLmRyYXcoZ3JhcGhpY3MpO1xuICBwaWNrdXBzLmRyYXcoZ3JhcGhpY3MpO1xuICBwbGF5ZXIuZHJhdyhncmFwaGljcyk7XG4gIG1hcC5kcmF3KGdyYXBoaWNzKTtcbiAgcHRvb2xzLmZyb250U3lzdGVtLmRyYXcoZ3JhcGhpY3MpO1xuICBEYW1hZ2VUZXh0cy5kcmF3KGdyYXBoaWNzKTtcbiAgcmV0dXJuIHBsYXllci5kcmF3SHVkKGdyYXBoaWNzKTtcbn07XG5jcmVhdGVUZXN0V29ybGQgPSBmdW5jdGlvbigpe1xuICBtYXAgPSBNYXAuY3JlYXRlVGVzdE1hcChncmFwaGljcyk7XG4gIHB0b29scyA9IG5ldyBQYXJ0aWNsZVRvb2xzKGdyYXBoaWNzKTtcbiAgcGxheWVyID0gbmV3IFBsYXllcihncmFwaGljcywgdW5pdHMudGlsZVRvR2FtZShrU2NyZWVuV2lkdGggLyAyKSwgdW5pdHMudGlsZVRvR2FtZSgxMCksIHB0b29scyk7XG4gIGJhdCA9IG5ldyBGaXJzdENhdmVCYXQoZ3JhcGhpY3MsIHVuaXRzLnRpbGVUb0dhbWUoNyksIHVuaXRzLnRpbGVUb0dhbWUoOCkpO1xuICByZXR1cm4gcGlja3VwcyA9IG5ldyBQaWNrdXBzO1xufTtcbm91dCQuc3RhcnQgPSBzdGFydCA9IGZ1bmN0aW9uKCl7XG4gIFNETC5pbml0KFNETC5JTklUX0VWRVJZVEhJTkcpO1xuICByZWFkb3V0LmFkZFJlYWRlcignZnJhbWV0aW1lJywgJ0ZyYW1lIHRpbWUnKTtcbiAgcmVhZG91dC5hZGRSZWFkZXIoJ2RyYXd0aW1lJywgJ0RyYXcgdGltZScpO1xuICByZWFkb3V0LmFkZFJlYWRlcignd2lsbHN0b3AnLCAnV2lsbCBzdG9wJywgdHJ1ZSk7XG4gIGNyZWF0ZVRlc3RXb3JsZCgpO1xuICBldmVudExvb3AoKTtcbiAgcmV0dXJuIHN0ZC5kZWxheSg1MDAwLCBmdW5jdGlvbigpe1xuICAgIGlmICghYW55S2V5c1ByZXNzZWQpIHtcbiAgICAgIHJldHVybiBydW5uaW5nID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdGQubG9nKFwiR2FtZSBiZWluZyBpbnRlcmFjdGVkIHdpdGguIERvbid0IHNodXQgZG93blwiKTtcbiAgICB9XG4gIH0pO1xufTsiLCJ2YXIgc3RkLCBTREwsIGNvbmZpZywgdW5pdHMsIGtTY3JlZW5XaWR0aCwga1NjcmVlbkhlaWdodCwga1RyYW5zcGFyZW50Q29sb3IsIGtTY3JlZW5TY2FsZUZhY3Rvciwgc3ByaXRlc2hlZXRzLCBzY3JlZW4sIGxvYWRJbWFnZSwgYmxpdFN1cmZhY2UsIGNsZWFyLCB2aXN1YWxpc2VSZWN0LCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG5TREwgPSByZXF1aXJlKCdTREwnKTtcbmNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG51bml0cyA9IHJlcXVpcmUoJy4vdW5pdHMnKTtcbmtTY3JlZW5XaWR0aCA9IGNvbmZpZy5rU2NyZWVuV2lkdGgsIGtTY3JlZW5IZWlnaHQgPSBjb25maWcua1NjcmVlbkhlaWdodDtcbmtUcmFuc3BhcmVudENvbG9yID0gWzAsIDAsIDBdO1xua1NjcmVlblNjYWxlRmFjdG9yID0gY29uZmlnLmtHcmFwaGljc1F1YWxpdHkgPT09IDE2ID8gMiA6IDE7XG5zcHJpdGVzaGVldHMgPSB7fTtcbnNjcmVlbiA9IFNETC5zZXRWaWRlb01vZGUodW5pdHMudGlsZVRvUHgoa1NjcmVlbldpZHRoKSwgdW5pdHMudGlsZVRvUHgoa1NjcmVlbkhlaWdodCksIGtTY3JlZW5TY2FsZUZhY3Rvcik7XG5vdXQkLmxvYWRJbWFnZSA9IGxvYWRJbWFnZSA9IGZ1bmN0aW9uKGZpbGVuYW1lLCB1c2VUcmFuc3BhcmVuY3kpe1xuICB1c2VUcmFuc3BhcmVuY3kgPT0gbnVsbCAmJiAodXNlVHJhbnNwYXJlbmN5ID0gZmFsc2UpO1xuICBpZiAoc3ByaXRlc2hlZXRzW2ZpbGVuYW1lXSA9PSBudWxsKSB7XG4gICAgc3ByaXRlc2hlZXRzW2ZpbGVuYW1lXSA9IFNETC5sb2FkSW1hZ2UoY29uZmlnLmZpbmRBc3NldChmaWxlbmFtZSkpO1xuICAgIGlmICh1c2VUcmFuc3BhcmVuY3kpIHtcbiAgICAgIFNETC5zZXRDb2xvcktleShzcHJpdGVzaGVldHNbZmlsZW5hbWVdLCBrVHJhbnNwYXJlbnRDb2xvcik7XG4gICAgfVxuICAgIGlmIChjb25maWcuc2hvd1Nwcml0ZXNoZWV0cykge1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzcHJpdGVzaGVldHNbZmlsZW5hbWVdLmNhbnZhcyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzcHJpdGVzaGVldHNbZmlsZW5hbWVdO1xufTtcbm91dCQuYmxpdFN1cmZhY2UgPSBibGl0U3VyZmFjZSA9IGZ1bmN0aW9uKHNvdXJjZSwgc3JjUmVjdCwgZGVzdFJlY3Qpe1xuICByZXR1cm4gU0RMLmJsaXRTdXJmYWNlKHNvdXJjZSwgc3JjUmVjdCwgc2NyZWVuLCBkZXN0UmVjdCk7XG59O1xub3V0JC5jbGVhciA9IGNsZWFyID0gYmluZCQoc2NyZWVuLCAnY2xlYXInKTtcbm91dCQudmlzdWFsaXNlUmVjdCA9IHZpc3VhbGlzZVJlY3QgPSBmdW5jdGlvbihyZWN0LCBmaWxsKXtcbiAgdmFyIHBhaW50UmVjdDtcbiAgcGFpbnRSZWN0ID0gbmV3IFNETC5SZWN0KHVuaXRzLmdhbWVUb1B4KHJlY3QubGVmdCksIHVuaXRzLmdhbWVUb1B4KHJlY3QudG9wKSwgdW5pdHMuZ2FtZVRvUHgocmVjdC53KSwgdW5pdHMuZ2FtZVRvUHgocmVjdC5oKSk7XG4gIGlmIChmaWxsKSB7XG4gICAgcmV0dXJuIHNjcmVlbi5kcmF3UmVjdChwYWludFJlY3QsICdyZWQnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2NyZWVuLmRyYXdCb3gocGFpbnRSZWN0LCAncmVkJyk7XG4gIH1cbn07XG5mdW5jdGlvbiBiaW5kJChvYmosIGtleSwgdGFyZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiAodGFyZ2V0IHx8IG9iailba2V5XS5hcHBseShvYmosIGFyZ3VtZW50cykgfTtcbn0iLCJ2YXIgc3RkLCB1bml0cywgZGl2LCB0aWxlVG9HYW1lLCB0cHgsIGdhbWVUb1B4LCBrSGFsZlRpbGUsIFRpbWVyLCByZWYkLCBTcHJpdGUsIE51bWJlclNwcml0ZSwgVmFyeWluZ1dpZHRoU3ByaXRlLCBrRHJhd1ksIGtMdkRyYXdYLCBrQmFyRHJhd1gsIGtMdmxOdW1EcmF3WCwga0ZsYXNoVGltZSwga0ZsYXNoUGVyaW9kLCBrU3ByaXRlTmFtZSwga0JhclNyY1dpZHRoLCBrQmFyU3JjSGVpZ2h0LCBrQmFyU3JjWCwga0JhclNyY1ksIGtGbGFzaFNyY1gsIGtGbGFzaFNyY1ksIGtNYXhTcmNYLCBrTWF4U3JjWSwga0ZpbGxTcmNYLCBrRmlsbFNyY1ksIGtMdmxTcmNYLCBrTHZsU3JjWSwga0x2bFNyY1dpZHRoLCBrTHZsU3JjSGVpZ2h0LCBHdW5FeHBlcmllbmNlSFVELCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG51bml0cyA9IHJlcXVpcmUoJy4vdW5pdHMnKTtcbmRpdiA9IHN0ZC5kaXY7XG50aWxlVG9HYW1lID0gdW5pdHMudGlsZVRvR2FtZSwgdHB4ID0gdW5pdHMudGlsZVRvUHgsIGdhbWVUb1B4ID0gdW5pdHMuZ2FtZVRvUHgsIGtIYWxmVGlsZSA9IHVuaXRzLmtIYWxmVGlsZTtcblRpbWVyID0gcmVxdWlyZSgnLi90aW1lcicpLlRpbWVyO1xucmVmJCA9IHJlcXVpcmUoJy4vc3ByaXRlJyksIFNwcml0ZSA9IHJlZiQuU3ByaXRlLCBOdW1iZXJTcHJpdGUgPSByZWYkLk51bWJlclNwcml0ZSwgVmFyeWluZ1dpZHRoU3ByaXRlID0gcmVmJC5WYXJ5aW5nV2lkdGhTcHJpdGU7XG5rRHJhd1kgPSB0aWxlVG9HYW1lKDEuNSk7XG5rTHZEcmF3WCA9IHRpbGVUb0dhbWUoMS4wKTtcbmtCYXJEcmF3WCA9IHRpbGVUb0dhbWUoMi41KTtcbmtMdmxOdW1EcmF3WCA9IHRpbGVUb0dhbWUoMi4wKTtcbmtGbGFzaFRpbWUgPSA4MDA7XG5rRmxhc2hQZXJpb2QgPSA0MDtcbmtTcHJpdGVOYW1lID0gJ1RleHRCb3gnO1xua0JhclNyY1dpZHRoID0gMi41O1xua0JhclNyY0hlaWdodCA9IDAuNTtcbmtCYXJTcmNYID0gMC4wO1xua0JhclNyY1kgPSA0LjU7XG5rRmxhc2hTcmNYID0gMi41O1xua0ZsYXNoU3JjWSA9IDUuMDtcbmtNYXhTcmNYID0gMi41O1xua01heFNyY1kgPSA0LjU7XG5rRmlsbFNyY1ggPSAwLjA7XG5rRmlsbFNyY1kgPSA1LjA7XG5rTHZsU3JjWCA9IHRpbGVUb0dhbWUoNSk7XG5rTHZsU3JjWSA9IDE2MDtcbmtMdmxTcmNXaWR0aCA9IHRpbGVUb0dhbWUoMSk7XG5rTHZsU3JjSGVpZ2h0ID0gdGlsZVRvR2FtZSgwLjUpO1xub3V0JC5HdW5FeHBlcmllbmNlSFVEID0gR3VuRXhwZXJpZW5jZUhVRCA9IChmdW5jdGlvbigpe1xuICBHdW5FeHBlcmllbmNlSFVELmRpc3BsYXlOYW1lID0gJ0d1bkV4cGVyaWVuY2VIVUQnO1xuICB2YXIgcHJvdG90eXBlID0gR3VuRXhwZXJpZW5jZUhVRC5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gR3VuRXhwZXJpZW5jZUhVRDtcbiAgZnVuY3Rpb24gR3VuRXhwZXJpZW5jZUhVRChncmFwaGljcywgbGV2ZWxYcCwgbWF4WHApe1xuICAgIHRoaXMueHBCYXJTcHJpdGUgPSBuZXcgU3ByaXRlKGdyYXBoaWNzLCBrU3ByaXRlTmFtZSwgdHB4KGtCYXJTcmNYKSwgdHB4KGtCYXJTcmNZKSwgdHB4KGtCYXJTcmNXaWR0aCksIHRweChrQmFyU3JjSGVpZ2h0KSk7XG4gICAgdGhpcy5sdlNwcml0ZSA9IG5ldyBTcHJpdGUoZ3JhcGhpY3MsIGtTcHJpdGVOYW1lLCBnYW1lVG9QeChrTHZsU3JjWCksIGdhbWVUb1B4KGtMdmxTcmNZKSwgZ2FtZVRvUHgoa0x2bFNyY1dpZHRoKSwgZ2FtZVRvUHgoa0x2bFNyY0hlaWdodCkpO1xuICAgIHRoaXMuZmxhc2hTcHJpdGUgPSBuZXcgU3ByaXRlKGdyYXBoaWNzLCBrU3ByaXRlTmFtZSwgdHB4KGtGbGFzaFNyY1gpLCB0cHgoa0ZsYXNoU3JjWSksIHRweChrQmFyU3JjV2lkdGgpLCB0cHgoa0JhclNyY0hlaWdodCkpO1xuICAgIHRoaXMubWF4U3ByaXRlID0gbmV3IFNwcml0ZShncmFwaGljcywga1Nwcml0ZU5hbWUsIHRweChrTWF4U3JjWCksIHRweChrTWF4U3JjWSksIHRweChrQmFyU3JjV2lkdGgpLCB0cHgoa0JhclNyY0hlaWdodCkpO1xuICAgIHRoaXMuZmlsbFNwcml0ZSA9IG5ldyBWYXJ5aW5nV2lkdGhTcHJpdGUoZ3JhcGhpY3MsIGtTcHJpdGVOYW1lLCB0cHgoa0ZpbGxTcmNYKSwgdHB4KGtGaWxsU3JjWSksIHRweChrQmFyU3JjV2lkdGgpLCB0cHgoa0JhclNyY0hlaWdodCkpO1xuICAgIHRoaXMuZmxhc2hUaW1lciA9IG5ldyBUaW1lcihrRmxhc2hUaW1lKTtcbiAgfVxuICBwcm90b3R5cGUuYWN0aXZhdGVGbGFzaCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuZmxhc2hUaW1lci5yZXNldCgpO1xuICB9O1xuICBwcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGdyYXBoaWNzLCBndW5MdmwsIGN1cnJlbnRYcCwgbGV2ZWxYcCl7XG4gICAgdGhpcy5sdlNwcml0ZS5kcmF3KGdyYXBoaWNzLCBrTHZEcmF3WCwga0RyYXdZKTtcbiAgICB0aGlzLnhwQmFyU3ByaXRlLmRyYXcoZ3JhcGhpY3MsIGtCYXJEcmF3WCwga0RyYXdZKTtcbiAgICBOdW1iZXJTcHJpdGUuSFVETnVtYmVyKGdyYXBoaWNzLCBndW5MdmwsIDEpLmRyYXcoZ3JhcGhpY3MsIGtMdmxOdW1EcmF3WCwga0RyYXdZKTtcbiAgICBpZiAoY3VycmVudFhwIDwgbGV2ZWxYcCkge1xuICAgICAgdGhpcy5maWxsU3ByaXRlLnNldFBlcmNlbnRhZ2VXaWR0aChjdXJyZW50WHAgLyBsZXZlbFhwKTtcbiAgICAgIHRoaXMuZmlsbFNwcml0ZS5kcmF3KGdyYXBoaWNzLCBrQmFyRHJhd1gsIGtEcmF3WSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWF4U3ByaXRlLmRyYXcoZ3JhcGhpY3MsIGtCYXJEcmF3WCwga0RyYXdZKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZmxhc2hUaW1lci5pc0FjdGl2ZSAmJiBkaXYodGhpcy5mbGFzaFRpbWVyLmN1cnJlbnRUaW1lLCBrRmxhc2hQZXJpb2QpICUgMiA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmxhc2hTcHJpdGUuZHJhdyhncmFwaGljcywga0JhckRyYXdYLCBrRHJhd1kpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIEd1bkV4cGVyaWVuY2VIVUQ7XG59KCkpOyIsInZhciBzdGQsIHVuaXRzLCBweCwgVGltZXIsIFBhcnRpY2xlLCBTcHJpdGUsIFBvbGFyVmVjdG9yLCBSZWN0YW5nbGUsIGtGbGFzaFBlcmlvZCwga0xpZmVUaW1lLCBrU3BlZWQsIEhlYWRCdW1wUGFydGljbGUsIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5zdGQgPSByZXF1aXJlKCdzdGQnKTtcbnVuaXRzID0gcmVxdWlyZSgnLi91bml0cycpO1xucHggPSB1bml0cy5nYW1lVG9QeDtcblRpbWVyID0gcmVxdWlyZSgnLi90aW1lcicpLlRpbWVyO1xuUGFydGljbGUgPSByZXF1aXJlKCcuL3BhcnRpY2xlJykuUGFydGljbGU7XG5TcHJpdGUgPSByZXF1aXJlKCcuL3Nwcml0ZScpLlNwcml0ZTtcblBvbGFyVmVjdG9yID0gcmVxdWlyZSgnLi9wb2xhcicpLlBvbGFyVmVjdG9yO1xuUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi9yZWN0YW5nbGUnKS5SZWN0YW5nbGU7XG5rRmxhc2hQZXJpb2QgPSAyNTtcbmtMaWZlVGltZSA9IDcwMDtcbmtTcGVlZCA9IDAuMTI7XG5vdXQkLkhlYWRCdW1wUGFydGljbGUgPSBIZWFkQnVtcFBhcnRpY2xlID0gKGZ1bmN0aW9uKHN1cGVyY2xhc3Mpe1xuICB2YXIgcHJvdG90eXBlID0gZXh0ZW5kJCgoaW1wb3J0JChIZWFkQnVtcFBhcnRpY2xlLCBzdXBlcmNsYXNzKS5kaXNwbGF5TmFtZSA9ICdIZWFkQnVtcFBhcnRpY2xlJywgSGVhZEJ1bXBQYXJ0aWNsZSksIHN1cGVyY2xhc3MpLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBIZWFkQnVtcFBhcnRpY2xlO1xuICBmdW5jdGlvbiBIZWFkQnVtcFBhcnRpY2xlKGdyYXBoaWNzLCBjZW50ZXJYLCBjZW50ZXJZKXtcbiAgICB0aGlzLmNlbnRlclggPSBjZW50ZXJYO1xuICAgIHRoaXMuY2VudGVyWSA9IGNlbnRlclk7XG4gICAgdGhpcy5saWZlVGltZXIgPSBuZXcgVGltZXIoa0xpZmVUaW1lLCB0cnVlKTtcbiAgICB0aGlzLnBhcnRpY2xlQSA9IG5ldyBQb2xhclZlY3RvcigwLCBzdGQucmFuZCgwLCBzdGQudGF1KSk7XG4gICAgdGhpcy5wYXJ0aWNsZUIgPSBuZXcgUG9sYXJWZWN0b3IoMCwgc3RkLnJhbmQoMCwgc3RkLnRhdSkpO1xuICAgIHRoaXMubWF4T2Zmc2V0QSA9IHN0ZC5mbG9vcihzdGQucmFuZCg0LCAyMCkpO1xuICAgIHRoaXMubWF4T2Zmc2V0QiA9IHN0ZC5mbG9vcihzdGQucmFuZCg0LCAyMCkpO1xuICAgIHRoaXMuc3ByaXRlID0gbmV3IFNwcml0ZShncmFwaGljcywgJ0NhcmV0JywgcHgoMTE2KSwgcHgoNTQpLCBweCg2KSwgcHgoNikpO1xuICB9XG4gIHByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihlbGFwc2VkVGltZSl7XG4gICAgdGhpcy5wYXJ0aWNsZUEubWFnID0gc3RkLm1pbih0aGlzLm1heE9mZnNldEEsIHRoaXMucGFydGljbGVBLm1hZyArIGVsYXBzZWRUaW1lICoga1NwZWVkKTtcbiAgICB0aGlzLnBhcnRpY2xlQi5tYWcgPSBzdGQubWluKHRoaXMubWF4T2Zmc2V0QiwgdGhpcy5wYXJ0aWNsZUIubWFnICsgZWxhcHNlZFRpbWUgKiBrU3BlZWQpO1xuICAgIHJldHVybiB0aGlzLmxpZmVUaW1lci5hY3RpdmUoKTtcbiAgfTtcbiAgcHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihncmFwaGljcyl7XG4gICAgaWYgKCh0aGlzLmxpZmVUaW1lci5jdXJyZW50VGltZSAvIGtGbGFzaFBlcmlvZCkgJSAyIDwgMSkge1xuICAgICAgdGhpcy5zcHJpdGUuZHJhdyhncmFwaGljcywgdGhpcy5jZW50ZXJYICsgdGhpcy5wYXJ0aWNsZUEueCwgdGhpcy5jZW50ZXJZICsgdGhpcy5wYXJ0aWNsZUEueSk7XG4gICAgICByZXR1cm4gdGhpcy5zcHJpdGUuZHJhdyhncmFwaGljcywgdGhpcy5jZW50ZXJYICsgdGhpcy5wYXJ0aWNsZUIueCwgdGhpcy5jZW50ZXJZICsgdGhpcy5wYXJ0aWNsZUIueSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gSGVhZEJ1bXBQYXJ0aWNsZTtcbn0oUGFydGljbGUpKTtcbmZ1bmN0aW9uIGV4dGVuZCQoc3ViLCBzdXApe1xuICBmdW5jdGlvbiBmdW4oKXt9IGZ1bi5wcm90b3R5cGUgPSAoc3ViLnN1cGVyY2xhc3MgPSBzdXApLnByb3RvdHlwZTtcbiAgKHN1Yi5wcm90b3R5cGUgPSBuZXcgZnVuKS5jb25zdHJ1Y3RvciA9IHN1YjtcbiAgaWYgKHR5cGVvZiBzdXAuZXh0ZW5kZWQgPT0gJ2Z1bmN0aW9uJykgc3VwLmV4dGVuZGVkKHN1Yik7XG4gIHJldHVybiBzdWI7XG59XG5mdW5jdGlvbiBpbXBvcnQkKG9iaiwgc3JjKXtcbiAgdmFyIG93biA9IHt9Lmhhc093blByb3BlcnR5O1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSBpZiAob3duLmNhbGwoc3JjLCBrZXkpKSBvYmpba2V5XSA9IHNyY1trZXldO1xuICByZXR1cm4gb2JqO1xufSIsInZhciBzdGQsIHVuaXRzLCBkaXYsIGtIYWxmVGlsZSwgcHhUb1RpbGUsIHRweCwgcHhUb0dhbWUsIHRpbGVUb0dhbWUsIFRpbWVyLCByZWYkLCBTcHJpdGUsIE51bWJlclNwcml0ZSwgVmFyeWluZ1dpZHRoU3ByaXRlLCBrSGVhbHRoQmFyWCwga0hlYWx0aEJhclksIGtIZWFsdGhGaWxsWCwga0hlYWx0aEZpbGxZLCBrSGVhbHRoTnVtWCwga0hlYWx0aE51bVksIGtNYXhGaWxsUHgsIGtEYW1hZ2VEZWxheSwga1Nwcml0ZVBhdGgsIGtCYXJTcmNYLCBrQmFyU3JjWSwga0ZpbGxTcmNZLCBrRGFtYWdlU3JjWSwga0JhclNyY1dpZHRoLCBrQmFyU3JjSGVpZ2h0LCBIZWFsdGgsIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5zdGQgPSByZXF1aXJlKCdzdGQnKTtcbnVuaXRzID0gcmVxdWlyZSgnLi91bml0cycpO1xuZGl2ID0gc3RkLmRpdjtcbmtIYWxmVGlsZSA9IHVuaXRzLmtIYWxmVGlsZSwgcHhUb1RpbGUgPSB1bml0cy5weFRvVGlsZSwgdHB4ID0gdW5pdHMudGlsZVRvUHgsIHB4VG9HYW1lID0gdW5pdHMucHhUb0dhbWUsIHRpbGVUb0dhbWUgPSB1bml0cy50aWxlVG9HYW1lO1xuVGltZXIgPSByZXF1aXJlKCcuL3RpbWVyJykuVGltZXI7XG5yZWYkID0gcmVxdWlyZSgnLi9zcHJpdGUnKSwgU3ByaXRlID0gcmVmJC5TcHJpdGUsIE51bWJlclNwcml0ZSA9IHJlZiQuTnVtYmVyU3ByaXRlLCBWYXJ5aW5nV2lkdGhTcHJpdGUgPSByZWYkLlZhcnlpbmdXaWR0aFNwcml0ZTtcbmtIZWFsdGhCYXJYID0gdGlsZVRvR2FtZSgxKTtcbmtIZWFsdGhCYXJZID0gdGlsZVRvR2FtZSgyKTtcbmtIZWFsdGhGaWxsWCA9IHRpbGVUb0dhbWUoMi41KTtcbmtIZWFsdGhGaWxsWSA9IHRpbGVUb0dhbWUoMik7XG5rSGVhbHRoTnVtWCA9IHRpbGVUb0dhbWUoMS41KTtcbmtIZWFsdGhOdW1ZID0gdGlsZVRvR2FtZSgyKTtcbmtNYXhGaWxsUHggPSB0cHgoMi41KSAtIDE7XG5rRGFtYWdlRGVsYXkgPSAxNTAwO1xua1Nwcml0ZVBhdGggPSAnVGV4dEJveCc7XG5rQmFyU3JjWCA9IDA7XG5rQmFyU3JjWSA9IDIuNTtcbmtGaWxsU3JjWSA9IDEuNTtcbmtEYW1hZ2VTcmNZID0gMjtcbmtCYXJTcmNXaWR0aCA9IDQ7XG5rQmFyU3JjSGVpZ2h0ID0gMC41O1xub3V0JC5IZWFsdGggPSBIZWFsdGggPSAoZnVuY3Rpb24oKXtcbiAgSGVhbHRoLmRpc3BsYXlOYW1lID0gJ0hlYWx0aCc7XG4gIHZhciBwcm90b3R5cGUgPSBIZWFsdGgucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IEhlYWx0aDtcbiAgZnVuY3Rpb24gSGVhbHRoKGdyYXBoaWNzLCBtYXhIZWFsdGgpe1xuICAgIHRoaXMubWF4SGVhbHRoID0gbWF4SGVhbHRoICE9IG51bGwgPyBtYXhIZWFsdGggOiA2O1xuICAgIHRoaXMuY3VycmVudEhlYWx0aCA9IHRoaXMubWF4SGVhbHRoO1xuICAgIHRoaXMuZGFtYWdlID0gMDtcbiAgICB0aGlzLmRhbWFnZVRpbWVyID0gbmV3IFRpbWVyKGtEYW1hZ2VEZWxheSk7XG4gICAgdGhpcy5oZWFsdGhCYXJTcHJpdGUgPSBuZXcgU3ByaXRlKGdyYXBoaWNzLCBrU3ByaXRlUGF0aCwgdHB4KGtCYXJTcmNYKSwgdHB4KGtCYXJTcmNZKSwgdHB4KGtCYXJTcmNXaWR0aCksIHRweChrQmFyU3JjSGVpZ2h0KSk7XG4gICAgdGhpcy5oZWFsdGhGaWxsU3ByaXRlID0gbmV3IFZhcnlpbmdXaWR0aFNwcml0ZShncmFwaGljcywga1Nwcml0ZVBhdGgsIHRweChrQmFyU3JjWCksIHRweChrRmlsbFNyY1kpLCBrTWF4RmlsbFB4LCB0cHgoa0JhclNyY0hlaWdodCksIGtNYXhGaWxsUHgpO1xuICAgIHRoaXMuZGFtYWdlRmlsbFNwcml0ZSA9IG5ldyBWYXJ5aW5nV2lkdGhTcHJpdGUoZ3JhcGhpY3MsIGtTcHJpdGVQYXRoLCB0cHgoa0JhclNyY1gpLCB0cHgoa0RhbWFnZVNyY1kpLCBrTWF4RmlsbFB4LCB0cHgoa0JhclNyY0hlaWdodCksIGtNYXhGaWxsUHgpO1xuICB9XG4gIHByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihlbGFwc2VkVGltZSl7XG4gICAgaWYgKHRoaXMuZGFtYWdlID4gMCAmJiB0aGlzLmRhbWFnZVRpbWVyLmlzRXhwaXJlZCkge1xuICAgICAgdGhpcy5jdXJyZW50SGVhbHRoID0gc3RkLm1heCgwLCB0aGlzLmN1cnJlbnRIZWFsdGggLSB0aGlzLmRhbWFnZSk7XG4gICAgICByZXR1cm4gdGhpcy5kYW1hZ2UgPSAwO1xuICAgIH1cbiAgfTtcbiAgcHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihncmFwaGljcyl7XG4gICAgdGhpcy5oZWFsdGhCYXJTcHJpdGUuZHJhdyhncmFwaGljcywga0hlYWx0aEJhclgsIGtIZWFsdGhCYXJZKTtcbiAgICBpZiAodGhpcy5jdXJyZW50SGVhbHRoICE9PSAwKSB7XG4gICAgICBpZiAodGhpcy5kYW1hZ2UpIHtcbiAgICAgICAgdGhpcy5kYW1hZ2VGaWxsU3ByaXRlLmRyYXcoZ3JhcGhpY3MsIGtIZWFsdGhGaWxsWCwga0hlYWx0aEZpbGxZKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGVhbHRoRmlsbFNwcml0ZS5kcmF3KGdyYXBoaWNzLCBrSGVhbHRoRmlsbFgsIGtIZWFsdGhGaWxsWSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTnVtYmVyU3ByaXRlLkhVRE51bWJlcihncmFwaGljcywgdGhpcy5jdXJyZW50SGVhbHRoLCAyKS5kcmF3KGdyYXBoaWNzLCBrSGVhbHRoTnVtWCwga0hlYWx0aE51bVkpO1xuICB9O1xuICBwcm90b3R5cGUudGFrZURhbWFnZSA9IGZ1bmN0aW9uKGRhbWFnZSl7XG4gICAgaWYgKHRoaXMuY3VycmVudEhlYWx0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRhbWFnZVRpbWVyLnJlc2V0KCk7XG4gICAgdGhpcy5oZWFsdGhGaWxsU3ByaXRlLnNldFBlcmNlbnRhZ2VXaWR0aCgodGhpcy5jdXJyZW50SGVhbHRoIC0gZGFtYWdlKSAvIHRoaXMubWF4SGVhbHRoKTtcbiAgICB0aGlzLmRhbWFnZUZpbGxTcHJpdGUuc2V0UGVyY2VudGFnZVdpZHRoKHRoaXMuY3VycmVudEhlYWx0aCAvIHRoaXMubWF4SGVhbHRoKTtcbiAgICB0aGlzLmRhbWFnZSA9IGRhbWFnZTtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50SGVhbHRoIC0gZGFtYWdlIDw9IDA7XG4gIH07XG4gIHJldHVybiBIZWFsdGg7XG59KCkpOyIsInZhciBzdGQsIEFuaW1hdGVkU3ByaXRlLCBJbW1vYmlsZVNpbmdsZUxvb3BQYXJ0aWNsZSwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcbnN0ZCA9IHJlcXVpcmUoJ3N0ZCcpO1xuQW5pbWF0ZWRTcHJpdGUgPSByZXF1aXJlKCcuL3Nwcml0ZScpLkFuaW1hdGVkU3ByaXRlO1xub3V0JC5JbW1vYmlsZVNpbmdsZUxvb3BQYXJ0aWNsZSA9IEltbW9iaWxlU2luZ2xlTG9vcFBhcnRpY2xlID0gKGZ1bmN0aW9uKCl7XG4gIEltbW9iaWxlU2luZ2xlTG9vcFBhcnRpY2xlLmRpc3BsYXlOYW1lID0gJ0ltbW9iaWxlU2luZ2xlTG9vcFBhcnRpY2xlJztcbiAgdmFyIHByb3RvdHlwZSA9IEltbW9iaWxlU2luZ2xlTG9vcFBhcnRpY2xlLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBJbW1vYmlsZVNpbmdsZUxvb3BQYXJ0aWNsZTtcbiAgZnVuY3Rpb24gSW1tb2JpbGVTaW5nbGVMb29wUGFydGljbGUoZ3JhcGhpY3MsIHgsIHksIHNwcml0ZVBhdGgsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIGZwcywgZnJhbWVzKXtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy5zcHJpdGUgPSBuZXcgQW5pbWF0ZWRTcHJpdGUoZ3JhcGhpY3MsIHNwcml0ZVBhdGgsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIGZwcywgZnJhbWVzKTtcbiAgfVxuICBwcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oZWxhcHNlZFRpbWUpe1xuICAgIHRoaXMuc3ByaXRlLnVwZGF0ZShlbGFwc2VkVGltZSk7XG4gICAgcmV0dXJuIHRoaXMuc3ByaXRlLm51bUNvbXBsZXRlZExvb3BzID09PSAwO1xuICB9O1xuICBwcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGdyYXBoaWNzKXtcbiAgICByZXR1cm4gdGhpcy5zcHJpdGUuZHJhdyhncmFwaGljcywgdGhpcy54LCB0aGlzLnkpO1xuICB9O1xuICByZXR1cm4gSW1tb2JpbGVTaW5nbGVMb29wUGFydGljbGU7XG59KCkpOyIsInZhciBzdGQsIElucHV0O1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG5JbnB1dCA9IChmdW5jdGlvbigpe1xuICBJbnB1dC5kaXNwbGF5TmFtZSA9ICdJbnB1dCc7XG4gIHZhciBwcm90b3R5cGUgPSBJbnB1dC5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gSW5wdXQ7XG4gIGZ1bmN0aW9uIElucHV0KCl7XG4gICAgdGhpcy5oZWxkS2V5cyA9IHt9O1xuICAgIHRoaXMucHJlc3NlZEtleXMgPSB7fTtcbiAgICB0aGlzLnJlbGVhc2VkS2V5cyA9IHt9O1xuICB9XG4gIHByb3RvdHlwZS5iZWdpbk5ld0ZyYW1lID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLnByZXNzZWRLZXlzID0ge307XG4gICAgcmV0dXJuIHRoaXMucmVsZWFzZWRLZXlzID0ge307XG4gIH07XG4gIHByb3RvdHlwZS5rZXlEb3duRXZlbnQgPSBmdW5jdGlvbihldmVudCl7XG4gICAgdGhpcy5wcmVzc2VkS2V5c1tldmVudC5rZXldID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5oZWxkS2V5c1tldmVudC5rZXldID0gdHJ1ZTtcbiAgfTtcbiAgcHJvdG90eXBlLmtleVVwRXZlbnQgPSBmdW5jdGlvbihldmVudCl7XG4gICAgdGhpcy5yZWxlYXNlZEtleXNbZXZlbnQua2V5XSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMuaGVsZEtleXNbZXZlbnQua2V5XSA9IGZhbHNlO1xuICB9O1xuICBwcm90b3R5cGUud2FzS2V5UHJlc3NlZCA9IGZ1bmN0aW9uKGtleSl7XG4gICAgcmV0dXJuIHRoaXMucHJlc3NlZEtleXNba2V5XTtcbiAgfTtcbiAgcHJvdG90eXBlLndhc0tleVJlbGVhc2VkID0gZnVuY3Rpb24oa2V5KXtcbiAgICByZXR1cm4gdGhpcy5yZWxlYXNlZEtleXNba2V5XTtcbiAgfTtcbiAgcHJvdG90eXBlLmlzS2V5SGVsZCA9IGZ1bmN0aW9uKGtleSl7XG4gICAgcmV0dXJuIHRoaXMuaGVsZEtleXNba2V5XTtcbiAgfTtcbiAgcmV0dXJuIElucHV0O1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gbmV3IElucHV0OyIsInZhciBzdGQsIHVuaXRzLCBLaW5lbWF0aWNzLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG51bml0cyA9IHJlcXVpcmUoJy4vdW5pdHMnKTtcbm91dCQuS2luZW1hdGljcyA9IEtpbmVtYXRpY3MgPSAoZnVuY3Rpb24oKXtcbiAgS2luZW1hdGljcy5kaXNwbGF5TmFtZSA9ICdLaW5lbWF0aWNzJztcbiAgdmFyIHByb3RvdHlwZSA9IEtpbmVtYXRpY3MucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IEtpbmVtYXRpY3M7XG4gIGZ1bmN0aW9uIEtpbmVtYXRpY3MocG9zaXRpb24sIHZlbG9jaXR5KXtcbiAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgdGhpcy52ZWxvY2l0eSA9IHZlbG9jaXR5O1xuICB9XG4gIHByb3RvdHlwZS5kZWx0YSA9IGZ1bmN0aW9uKGVsYXBzZWRUaW1lKXtcbiAgICByZXR1cm4gdGhpcy52ZWxvY2l0eSAqIGVsYXBzZWRUaW1lO1xuICB9O1xuICByZXR1cm4gS2luZW1hdGljcztcbn0oKSk7IiwidmFyIHN0ZCwgdW5pdHMsIEludGVyZmFjZUVycm9yLCBXQUxMX1RJTEUsIHJlZiQsIFRPUCwgQk9UVE9NLCBMRUZULCBSSUdIVCwgU2lkZSwgdG9wQm94LCBsZWZ0Qm94LCByaWdodEJveCwgYm90dG9tQm94LCBNYXBDb2xsaWRhYmxlLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG51bml0cyA9IHJlcXVpcmUoJy4vdW5pdHMnKTtcbkludGVyZmFjZUVycm9yID0gc3RkLkludGVyZmFjZUVycm9yO1xuV0FMTF9USUxFID0gcmVxdWlyZSgnLi9tYXAnKS5XQUxMX1RJTEU7XG5yZWYkID0gc3RkWydlbnVtJ10sIFRPUCA9IHJlZiRbMF0sIEJPVFRPTSA9IHJlZiRbMV0sIExFRlQgPSByZWYkWzJdLCBSSUdIVCA9IHJlZiRbM107XG5vdXQkLlNpZGUgPSBTaWRlID0ge1xuICBUT1A6IFRPUCxcbiAgQk9UVE9NOiBCT1RUT00sXG4gIExFRlQ6IExFRlQsXG4gIFJJR0hUOiBSSUdIVFxufTtcbnRvcEJveCA9IGZ1bmN0aW9uKHJlY3QsIHgsIHksIM6UKXtcbiAgcmV0dXJuIHJlY3QudG9wQ29sbGlzaW9uKHgucG9zaXRpb24sIHkucG9zaXRpb24sIM6UKTtcbn07XG5sZWZ0Qm94ID0gZnVuY3Rpb24ocmVjdCwgeCwgeSwgzpQpe1xuICByZXR1cm4gcmVjdC5sZWZ0Q29sbGlzaW9uKHgucG9zaXRpb24sIHkucG9zaXRpb24sIM6UKTtcbn07XG5yaWdodEJveCA9IGZ1bmN0aW9uKHJlY3QsIHgsIHksIM6UKXtcbiAgcmV0dXJuIHJlY3QucmlnaHRDb2xsaXNpb24oeC5wb3NpdGlvbiwgeS5wb3NpdGlvbiwgzpQpO1xufTtcbmJvdHRvbUJveCA9IGZ1bmN0aW9uKHJlY3QsIHgsIHksIM6UKXtcbiAgcmV0dXJuIHJlY3QuYm90dG9tQ29sbGlzaW9uKHgucG9zaXRpb24sIHkucG9zaXRpb24sIM6UKTtcbn07XG5vdXQkLk1hcENvbGxpZGFibGUgPSBNYXBDb2xsaWRhYmxlID0gKGZ1bmN0aW9uKCl7XG4gIE1hcENvbGxpZGFibGUuZGlzcGxheU5hbWUgPSAnTWFwQ29sbGlkYWJsZSc7XG4gIHZhciBwcm90b3R5cGUgPSBNYXBDb2xsaWRhYmxlLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBNYXBDb2xsaWRhYmxlO1xuICBmdW5jdGlvbiBNYXBDb2xsaWRhYmxlKCl7fVxuICBwcm90b3R5cGUub25Db2xsaXNpb24gPSBmdW5jdGlvbigpe1xuICAgIHRocm93IG5ldyBJbnRlcmZhY2VFcnJvcihcIk1hcENvbGxpZGFibGUgLSBgb24tY29sbGlzaW9uYCBtZXRob2Qgbm90IGltcGxlbWVudGVkXCIpO1xuICB9O1xuICBwcm90b3R5cGUub25EZWx0YSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhyb3cgbmV3IEludGVyZmFjZUVycm9yKFwiTWFwQ29sbGlkYWJsZSAtIGBvbi1kZWx0YWAgbWV0aG9kIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfTtcbiAgcHJvdG90eXBlLm9uV2FsbENvbGxpc2lvbiA9IGZ1bmN0aW9uKG1hcCwgcmVjdCwgzrspe1xuICAgIHZhciBpJCwgcmVmJCwgbGVuJCwgdGlsZTtcbiAgICBmb3IgKGkkID0gMCwgbGVuJCA9IChyZWYkID0gbWFwLmdldENvbGxpZGluZ1RpbGVzKHJlY3QpKS5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgICAgdGlsZSA9IHJlZiRbaSRdO1xuICAgICAgaWYgKHRpbGUudHlwZSA9PT0gV0FMTF9USUxFKSB7XG4gICAgICAgIHJldHVybiDOuy5jYWxsKHRoaXMsIHRpbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gzrsuY2FsbCh0aGlzKTtcbiAgfTtcbiAgcHJvdG90eXBlLnVwZGF0ZVggPSBmdW5jdGlvbihyZWN0LCBhY2MsIGt4LCBreSwgZWxhcHNlZFRpbWUsIG1hcCl7XG4gICAgdmFyIM6UeDtcbiAgICBhY2MudXBkYXRlVmVsb2NpdHkoa3gsIGVsYXBzZWRUaW1lKTtcbiAgICDOlHggPSBreC52ZWxvY2l0eSAqIGVsYXBzZWRUaW1lO1xuICAgIGlmICjOlHggPiAwKSB7XG4gICAgICB0aGlzLm9uV2FsbENvbGxpc2lvbihtYXAsIHJpZ2h0Qm94KHJlY3QsIGt4LCBreSwgzpR4KSwgZnVuY3Rpb24odGlsZSl7XG4gICAgICAgIGlmICh0aWxlKSB7XG4gICAgICAgICAga3gucG9zaXRpb24gPSB1bml0cy50aWxlVG9HYW1lKHRpbGUuY29sKSAtIHJlY3QuYm91bmRpbmdCb3gucmlnaHQ7XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25Db2xsaXNpb24oU2lkZS5SSUdIVCwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga3gucG9zaXRpb24gKz0gzpR4O1xuICAgICAgICAgIHJldHVybiB0aGlzLm9uRGVsdGEoU2lkZS5SSUdIVCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMub25XYWxsQ29sbGlzaW9uKG1hcCwgbGVmdEJveChyZWN0LCBreCwga3ksIDApLCBmdW5jdGlvbih0aWxlKXtcbiAgICAgICAgaWYgKHRpbGUpIHtcbiAgICAgICAgICBreC5wb3NpdGlvbiA9IHVuaXRzLnRpbGVUb0dhbWUodGlsZS5jb2wgKyAxKSAtIHJlY3QuYm91bmRpbmdCb3gubGVmdDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vbkNvbGxpc2lvbihTaWRlLkxFRlQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub25XYWxsQ29sbGlzaW9uKG1hcCwgbGVmdEJveChyZWN0LCBreCwga3ksIM6UeCksIGZ1bmN0aW9uKHRpbGUpe1xuICAgICAgICBpZiAodGlsZSkge1xuICAgICAgICAgIGt4LnBvc2l0aW9uID0gdW5pdHMudGlsZVRvR2FtZSh0aWxlLmNvbCArIDEpIC0gcmVjdC5ib3VuZGluZ0JveC5sZWZ0O1xuICAgICAgICAgIHJldHVybiB0aGlzLm9uQ29sbGlzaW9uKFNpZGUuTEVGVCwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga3gucG9zaXRpb24gKz0gzpR4O1xuICAgICAgICAgIHJldHVybiB0aGlzLm9uRGVsdGEoU2lkZS5MRUZUKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5vbldhbGxDb2xsaXNpb24obWFwLCByaWdodEJveChyZWN0LCBreCwga3ksIDApLCBmdW5jdGlvbih0aWxlKXtcbiAgICAgICAgaWYgKHRpbGUpIHtcbiAgICAgICAgICBreC5wb3NpdGlvbiA9IHVuaXRzLnRpbGVUb0dhbWUodGlsZS5jb2wpIC0gcmVjdC5ib3VuZGluZ0JveC5yaWdodDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vbkNvbGxpc2lvbihTaWRlLlJJR0hULCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgcHJvdG90eXBlLnVwZGF0ZVkgPSBmdW5jdGlvbihyZWN0LCBhY2MsIGt4LCBreSwgZWxhcHNlZFRpbWUsIG1hcCl7XG4gICAgdmFyIM6UeTtcbiAgICBhY2MudXBkYXRlVmVsb2NpdHkoa3ksIGVsYXBzZWRUaW1lKTtcbiAgICDOlHkgPSBreS52ZWxvY2l0eSAqIGVsYXBzZWRUaW1lO1xuICAgIGlmICjOlHkgPiAwKSB7XG4gICAgICB0aGlzLm9uV2FsbENvbGxpc2lvbihtYXAsIGJvdHRvbUJveChyZWN0LCBreCwga3ksIM6UeSksIGZ1bmN0aW9uKHRpbGUpe1xuICAgICAgICBpZiAodGlsZSkge1xuICAgICAgICAgIGt5LnBvc2l0aW9uID0gdW5pdHMudGlsZVRvR2FtZSh0aWxlLnJvdykgLSByZWN0LmJvdW5kaW5nQm94LmJvdHRvbTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vbkNvbGxpc2lvbihTaWRlLkJPVFRPTSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga3kucG9zaXRpb24gKz0gzpR5O1xuICAgICAgICAgIHJldHVybiB0aGlzLm9uRGVsdGEoU2lkZS5CT1RUT00pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLm9uV2FsbENvbGxpc2lvbihtYXAsIHRvcEJveChyZWN0LCBreCwga3ksIDApLCBmdW5jdGlvbih0aWxlKXtcbiAgICAgICAgaWYgKHRpbGUpIHtcbiAgICAgICAgICBreS5wb3NpdGlvbiA9IHVuaXRzLnRpbGVUb0dhbWUodGlsZS5yb3cgKyAxKSArIHJlY3QuYm91bmRpbmdCb3gudG9wO1xuICAgICAgICAgIHJldHVybiB0aGlzLm9uQ29sbGlzaW9uKFNpZGUuVE9QLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uV2FsbENvbGxpc2lvbihtYXAsIHRvcEJveChyZWN0LCBreCwga3ksIM6UeSksIGZ1bmN0aW9uKHRpbGUpe1xuICAgICAgICBpZiAodGlsZSkge1xuICAgICAgICAgIGt5LnBvc2l0aW9uID0gdW5pdHMudGlsZVRvR2FtZSh0aWxlLnJvdyArIDEpICsgcmVjdC5ib3VuZGluZ0JveC50b3A7XG4gICAgICAgICAgdGhpcy5vbkNvbGxpc2lvbihTaWRlLlRPUCwgdHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuIGt5LnBvc2l0aW9uID0gdW5pdHMudGlsZVRvR2FtZSh0aWxlLnJvdyArIDEpICsgcmVjdC5ib3VuZGluZ0JveC50b3A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga3kucG9zaXRpb24gKz0gzpR5O1xuICAgICAgICAgIHJldHVybiB0aGlzLm9uRGVsdGEoU2lkZS5UT1ApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLm9uV2FsbENvbGxpc2lvbihtYXAsIGJvdHRvbUJveChyZWN0LCBreCwga3ksIDApLCBmdW5jdGlvbih0aWxlKXtcbiAgICAgICAgaWYgKHRpbGUpIHtcbiAgICAgICAgICBreS5wb3NpdGlvbiA9IHVuaXRzLnRpbGVUb0dhbWUodGlsZS5yb3cpIC0gcmVjdC5ib3VuZGluZ0JveC5ib3R0b207XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25Db2xsaXNpb24oU2lkZS5CT1RUT00sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gTWFwQ29sbGlkYWJsZTtcbn0oKSk7IiwidmFyIHN0ZCwgdW5pdHMsIGRpdiwgdHB4LCBnYW1lVG9QeCwgdGlsZVRvR2FtZSwgU3ByaXRlLCBGaXhlZEJhY2tkcm9wLCByZWYkLCBBSVJfVElMRSwgV0FMTF9USUxFLCBrTWFwV2lkdGgsIFRpbGUsIENvbGxpc2lvblRpbGUsIE1hcDtcbnN0ZCA9IHJlcXVpcmUoJ3N0ZCcpO1xudW5pdHMgPSByZXF1aXJlKCcuL3VuaXRzJyk7XG5kaXYgPSBzdGQuZGl2O1xudHB4ID0gdW5pdHMudGlsZVRvUHgsIGdhbWVUb1B4ID0gdW5pdHMuZ2FtZVRvUHgsIHRpbGVUb0dhbWUgPSB1bml0cy50aWxlVG9HYW1lO1xuU3ByaXRlID0gcmVxdWlyZSgnLi9zcHJpdGUnKS5TcHJpdGU7XG5GaXhlZEJhY2tkcm9wID0gcmVxdWlyZSgnLi9iYWNrZHJvcCcpLkZpeGVkQmFja2Ryb3A7XG5yZWYkID0gc3RkWydlbnVtJ10sIEFJUl9USUxFID0gcmVmJFswXSwgV0FMTF9USUxFID0gcmVmJFsxXTtcbmtNYXBXaWR0aCA9IDIwO1xuVGlsZSA9IChmdW5jdGlvbigpe1xuICBUaWxlLmRpc3BsYXlOYW1lID0gJ1RpbGUnO1xuICB2YXIgcHJvdG90eXBlID0gVGlsZS5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gVGlsZTtcbiAgZnVuY3Rpb24gVGlsZSh0eXBlLCBzcHJpdGUpe1xuICAgIHRoaXMudHlwZSA9IHR5cGUgIT0gbnVsbCA/IHR5cGUgOiBBSVJfVElMRTtcbiAgICB0aGlzLnNwcml0ZSA9IHNwcml0ZTtcbiAgfVxuICByZXR1cm4gVGlsZTtcbn0oKSk7XG5Db2xsaXNpb25UaWxlID0gKGZ1bmN0aW9uKCl7XG4gIENvbGxpc2lvblRpbGUuZGlzcGxheU5hbWUgPSAnQ29sbGlzaW9uVGlsZSc7XG4gIHZhciBwcm90b3R5cGUgPSBDb2xsaXNpb25UaWxlLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBDb2xsaXNpb25UaWxlO1xuICBmdW5jdGlvbiBDb2xsaXNpb25UaWxlKHJvdywgY29sLCB0eXBlKXtcbiAgICB0aGlzLnJvdyA9IHJvdztcbiAgICB0aGlzLmNvbCA9IGNvbDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG4gIHJldHVybiBDb2xsaXNpb25UaWxlO1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gTWFwID0gKGZ1bmN0aW9uKCl7XG4gIE1hcC5kaXNwbGF5TmFtZSA9ICdNYXAnO1xuICB2YXIgcHJvdG90eXBlID0gTWFwLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBNYXA7XG4gIGZ1bmN0aW9uIE1hcCgpe1xuICAgIHRoaXMuYmFja2Ryb3AgPSBudWxsO1xuICAgIHRoaXMudGlsZXMgPSBNYXAuY3JlYXRlTWF0cml4KG5ldyBUaWxlLCBrTWFwV2lkdGgsIDE1KTtcbiAgICB0aGlzLmJnVGlsZXMgPSBNYXAuY3JlYXRlTWF0cml4KG51bGwsIGtNYXBXaWR0aCwgMTUpO1xuICB9XG4gIHByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZ3JhcGhpY3Mpe1xuICAgIHZhciBpJCwgcmVmJCwgbGVuJCwgeSwgcm93LCBscmVzdWx0JCwgaiQsIGxlbjEkLCB4LCB0aWxlLCByZWYxJCwgcmVzdWx0cyQgPSBbXTtcbiAgICBmb3IgKGkkID0gMCwgbGVuJCA9IChyZWYkID0gdGhpcy50aWxlcykubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICAgIHkgPSBpJDtcbiAgICAgIHJvdyA9IHJlZiRbaSRdO1xuICAgICAgbHJlc3VsdCQgPSBbXTtcbiAgICAgIGZvciAoaiQgPSAwLCBsZW4xJCA9IHJvdy5sZW5ndGg7IGokIDwgbGVuMSQ7ICsraiQpIHtcbiAgICAgICAgeCA9IGokO1xuICAgICAgICB0aWxlID0gcm93W2okXTtcbiAgICAgICAgbHJlc3VsdCQucHVzaCgocmVmMSQgPSB0aWxlLnNwcml0ZSkgIT0gbnVsbCA/IHJlZjEkLmRyYXcoZ3JhcGhpY3MsIHRpbGVUb0dhbWUoeCksIHRpbGVUb0dhbWUoeSkpIDogdm9pZCA4KTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdHMkLnB1c2gobHJlc3VsdCQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cyQ7XG4gIH07XG4gIHByb3RvdHlwZS5kcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uKGdyYXBoaWNzKXtcbiAgICB2YXIgaSQsIHJlZiQsIGxlbiQsIHksIHJvdywgbHJlc3VsdCQsIGokLCBsZW4xJCwgeCwgc3ByaXRlLCByZXN1bHRzJCA9IFtdO1xuICAgIHRoaXMuYmFja2Ryb3AuZHJhdyhncmFwaGljcyk7XG4gICAgZm9yIChpJCA9IDAsIGxlbiQgPSAocmVmJCA9IHRoaXMuYmdUaWxlcykubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICAgIHkgPSBpJDtcbiAgICAgIHJvdyA9IHJlZiRbaSRdO1xuICAgICAgbHJlc3VsdCQgPSBbXTtcbiAgICAgIGZvciAoaiQgPSAwLCBsZW4xJCA9IHJvdy5sZW5ndGg7IGokIDwgbGVuMSQ7ICsraiQpIHtcbiAgICAgICAgeCA9IGokO1xuICAgICAgICBzcHJpdGUgPSByb3dbaiRdO1xuICAgICAgICBscmVzdWx0JC5wdXNoKHNwcml0ZSAhPSBudWxsID8gc3ByaXRlLmRyYXcoZ3JhcGhpY3MsIHRpbGVUb0dhbWUoeCksIHRpbGVUb0dhbWUoeSkpIDogdm9pZCA4KTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdHMkLnB1c2gobHJlc3VsdCQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cyQ7XG4gIH07XG4gIHByb3RvdHlwZS5nZXRDb2xsaWRpbmdUaWxlcyA9IGZ1bmN0aW9uKHJlY3Qpe1xuICAgIHZhciBmaXJzdFJvdywgbGFzdFJvdywgZmlyc3RDb2wsIGxhc3RDb2wsIGNvbGxpc2lvblRpbGVzLCBpJCwgcm93LCBqJCwgY29sO1xuICAgIGZpcnN0Um93ID0gZGl2KGdhbWVUb1B4KHJlY3QudG9wKSwgdHB4KDEpKTtcbiAgICBsYXN0Um93ID0gZGl2KGdhbWVUb1B4KHJlY3QuYm90dG9tKSwgdHB4KDEpKTtcbiAgICBmaXJzdENvbCA9IGRpdihnYW1lVG9QeChyZWN0LmxlZnQpLCB0cHgoMSkpO1xuICAgIGxhc3RDb2wgPSBkaXYoZ2FtZVRvUHgocmVjdC5yaWdodCksIHRweCgxKSk7XG4gICAgY29sbGlzaW9uVGlsZXMgPSBbXTtcbiAgICBmb3IgKGkkID0gZmlyc3RSb3c7IGkkIDw9IGxhc3RSb3c7ICsraSQpIHtcbiAgICAgIHJvdyA9IGkkO1xuICAgICAgZm9yIChqJCA9IGZpcnN0Q29sOyBqJCA8PSBsYXN0Q29sOyArK2okKSB7XG4gICAgICAgIGNvbCA9IGokO1xuICAgICAgICBpZiAocm93IDwgMCB8fCBjb2wgPCAwIHx8IGNvbCA+PSBrTWFwV2lkdGgpIHtcbiAgICAgICAgICBjb2xsaXNpb25UaWxlcy5wdXNoKG5ldyBDb2xsaXNpb25UaWxlKHJvdywgY29sLCBXQUxMX1RJTEUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2xsaXNpb25UaWxlcy5wdXNoKG5ldyBDb2xsaXNpb25UaWxlKHJvdywgY29sLCB0aGlzLnRpbGVzW3Jvd11bY29sXS50eXBlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxpc2lvblRpbGVzO1xuICB9O1xuICBNYXAuY3JlYXRlVGVzdE1hcCA9IGZ1bmN0aW9uKGdyYXBoaWNzKXtcbiAgICB2YXIgbWFwLCBiZ1BhdGgsIGZnUGF0aCwgbnVtUm93cywgbnVtQ29scywgcm93LCB0aWxlLCBpJCwgY29sLCBjaGFpblRvcCwgY2hhaW5NaWQsIGNoYWluQnRtO1xuICAgIG1hcCA9IG5ldyBNYXA7XG4gICAgYmdQYXRoID0gJ2JrQmx1ZSc7XG4gICAgZmdQYXRoID0gJ1N0YWdlL1BydENhdmUnO1xuICAgIG1hcC5iYWNrZHJvcCA9IG5ldyBGaXhlZEJhY2tkcm9wKGJnUGF0aCwgZ3JhcGhpY3MpO1xuICAgIG51bVJvd3MgPSAxNTtcbiAgICBudW1Db2xzID0gMjA7XG4gICAgcm93ID0gMTE7XG4gICAgdGlsZSA9IG5ldyBUaWxlKFdBTExfVElMRSwgbmV3IFNwcml0ZShncmFwaGljcywgZmdQYXRoLCB0cHgoMSksIHRweCgwKSwgdHB4KDEpLCB0cHgoMSkpKTtcbiAgICBmb3IgKGkkID0gMDsgaSQgPD0gbnVtQ29sczsgKytpJCkge1xuICAgICAgY29sID0gaSQ7XG4gICAgICBtYXAudGlsZXNbcm93XVtjb2xdID0gdGlsZTtcbiAgICB9XG4gICAgbWFwLnRpbGVzWzEwXVs1XSA9IHRpbGU7XG4gICAgbWFwLnRpbGVzWzldWzRdID0gdGlsZTtcbiAgICBtYXAudGlsZXNbOF1bM10gPSB0aWxlO1xuICAgIG1hcC50aWxlc1s3XVsyXSA9IHRpbGU7XG4gICAgbWFwLnRpbGVzWzEwXVszXSA9IHRpbGU7XG4gICAgbWFwLnRpbGVzWzEwXVswXSA9IHRpbGU7XG4gICAgbWFwLnRpbGVzWzhdWzEwXSA9IHRpbGU7XG4gICAgY2hhaW5Ub3AgPSBuZXcgU3ByaXRlKGdyYXBoaWNzLCBmZ1BhdGgsIHRweCgxMSksIHRweCgyKSwgdHB4KDEpLCB0cHgoMSkpO1xuICAgIGNoYWluTWlkID0gbmV3IFNwcml0ZShncmFwaGljcywgZmdQYXRoLCB0cHgoMTIpLCB0cHgoMiksIHRweCgxKSwgdHB4KDEpKTtcbiAgICBjaGFpbkJ0bSA9IG5ldyBTcHJpdGUoZ3JhcGhpY3MsIGZnUGF0aCwgdHB4KDEzKSwgdHB4KDIpLCB0cHgoMSksIHRweCgxKSk7XG4gICAgbWFwLmJnVGlsZXNbOF1bMl0gPSBjaGFpblRvcDtcbiAgICBtYXAuYmdUaWxlc1s5XVsyXSA9IGNoYWluTWlkO1xuICAgIG1hcC5iZ1RpbGVzWzEwXVsyXSA9IGNoYWluQnRtO1xuICAgIHJldHVybiBtYXA7XG4gIH07XG4gIE1hcC5jcmVhdGVNYXRyaXggPSBmdW5jdGlvbih2YWx1ZSwgY29scywgcm93cyl7XG4gICAgdmFyIGkkLCB5LCBscmVzdWx0JCwgaiQsIHosIHJlc3VsdHMkID0gW107XG4gICAgZm9yIChpJCA9IDA7IGkkIDw9IHJvd3M7ICsraSQpIHtcbiAgICAgIHkgPSBpJDtcbiAgICAgIGxyZXN1bHQkID0gW107XG4gICAgICBmb3IgKGokID0gMDsgaiQgPD0gY29sczsgKytqJCkge1xuICAgICAgICB6ID0gaiQ7XG4gICAgICAgIGxyZXN1bHQkLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgICAgcmVzdWx0cyQucHVzaChscmVzdWx0JCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzJDtcbiAgfTtcbiAgTWFwLldBTExfVElMRSA9IFdBTExfVElMRTtcbiAgTWFwLkFJUl9USUxFID0gQUlSX1RJTEU7XG4gIHJldHVybiBNYXA7XG59KCkpOyIsInZhciBzdGQsIHVuaXRzLCByZWFkb3V0LCBQYXJ0aWNsZVRvb2xzLCBQYXJ0aWNsZVN5c3RlbSwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcbnN0ZCA9IHJlcXVpcmUoJ3N0ZCcpO1xudW5pdHMgPSByZXF1aXJlKCcuL3VuaXRzJyk7XG5yZWFkb3V0ID0gcmVxdWlyZSgnLi9yZWFkb3V0Jyk7XG5vdXQkLlBhcnRpY2xlVG9vbHMgPSBQYXJ0aWNsZVRvb2xzID0gKGZ1bmN0aW9uKCl7XG4gIFBhcnRpY2xlVG9vbHMuZGlzcGxheU5hbWUgPSAnUGFydGljbGVUb29scyc7XG4gIHZhciBwcm90b3R5cGUgPSBQYXJ0aWNsZVRvb2xzLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBQYXJ0aWNsZVRvb2xzO1xuICBmdW5jdGlvbiBQYXJ0aWNsZVRvb2xzKGdyYXBoaWNzKXtcbiAgICB0aGlzLmdyYXBoaWNzID0gZ3JhcGhpY3M7XG4gICAgcmVhZG91dC5hZGRSZWFkZXIoJ3BhcnRpY2xlcycsICdQYXJ0aWNsZXMnLCAwKTtcbiAgICB0aGlzLmVudGl0eVN5c3RlbSA9IG5ldyBQYXJ0aWNsZVN5c3RlbTtcbiAgICB0aGlzLmZyb250U3lzdGVtID0gbmV3IFBhcnRpY2xlU3lzdGVtO1xuICB9XG4gIHByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihlbGFwc2VkVGltZSl7XG4gICAgcmVhZG91dC51cGRhdGUoJ3BhcnRpY2xlcycsIHRoaXMuZW50aXR5U3lzdGVtLnBhcnRpY2xlcy5sZW5ndGggKyB0aGlzLmZyb250U3lzdGVtLnBhcnRpY2xlcy5sZW5ndGgpO1xuICAgIHRoaXMuZW50aXR5U3lzdGVtLnVwZGF0ZShlbGFwc2VkVGltZSk7XG4gICAgcmV0dXJuIHRoaXMuZnJvbnRTeXN0ZW0udXBkYXRlKGVsYXBzZWRUaW1lKTtcbiAgfTtcbiAgcmV0dXJuIFBhcnRpY2xlVG9vbHM7XG59KCkpO1xub3V0JC5QYXJ0aWNsZVN5c3RlbSA9IFBhcnRpY2xlU3lzdGVtID0gKGZ1bmN0aW9uKCl7XG4gIFBhcnRpY2xlU3lzdGVtLmRpc3BsYXlOYW1lID0gJ1BhcnRpY2xlU3lzdGVtJztcbiAgdmFyIHByb3RvdHlwZSA9IFBhcnRpY2xlU3lzdGVtLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBQYXJ0aWNsZVN5c3RlbTtcbiAgZnVuY3Rpb24gUGFydGljbGVTeXN0ZW0oKXtcbiAgICB0aGlzLnBhcnRpY2xlcyA9IFtdO1xuICB9XG4gIHByb3RvdHlwZS5hZGROZXdQYXJ0aWNsZSA9IGZ1bmN0aW9uKGl0KXtcbiAgICByZXR1cm4gdGhpcy5wYXJ0aWNsZXMucHVzaChpdCk7XG4gIH07XG4gIHByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihlbGFwc2VkVGltZSl7XG4gICAgcmV0dXJuIHRoaXMucGFydGljbGVzID0gc3RkLmZpbHRlcihmdW5jdGlvbihpdCl7XG4gICAgICByZXR1cm4gaXQudXBkYXRlKGVsYXBzZWRUaW1lKTtcbiAgICB9LCB0aGlzLnBhcnRpY2xlcyk7XG4gIH07XG4gIHByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZ3JhcGhpY3Mpe1xuICAgIHJldHVybiB0aGlzLnBhcnRpY2xlcy5mb3JFYWNoKGZ1bmN0aW9uKGl0KXtcbiAgICAgIHJldHVybiBpdC5kcmF3KGdyYXBoaWNzKTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIFBhcnRpY2xlU3lzdGVtO1xufSgpKTsiLCJ2YXIgSW50ZXJmYWNlRXJyb3IsIFBhcnRpY2xlLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuSW50ZXJmYWNlRXJyb3IgPSAoZnVuY3Rpb24oc3VwZXJjbGFzcyl7XG4gIHZhciBwcm90b3R5cGUgPSBleHRlbmQkKChpbXBvcnQkKEludGVyZmFjZUVycm9yLCBzdXBlcmNsYXNzKS5kaXNwbGF5TmFtZSA9ICdJbnRlcmZhY2VFcnJvcicsIEludGVyZmFjZUVycm9yKSwgc3VwZXJjbGFzcykucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IEludGVyZmFjZUVycm9yO1xuICBmdW5jdGlvbiBJbnRlcmZhY2VFcnJvcihtZXNzYWdlKXtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMubmFtZSA9ICdJbnRlcmZhY2VFcnJvcic7XG4gIH1cbiAgcmV0dXJuIEludGVyZmFjZUVycm9yO1xufShFcnJvcikpO1xub3V0JC5QYXJ0aWNsZSA9IFBhcnRpY2xlID0gKGZ1bmN0aW9uKCl7XG4gIFBhcnRpY2xlLmRpc3BsYXlOYW1lID0gJ1BhcnRpY2xlJztcbiAgdmFyIHByb3RvdHlwZSA9IFBhcnRpY2xlLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBQYXJ0aWNsZTtcbiAgcHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGVsYXBzZWRUaW1lKXtcbiAgICB0aHJvdyBuZXcgSW50ZXJmYWNlRXJyb3IoXCJQYXJ0aWNsZSAtIGB1cGRhdGVgIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfTtcbiAgcHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihncmFwaGljcyl7XG4gICAgdGhyb3cgbmV3IEludGVyZmFjZUVycm9yKFwiUGFydGljbGUgLSBgZHJhd2Agbm90IGltcGxlbWVudGVkXCIpO1xuICB9O1xuICBmdW5jdGlvbiBQYXJ0aWNsZSgpe31cbiAgcmV0dXJuIFBhcnRpY2xlO1xufSgpKTtcbmZ1bmN0aW9uIGV4dGVuZCQoc3ViLCBzdXApe1xuICBmdW5jdGlvbiBmdW4oKXt9IGZ1bi5wcm90b3R5cGUgPSAoc3ViLnN1cGVyY2xhc3MgPSBzdXApLnByb3RvdHlwZTtcbiAgKHN1Yi5wcm90b3R5cGUgPSBuZXcgZnVuKS5jb25zdHJ1Y3RvciA9IHN1YjtcbiAgaWYgKHR5cGVvZiBzdXAuZXh0ZW5kZWQgPT0gJ2Z1bmN0aW9uJykgc3VwLmV4dGVuZGVkKHN1Yik7XG4gIHJldHVybiBzdWI7XG59XG5mdW5jdGlvbiBpbXBvcnQkKG9iaiwgc3JjKXtcbiAgdmFyIG93biA9IHt9Lmhhc093blByb3BlcnR5O1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSBpZiAob3duLmNhbGwoc3JjLCBrZXkpKSBvYmpba2V5XSA9IHNyY1trZXldO1xuICByZXR1cm4gb2JqO1xufSIsInZhciBzdGQsIHVuaXRzLCBrSGFsZlRpbGUsIHRweCwgVGltZXIsIFJlY3RhbmdsZSwgS2luZW1hdGljcywgQW5pbWF0ZWRTcHJpdGUsIHJlZiQsIE1hcENvbGxpZGFibGUsIFNpZGUsIFNpbXBsZUNvbGxpc2lvblJlY3RhbmdsZSwgRnJpY3Rpb25BY2NlbGVyYXRvciwga0dyYXZpdHlBY2MsIEhFQUxUSCwgTUlTU0lMRVMsIEVYUEVSSUVOQ0UsIFNNQUxMLCBNRURJVU0sIExBUkdFLCBQaWNrdXAsIFBvd2VyRG9yaXRvLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG51bml0cyA9IHJlcXVpcmUoJy4vdW5pdHMnKSwga0hhbGZUaWxlID0gdW5pdHMua0hhbGZUaWxlLCB0cHggPSB1bml0cy50aWxlVG9QeDtcblRpbWVyID0gcmVxdWlyZSgnLi90aW1lcicpLlRpbWVyO1xuUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi9yZWN0YW5nbGUnKS5SZWN0YW5nbGU7XG5LaW5lbWF0aWNzID0gcmVxdWlyZSgnLi9raW5lbWF0aWNzJykuS2luZW1hdGljcztcbkFuaW1hdGVkU3ByaXRlID0gcmVxdWlyZSgnLi9zcHJpdGUnKS5BbmltYXRlZFNwcml0ZTtcbnJlZiQgPSByZXF1aXJlKCcuL21hcC1jb2xsaWRhYmxlJyksIE1hcENvbGxpZGFibGUgPSByZWYkLk1hcENvbGxpZGFibGUsIFNpZGUgPSByZWYkLlNpZGU7XG5TaW1wbGVDb2xsaXNpb25SZWN0YW5nbGUgPSByZXF1aXJlKCcuL2NvbGxpc2lvbi1yZWN0YW5nbGUnKS5TaW1wbGVDb2xsaXNpb25SZWN0YW5nbGU7XG5yZWYkID0gcmVxdWlyZSgnLi9hY2NlbGVyYXRvcnMnKSwgRnJpY3Rpb25BY2NlbGVyYXRvciA9IHJlZiQuRnJpY3Rpb25BY2NlbGVyYXRvciwga0dyYXZpdHlBY2MgPSByZWYkLmtHcmF2aXR5QWNjO1xucmVmJCA9IHN0ZFsnZW51bSddLCBIRUFMVEggPSByZWYkWzBdLCBNSVNTSUxFUyA9IHJlZiRbMV0sIEVYUEVSSUVOQ0UgPSByZWYkWzJdO1xucmVmJCA9IHN0ZFsnZW51bSddLCBTTUFMTCA9IHJlZiRbMF0sIE1FRElVTSA9IHJlZiRbMV0sIExBUkdFID0gcmVmJFsyXTtcbm91dCQuUGlja3VwID0gUGlja3VwID0gKGZ1bmN0aW9uKCl7XG4gIFBpY2t1cC5kaXNwbGF5TmFtZSA9ICdQaWNrdXAnO1xuICB2YXIgcHJvdG90eXBlID0gUGlja3VwLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBQaWNrdXA7XG4gIFBpY2t1cC5TTUFMTCA9IFNNQUxMO1xuICBQaWNrdXAuTUVESVVNID0gTUVESVVNO1xuICBQaWNrdXAuTEFSR0UgPSBMQVJHRTtcbiAgZnVuY3Rpb24gUGlja3VwKHR5cGUsIHZhbHVlKXtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmNvbGxpc29uUmVjdGFuZ2xlID0gbmV3IFJlY3RhbmdsZTtcbiAgfVxuICBwcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGdyYXBoaWNzKXt9O1xuICBwcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oZWxhcHNlZFRpbWUpe307XG4gIHJldHVybiBQaWNrdXA7XG59KCkpO1xub3V0JC5Qb3dlckRvcml0byA9IFBvd2VyRG9yaXRvID0gKGZ1bmN0aW9uKHN1cGVyY2xhc3Mpe1xuICB2YXIga1ZhbHVlcywga1Nwcml0ZU5hbWUsIGtTb3VyY2VYLCBrU291cmNlWXMsIGtTb3VyY2VXaWR0aCwga1NvdXJjZUhlaWdodCwga0Zwcywga051bUZyYW1lcywga0xpZmV0aW1lLCBrRmxhc2h0aW1lLCBrRmxhc2hQZXJpb2QsIGtCb3VuY2VTcGVlZCwga0ZyaWN0aW9uLCBrQ29sbGlzaW9uUmVjdGFuZ2xlcywgcHJvdG90eXBlID0gZXh0ZW5kJCgoaW1wb3J0JChQb3dlckRvcml0bywgc3VwZXJjbGFzcykuZGlzcGxheU5hbWUgPSAnUG93ZXJEb3JpdG8nLCBQb3dlckRvcml0byksIHN1cGVyY2xhc3MpLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBQb3dlckRvcml0bztcbiAgaW1wb3J0QWxsJChwcm90b3R5cGUsIGFyZ3VtZW50c1sxXSk7XG4gIGtWYWx1ZXMgPSBbMSwgNSwgMjBdO1xuICBrU3ByaXRlTmFtZSA9ICdOcGMvTnBjU3ltJztcbiAga1NvdXJjZVggPSAwO1xuICBrU291cmNlWXMgPSBbMSwgMiwgM107XG4gIGtTb3VyY2VXaWR0aCA9IDE7XG4gIGtTb3VyY2VIZWlnaHQgPSAxO1xuICBrRnBzID0gMTQ7XG4gIGtOdW1GcmFtZXMgPSA2O1xuICBrTGlmZXRpbWUgPSA4MDAwO1xuICBrRmxhc2h0aW1lID0gNzAwMDtcbiAga0ZsYXNoUGVyaW9kID0gNTA7XG4gIGtCb3VuY2VTcGVlZCA9IDAuMjI1O1xuICBrRnJpY3Rpb24gPSBuZXcgRnJpY3Rpb25BY2NlbGVyYXRvcigwLjAwMDAyKTtcbiAga0NvbGxpc2lvblJlY3RhbmdsZXMgPSBbbmV3IFNpbXBsZUNvbGxpc2lvblJlY3RhbmdsZShuZXcgUmVjdGFuZ2xlKDgsIDgsIDE2LCAxNikpLCBuZXcgU2ltcGxlQ29sbGlzaW9uUmVjdGFuZ2xlKG5ldyBSZWN0YW5nbGUoNCwgNCwgMjQsIDI0KSksIG5ldyBTaW1wbGVDb2xsaXNpb25SZWN0YW5nbGUobmV3IFJlY3RhbmdsZSgwLCAwLCAzMiwgMzIpKV07XG4gIGZ1bmN0aW9uIFBvd2VyRG9yaXRvKGdyYXBoaWNzLCBjZW50ZXJYLCBjZW50ZXJZLCBzaXplKXtcbiAgICB0aGlzLmNlbnRlclggPSBjZW50ZXJYO1xuICAgIHRoaXMuY2VudGVyWSA9IGNlbnRlclk7XG4gICAgdGhpcy5zaXplID0gc2l6ZSAhPSBudWxsID8gc2l6ZSA6IFNNQUxMO1xuICAgIFBvd2VyRG9yaXRvLnN1cGVyY2xhc3MuY2FsbCh0aGlzLCBFWFBFUklFTkNFLCBrVmFsdWVzW3RoaXMuc2l6ZV0pO1xuICAgIHRoaXMua2luZW1hdGljc1ggPSBuZXcgS2luZW1hdGljcyh0aGlzLmNlbnRlclggLSBrSGFsZlRpbGUsIDAuMDI1ICogc3RkLnJhbmQoLTUsIDUpKTtcbiAgICB0aGlzLmtpbmVtYXRpY3NZID0gbmV3IEtpbmVtYXRpY3ModGhpcy5jZW50ZXJZIC0ga0hhbGZUaWxlLCAwLjAyNSAqIHN0ZC5yYW5kKC01LCA1KSk7XG4gICAgdGhpcy50aW1lciA9IG5ldyBUaW1lcihrTGlmZXRpbWUsIHRydWUpO1xuICAgIHRoaXMuc3ByaXRlID0gbmV3IEFuaW1hdGVkU3ByaXRlKGdyYXBoaWNzLCBrU3ByaXRlTmFtZSwgdHB4KGtTb3VyY2VYKSwgdHB4KGtTb3VyY2VZc1t0aGlzLnNpemVdKSwgdHB4KGtTb3VyY2VXaWR0aCksIHRweChrU291cmNlSGVpZ2h0KSwga0Zwcywga051bUZyYW1lcyk7XG4gIH1cbiAgcHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihncmFwaGljcyl7XG4gICAgaWYgKHRoaXMudGltZXIuY3VycmVudFRpbWUgPCBrRmxhc2h0aW1lIHx8IHN0ZC5kaXYodGhpcy50aW1lci5jdXJyZW50VGltZSwga0ZsYXNoUGVyaW9kKSAlIDIgPT09IDApIHtcbiAgICAgIHRoaXMuc3ByaXRlLmRyYXcoZ3JhcGhpY3MsIHRoaXMua2luZW1hdGljc1gucG9zaXRpb24sIHRoaXMua2luZW1hdGljc1kucG9zaXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gZ3JhcGhpY3MudmlzdWFsaXNlUmVjdCh0aGlzLmNvbGxpc2lvblJlY3RhbmdsZSgpKTtcbiAgfTtcbiAgcHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGVsYXBzZWRUaW1lLCBtYXApe1xuICAgIHRoaXMuc3ByaXRlLnVwZGF0ZSgpO1xuICAgIHRoaXMudXBkYXRlWShrQ29sbGlzaW9uUmVjdGFuZ2xlc1t0aGlzLnNpemVdLCBrR3Jhdml0eUFjYywgdGhpcy5raW5lbWF0aWNzWCwgdGhpcy5raW5lbWF0aWNzWSwgZWxhcHNlZFRpbWUsIG1hcCk7XG4gICAgdGhpcy51cGRhdGVYKGtDb2xsaXNpb25SZWN0YW5nbGVzW3RoaXMuc2l6ZV0sIGtGcmljdGlvbiwgdGhpcy5raW5lbWF0aWNzWCwgdGhpcy5raW5lbWF0aWNzWSwgZWxhcHNlZFRpbWUsIG1hcCk7XG4gICAgcmV0dXJuIHRoaXMudGltZXIuaXNBY3RpdmU7XG4gIH07XG4gIHByb3RvdHlwZS5jb2xsaXNpb25SZWN0YW5nbGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBib3g7XG4gICAgYm94ID0ga0NvbGxpc2lvblJlY3RhbmdsZXNbdGhpcy5zaXplXS5ib3VuZGluZ0JveDtcbiAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLmtpbmVtYXRpY3NYLnBvc2l0aW9uICsgYm94LmxlZnQsIHRoaXMua2luZW1hdGljc1kucG9zaXRpb24gKyBib3gudG9wLCBib3gudywgYm94LmgpO1xuICB9O1xuICBwcm90b3R5cGUub25Db2xsaXNpb24gPSBmdW5jdGlvbihzaWRlLCBpc0RlbHRhRGlyZWN0aW9uKXtcbiAgICBpZiAoc2lkZSA9PT0gU2lkZS5UT1ApIHtcbiAgICAgIHJldHVybiB0aGlzLmtpbmVtYXRpY3NZLnZlbG9jaXR5ID0gMDtcbiAgICB9IGVsc2UgaWYgKHNpZGUgPT09IFNpZGUuQk9UVE9NKSB7XG4gICAgICByZXR1cm4gdGhpcy5raW5lbWF0aWNzWS52ZWxvY2l0eSA9IC1rQm91bmNlU3BlZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmtpbmVtYXRpY3NYLnZlbG9jaXR5ICo9IC0xO1xuICAgIH1cbiAgfTtcbiAgcHJvdG90eXBlLm9uRGVsdGEgPSBmdW5jdGlvbihzaWRlKXt9O1xuICByZXR1cm4gUG93ZXJEb3JpdG87XG59KFBpY2t1cCwgTWFwQ29sbGlkYWJsZS5wcm90b3R5cGUpKTtcblBpY2t1cC5IRUFMVEggPSBIRUFMVEg7XG5QaWNrdXAuTUlTU0lMRVMgPSBNSVNTSUxFUztcblBpY2t1cC5FWFBFUklFTkNFID0gRVhQRVJJRU5DRTtcbmZ1bmN0aW9uIGV4dGVuZCQoc3ViLCBzdXApe1xuICBmdW5jdGlvbiBmdW4oKXt9IGZ1bi5wcm90b3R5cGUgPSAoc3ViLnN1cGVyY2xhc3MgPSBzdXApLnByb3RvdHlwZTtcbiAgKHN1Yi5wcm90b3R5cGUgPSBuZXcgZnVuKS5jb25zdHJ1Y3RvciA9IHN1YjtcbiAgaWYgKHR5cGVvZiBzdXAuZXh0ZW5kZWQgPT0gJ2Z1bmN0aW9uJykgc3VwLmV4dGVuZGVkKHN1Yik7XG4gIHJldHVybiBzdWI7XG59XG5mdW5jdGlvbiBpbXBvcnQkKG9iaiwgc3JjKXtcbiAgdmFyIG93biA9IHt9Lmhhc093blByb3BlcnR5O1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSBpZiAob3duLmNhbGwoc3JjLCBrZXkpKSBvYmpba2V5XSA9IHNyY1trZXldO1xuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gaW1wb3J0QWxsJChvYmosIHNyYyl7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIG9ialtrZXldID0gc3JjW2tleV07XG4gIHJldHVybiBvYmo7XG59IiwidmFyIHN0ZCwgdW5pdHMsIFBpY2t1cHMsIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5zdGQgPSByZXF1aXJlKCdzdGQnKTtcbnVuaXRzID0gcmVxdWlyZSgnLi91bml0cycpO1xub3V0JC5QaWNrdXBzID0gUGlja3VwcyA9IChmdW5jdGlvbigpe1xuICBQaWNrdXBzLmRpc3BsYXlOYW1lID0gJ1BpY2t1cHMnO1xuICB2YXIgcHJvdG90eXBlID0gUGlja3Vwcy5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gUGlja3VwcztcbiAgZnVuY3Rpb24gUGlja3Vwcygpe1xuICAgIHRoaXMucGlja3VwcyA9IFtdO1xuICB9XG4gIHByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihlbGFwc2VkVGltZSwgbWFwKXtcbiAgICByZXR1cm4gdGhpcy5waWNrdXBzID0gdGhpcy5waWNrdXBzLmZpbHRlcihmdW5jdGlvbihpdCl7XG4gICAgICByZXR1cm4gaXQudXBkYXRlKGVsYXBzZWRUaW1lLCBtYXApO1xuICAgIH0pO1xuICB9O1xuICBwcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ocGlja3VwKXtcbiAgICByZXR1cm4gdGhpcy5waWNrdXBzLnB1c2gocGlja3VwKTtcbiAgfTtcbiAgcHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihncmFwaGljcyl7XG4gICAgcmV0dXJuIHRoaXMucGlja3Vwcy5tYXAoZnVuY3Rpb24oaXQpe1xuICAgICAgcmV0dXJuIGl0LmRyYXcoZ3JhcGhpY3MpO1xuICAgIH0pO1xuICB9O1xuICBwcm90b3R5cGUuaGFuZGxlQ29sbGlzaW9ucyA9IGZ1bmN0aW9uKHBsYXllcil7XG4gICAgcmV0dXJuIHRoaXMucGlja3VwcyA9IHRoaXMucGlja3Vwcy5maWx0ZXIoZnVuY3Rpb24oaXQpe1xuICAgICAgaWYgKHBsYXllci5kYW1hZ2VDb2xsaXNpb24oKS5jb2xsaWRlc1dpdGgoaXQuY29sbGlzaW9uUmVjdGFuZ2xlKCkpKSB7XG4gICAgICAgIHBsYXllci5jb2xsZWN0UGlja3VwKGl0KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBQaWNrdXBzO1xufSgpKTsiLCJ2YXIgc3RkLCB1bml0cywgY29uZmlnLCByZWFkb3V0LCBrSGFsZlRpbGUsIHRpbGVUb0dhbWUsIHRweCwgVGltZXIsIEhlYWx0aCwgUGlja3VwLCBLaW5lbWF0aWNzLCBEYW1hZ2VhYmxlLCBEYW1hZ2VUZXh0LCBEYW1hZ2VUZXh0cywgUG9sYXJTdGFyLCBHdW5FeHBlcmllbmNlSFVELCBNYXBDb2xsaWRhYmxlLCByZWYkLCBTcHJpdGVTdGF0ZSwgU3RhdGUsIFJlY3QsIEhlYWRCdW1wUGFydGljbGUsIENvbXBvc2l0ZUNvbGxpc2lvblJlY3RhbmdsZSwgQ29uc3RhbnRBY2NlbGVyYXRvciwgRnJpY3Rpb25BY2NlbGVyYXRvciwgQmlkaXJlY3Rpb25hbEFjY2VsZXJhdG9yLCBrWmVybywga0dyYXZpdHksIGtUZXJtaW5hbFNwZWVkLCBTaWRlLCBTcHJpdGUsIEFuaW1hdGVkU3ByaXRlLCBOdW1iZXJTcHJpdGUsIGtDaGFyYWN0ZXJGcmFtZSwga1dhbGtGcmFtZSwga1N0YW5kRnJhbWUsIGtKdW1wRnJhbWUsIGtGYWxsRnJhbWUsIGtVcEZyYW1lT2Zmc2V0LCBrRG93bkZyYW1lLCBrQmFja0ZyYW1lLCBrTnVtV2Fsa0ZyYW1lcywga1dhbGtGcHMsIGtTdHJpZGVNaWRkbGVGcmFtZU9mZnNldCwga1N0cmlkZUxlZnRGcmFtZU9mZnNldCwga1N0cmlkZVJpZ2h0RnJhbWVPZmZzZXQsIGtKdW1wU3BlZWQsIGtTaG9ydEp1bXBTcGVlZCwga01heFNwZWVkWCwga1dhbGtBY2MsIGtBaXJBY2MsIGtHcmF2aXR5QWNjLCBrRnJpY3Rpb25BY2MsIGtKdW1wR3Jhdml0eUFjYywga0ludmluY2libGVUaW1lLCBrSW52aW5jaWJsZUZsYXNoVGltZSwga0NvbGxpc2lvblgsIGtDb2xsaXNpb25ZVG9wLCBrQ29sbGlzaW9uWUhlaWdodCwga0NvbGxpc2lvbllUb3BXaWR0aCwga0NvbGxpc2lvbllCb3R0b21XaWR0aCwga0NvbGxpc2lvbllUb3BMZWZ0LCBrQ29sbGlzaW9uWUJvdHRvbUxlZnQsIGtDb2xsaXNpb25SZWN0YW5nbGUsIFdhbGtpbmdBbmltYXRpb24sIFBsYXllciwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcbnN0ZCA9IHJlcXVpcmUoJ3N0ZCcpO1xudW5pdHMgPSByZXF1aXJlKCcuL3VuaXRzJyk7XG5jb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xucmVhZG91dCA9IHJlcXVpcmUoJy4vcmVhZG91dCcpO1xua0hhbGZUaWxlID0gdW5pdHMua0hhbGZUaWxlLCB0aWxlVG9HYW1lID0gdW5pdHMudGlsZVRvR2FtZSwgdHB4ID0gdW5pdHMudGlsZVRvUHg7XG5UaW1lciA9IHJlcXVpcmUoJy4vdGltZXInKS5UaW1lcjtcbkhlYWx0aCA9IHJlcXVpcmUoJy4vaGVhbHRoJykuSGVhbHRoO1xuUGlja3VwID0gcmVxdWlyZSgnLi9waWNrdXAnKS5QaWNrdXA7XG5LaW5lbWF0aWNzID0gcmVxdWlyZSgnLi9raW5lbWF0aWNzJykuS2luZW1hdGljcztcbkRhbWFnZWFibGUgPSByZXF1aXJlKCcuL2RhbWFnZWFibGUnKS5EYW1hZ2VhYmxlO1xuRGFtYWdlVGV4dCA9IHJlcXVpcmUoJy4vZGFtYWdlLXRleHQnKS5EYW1hZ2VUZXh0O1xuRGFtYWdlVGV4dHMgPSByZXF1aXJlKCcuL2RhbWFnZS10ZXh0cycpLkRhbWFnZVRleHRzO1xuUG9sYXJTdGFyID0gcmVxdWlyZSgnLi9hcm1zJykuUG9sYXJTdGFyO1xuR3VuRXhwZXJpZW5jZUhVRCA9IHJlcXVpcmUoJy4vZ3VuLXhwLWh1ZCcpLkd1bkV4cGVyaWVuY2VIVUQ7XG5NYXBDb2xsaWRhYmxlID0gcmVxdWlyZSgnLi9tYXAtY29sbGlkYWJsZScpLk1hcENvbGxpZGFibGU7XG5yZWYkID0gcmVxdWlyZSgnLi9zcHJpdGVzdGF0ZScpLCBTcHJpdGVTdGF0ZSA9IHJlZiQuU3ByaXRlU3RhdGUsIFN0YXRlID0gcmVmJC5TdGF0ZTtcblJlY3QgPSByZXF1aXJlKCcuL3JlY3RhbmdsZScpLlJlY3RhbmdsZTtcbkhlYWRCdW1wUGFydGljbGUgPSByZXF1aXJlKCcuL2hlYWQtYnVtcC1wYXJ0aWNsZScpLkhlYWRCdW1wUGFydGljbGU7XG5Db21wb3NpdGVDb2xsaXNpb25SZWN0YW5nbGUgPSByZXF1aXJlKCcuL2NvbGxpc2lvbi1yZWN0YW5nbGUnKS5Db21wb3NpdGVDb2xsaXNpb25SZWN0YW5nbGU7XG5yZWYkID0gcmVxdWlyZSgnLi9hY2NlbGVyYXRvcnMnKSwgQ29uc3RhbnRBY2NlbGVyYXRvciA9IHJlZiQuQ29uc3RhbnRBY2NlbGVyYXRvciwgRnJpY3Rpb25BY2NlbGVyYXRvciA9IHJlZiQuRnJpY3Rpb25BY2NlbGVyYXRvciwgQmlkaXJlY3Rpb25hbEFjY2VsZXJhdG9yID0gcmVmJC5CaWRpcmVjdGlvbmFsQWNjZWxlcmF0b3IsIGtaZXJvID0gcmVmJC5rWmVybywga0dyYXZpdHkgPSByZWYkLmtHcmF2aXR5LCBrVGVybWluYWxTcGVlZCA9IHJlZiQua1Rlcm1pbmFsU3BlZWQ7XG5TaWRlID0gcmVxdWlyZSgnLi9tYXAtY29sbGlkYWJsZScpLlNpZGU7XG5yZWYkID0gcmVxdWlyZSgnLi9zcHJpdGUnKSwgU3ByaXRlID0gcmVmJC5TcHJpdGUsIEFuaW1hdGVkU3ByaXRlID0gcmVmJC5BbmltYXRlZFNwcml0ZSwgTnVtYmVyU3ByaXRlID0gcmVmJC5OdW1iZXJTcHJpdGU7XG5rQ2hhcmFjdGVyRnJhbWUgPSAwO1xua1dhbGtGcmFtZSA9IDA7XG5rU3RhbmRGcmFtZSA9IDA7XG5rSnVtcEZyYW1lID0gMTtcbmtGYWxsRnJhbWUgPSAyO1xua1VwRnJhbWVPZmZzZXQgPSAzO1xua0Rvd25GcmFtZSA9IDY7XG5rQmFja0ZyYW1lID0gNztcbmtOdW1XYWxrRnJhbWVzID0gMztcbmtXYWxrRnBzID0gMTU7XG5rU3RyaWRlTWlkZGxlRnJhbWVPZmZzZXQgPSAwO1xua1N0cmlkZUxlZnRGcmFtZU9mZnNldCA9IDE7XG5rU3RyaWRlUmlnaHRGcmFtZU9mZnNldCA9IDI7XG5rSnVtcFNwZWVkID0gMC4yNTtcbmtTaG9ydEp1bXBTcGVlZCA9IGtKdW1wU3BlZWQgLyAxLjU7XG5rTWF4U3BlZWRYID0gMC4xNTg1OTM3NTtcbmtXYWxrQWNjID0gbmV3IEJpZGlyZWN0aW9uYWxBY2NlbGVyYXRvcigwLjAwMDgzMDA3ODEyLCBrTWF4U3BlZWRYKTtcbmtBaXJBY2MgPSBuZXcgQmlkaXJlY3Rpb25hbEFjY2VsZXJhdG9yKDAuMDAwMzEyNSwga01heFNwZWVkWCk7XG5rR3Jhdml0eUFjYyA9IG5ldyBDb25zdGFudEFjY2VsZXJhdG9yKGtHcmF2aXR5LCBrVGVybWluYWxTcGVlZCk7XG5rRnJpY3Rpb25BY2MgPSBuZXcgRnJpY3Rpb25BY2NlbGVyYXRvcigwLjAwMDQ5ODA0Njg3KTtcbmtKdW1wR3Jhdml0eUFjYyA9IG5ldyBDb25zdGFudEFjY2VsZXJhdG9yKDAuMDAwMzEyNSwga1Rlcm1pbmFsU3BlZWQpO1xua0ludmluY2libGVUaW1lID0gMzAwMDtcbmtJbnZpbmNpYmxlRmxhc2hUaW1lID0gNTA7XG5rQ29sbGlzaW9uWCA9IG5ldyBSZWN0KDYsIDEwLCAyMCwgMTIpO1xua0NvbGxpc2lvbllUb3AgPSAyO1xua0NvbGxpc2lvbllIZWlnaHQgPSAzMDtcbmtDb2xsaXNpb25ZVG9wV2lkdGggPSAxODtcbmtDb2xsaXNpb25ZQm90dG9tV2lkdGggPSAxMDtcbmtDb2xsaXNpb25ZVG9wTGVmdCA9ICh0aWxlVG9HYW1lKDEpIC0ga0NvbGxpc2lvbllUb3BXaWR0aCkgLyAyO1xua0NvbGxpc2lvbllCb3R0b21MZWZ0ID0gKHRpbGVUb0dhbWUoMSkgLSBrQ29sbGlzaW9uWUJvdHRvbVdpZHRoKSAvIDI7XG5rQ29sbGlzaW9uUmVjdGFuZ2xlID0gbmV3IENvbXBvc2l0ZUNvbGxpc2lvblJlY3RhbmdsZShuZXcgUmVjdChrQ29sbGlzaW9uWVRvcExlZnQsIGtDb2xsaXNpb25ZVG9wLCBrQ29sbGlzaW9uWVRvcFdpZHRoLCBrQ29sbGlzaW9uWUhlaWdodCAvIDIpLCBuZXcgUmVjdChrQ29sbGlzaW9uWUJvdHRvbUxlZnQsIGtDb2xsaXNpb25ZVG9wICsga0NvbGxpc2lvbllIZWlnaHQgLyAyLCBrQ29sbGlzaW9uWUJvdHRvbVdpZHRoLCBrQ29sbGlzaW9uWUhlaWdodCAvIDIpLCBuZXcgUmVjdCg2LCAxMCwgMTAsIDEyKSwgbmV3IFJlY3QoMTYsIDEwLCAxMCwgMTIpKTtcbldhbGtpbmdBbmltYXRpb24gPSAoZnVuY3Rpb24oKXtcbiAgV2Fsa2luZ0FuaW1hdGlvbi5kaXNwbGF5TmFtZSA9ICdXYWxraW5nQW5pbWF0aW9uJztcbiAgdmFyIHByb3RvdHlwZSA9IFdhbGtpbmdBbmltYXRpb24ucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IFdhbGtpbmdBbmltYXRpb247XG4gIGZ1bmN0aW9uIFdhbGtpbmdBbmltYXRpb24obnVtRnJhbWVzLCBmcHMpe1xuICAgIHRoaXMubnVtRnJhbWVzID0gbnVtRnJhbWVzO1xuICAgIHRoaXMuZnBzID0gZnBzO1xuICAgIHRoaXMuZnJhbWVUaW1lciA9IG5ldyBUaW1lcigxMDAwIC8gdGhpcy5mcHMpO1xuICAgIHRoaXMuZm9yd2FyZCA9IHRydWU7XG4gICAgdGhpcy5pbmRleCA9IDA7XG4gIH1cbiAgcHJvdG90eXBlLnN0cmlkZSA9IGZ1bmN0aW9uKCl7XG4gICAgc3dpdGNoICh0aGlzLmluZGV4KSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIFN0YXRlLlNUUklERV9MRUZUO1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBTdGF0ZS5TVFJJREVfTUlERExFO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBTdGF0ZS5TVFJJREVfUklHSFQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBTdGF0ZS5TVFJJREVfTEVGVDtcbiAgICB9XG4gIH07XG4gIHByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIGlmICh0aGlzLmZyYW1lVGltZXIuaXNFeHBpcmVkKSB7XG4gICAgICB0aGlzLmZyYW1lVGltZXIucmVzZXQoKTtcbiAgICAgIGlmICh0aGlzLmZvcndhcmQpIHtcbiAgICAgICAgdGhpcy5pbmRleCArPSAxO1xuICAgICAgICByZXR1cm4gdGhpcy5mb3J3YXJkID0gdGhpcy5pbmRleCAhPT0gdGhpcy5udW1GcmFtZXMgLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbmRleCAtPSAxO1xuICAgICAgICByZXR1cm4gdGhpcy5mb3J3YXJkID0gdGhpcy5pbmRleCA9PT0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5mcmFtZVRpbWVyLnJlc2V0KCk7XG4gICAgdGhpcy5pbmRleCA9IDA7XG4gICAgcmV0dXJuIHRoaXMuZm9yd2FyZCA9IHRydWU7XG4gIH07XG4gIHJldHVybiBXYWxraW5nQW5pbWF0aW9uO1xufSgpKTtcbm91dCQuUGxheWVyID0gUGxheWVyID0gKGZ1bmN0aW9uKCl7XG4gIFBsYXllci5kaXNwbGF5TmFtZSA9ICdQbGF5ZXInO1xuICB2YXIgcHJvdG90eXBlID0gUGxheWVyLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBQbGF5ZXI7XG4gIGltcG9ydEFsbCQocHJvdG90eXBlLCBhcmd1bWVudHNbMF0pO1xuICBpbXBvcnRBbGwkKHByb3RvdHlwZSwgYXJndW1lbnRzWzFdKTtcbiAgZnVuY3Rpb24gUGxheWVyKGdyYXBoaWNzLCB4LCB5LCBwdG9vbHMpe1xuICAgIHRoaXMucHRvb2xzID0gcHRvb2xzO1xuICAgIHJlYWRvdXQuYWRkUmVhZGVyKCdwbGF5ZXItcG9zJywgJ1BsYXllcicpO1xuICAgIHRoaXMuYWNjZWxlcmF0aW9uWCA9IDA7XG4gICAgdGhpcy5ob3Jpem9udGFsRmFjaW5nID0gU3RhdGUuTEVGVDtcbiAgICB0aGlzLmludGVuZGVkVmVydGljYWxGYWNpbmcgPSBTdGF0ZS5IT1JJWk9OVEFMO1xuICAgIHRoaXMub25Hcm91bmQgPSBmYWxzZTtcbiAgICB0aGlzLmp1bXBBY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmludGVyYWN0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5raW5lbWF0aWNzWCA9IG5ldyBLaW5lbWF0aWNzKHgsIDApO1xuICAgIHRoaXMua2luZW1hdGljc1kgPSBuZXcgS2luZW1hdGljcyh5LCAwKTtcbiAgICB0aGlzLndhbGtBbmltYXRpb24gPSBuZXcgV2Fsa2luZ0FuaW1hdGlvbihrTnVtV2Fsa0ZyYW1lcywga1dhbGtGcHMpO1xuICAgIHRoaXMuaW52aW5jaWJsZVRpbWVyID0gbmV3IFRpbWVyKGtJbnZpbmNpYmxlVGltZSk7XG4gICAgdGhpcy5oZWFsdGggPSBuZXcgSGVhbHRoKGdyYXBoaWNzKTtcbiAgICB0aGlzLmd1bkh1ZCA9IG5ldyBHdW5FeHBlcmllbmNlSFVEKGdyYXBoaWNzKTtcbiAgICB0aGlzLnNwcml0ZXMgPSB0aGlzLmluaXRpYWxpc2VTcHJpdGVzKGdyYXBoaWNzKTtcbiAgICB0aGlzLmRhbWFnZVRleHQgPSBuZXcgRGFtYWdlVGV4dChncmFwaGljcyk7XG4gICAgRGFtYWdlVGV4dHMuYWRkRGFtYWdlYWJsZSh0aGlzKTtcbiAgICB0aGlzLmd1biA9IG5ldyBQb2xhclN0YXIoZ3JhcGhpY3MpO1xuICB9XG4gIHByb3RvdHlwZS5pbml0aWFsaXNlU3ByaXRlcyA9IGZ1bmN0aW9uKGdyYXBoaWNzLCBzcHJpdGVNYXApe1xuICAgIHNwcml0ZU1hcCA9PSBudWxsICYmIChzcHJpdGVNYXAgPSB7fSk7XG4gICAgcmV0dXJuIFNwcml0ZVN0YXRlLmdlbmVyYXRlV2l0aChmdW5jdGlvbihzdGF0ZSl7XG4gICAgICB2YXIgdGlsZVgsIHRpbGVZO1xuICAgICAgdGlsZVggPSAoZnVuY3Rpb24oKXtcbiAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgIGNhc2Ugc3RhdGUuV0FMS0lORzpcbiAgICAgICAgICByZXR1cm4ga1dhbGtGcmFtZTtcbiAgICAgICAgY2FzZSBzdGF0ZS5TVEFORElORzpcbiAgICAgICAgICByZXR1cm4ga1N0YW5kRnJhbWU7XG4gICAgICAgIGNhc2Ugc3RhdGUuSlVNUElORzpcbiAgICAgICAgICByZXR1cm4ga0p1bXBGcmFtZTtcbiAgICAgICAgY2FzZSBzdGF0ZS5GQUxMSU5HOlxuICAgICAgICAgIHJldHVybiBrRmFsbEZyYW1lO1xuICAgICAgICBjYXNlIHN0YXRlLklOVEVSQUNUSU5HOlxuICAgICAgICAgIHJldHVybiBrQmFja0ZyYW1lO1xuICAgICAgICB9XG4gICAgICB9KCkpO1xuICAgICAgaWYgKHN0YXRlLlVQKSB7XG4gICAgICAgIHRpbGVYICs9IGtVcEZyYW1lT2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLkRPV04pIHtcbiAgICAgICAgdGlsZVggPSBrRG93bkZyYW1lO1xuICAgICAgfVxuICAgICAgdGlsZVkgPSBrQ2hhcmFjdGVyRnJhbWUgKyAoc3RhdGUuTEVGVCA/IDAgOiAxKTtcbiAgICAgIGlmIChzdGF0ZS5XQUxLSU5HKSB7XG4gICAgICAgIHRpbGVYICs9IChmdW5jdGlvbigpe1xuICAgICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgIGNhc2Ugc3RhdGUuU1RSSURFX0xFRlQ6XG4gICAgICAgICAgICByZXR1cm4ga1N0cmlkZUxlZnRGcmFtZU9mZnNldDtcbiAgICAgICAgICBjYXNlIHN0YXRlLlNUUklERV9SSUdIVDpcbiAgICAgICAgICAgIHJldHVybiBrU3RyaWRlUmlnaHRGcmFtZU9mZnNldDtcbiAgICAgICAgICBjYXNlIHN0YXRlLlNUUklERV9NSURETEU6XG4gICAgICAgICAgICByZXR1cm4ga1N0cmlkZU1pZGRsZUZyYW1lT2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgU3ByaXRlKGdyYXBoaWNzLCAnTXlDaGFyJywgdHB4KHRpbGVYKSwgdHB4KHRpbGVZKSwgdHB4KDEpLCB0cHgoMSkpO1xuICAgIH0pO1xuICB9O1xuICBwcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oZWxhcHNlZFRpbWUsIG1hcCl7XG4gICAgdmFyIGFjY1gsIGFjY1k7XG4gICAgdGhpcy5oZWFsdGgudXBkYXRlKCk7XG4gICAgdGhpcy53YWxrQW5pbWF0aW9uLnVwZGF0ZShlbGFwc2VkVGltZSk7XG4gICAgdGhpcy5ndW4udXBkYXRlUHJvamVjdGlsZXMoZWxhcHNlZFRpbWUsIG1hcCwgdGhpcy5wdG9vbHMpO1xuICAgIHJlYWRvdXQudXBkYXRlKCdwbGF5ZXItcG9zJywgc3RkLnJvdW5kKHRoaXMuY2VudGVyWCkgKyBcIixcIiArIHN0ZC5yb3VuZCh0aGlzLmNlbnRlclkpKTtcbiAgICBhY2NYID0gdGhpcy5vbkdyb3VuZFxuICAgICAgPyB0aGlzLmFjY2VsZXJhdGlvblggPT09IDBcbiAgICAgICAgPyBrRnJpY3Rpb25BY2NcbiAgICAgICAgOiB0aGlzLmFjY2VsZXJhdGlvblggPCAwXG4gICAgICAgICAgPyBrV2Fsa0FjYy5uZWdhdGl2ZVxuICAgICAgICAgIDoga1dhbGtBY2MucG9zaXRpdmVcbiAgICAgIDogdGhpcy5hY2NlbGVyYXRpb25YID09PSAwXG4gICAgICAgID8ga1plcm9cbiAgICAgICAgOiB0aGlzLmFjY2VsZXJhdGlvblggPCAwXG4gICAgICAgICAgPyBrQWlyQWNjLm5lZ2F0aXZlXG4gICAgICAgICAgOiBrQWlyQWNjLnBvc2l0aXZlO1xuICAgIHRoaXMudXBkYXRlWChrQ29sbGlzaW9uUmVjdGFuZ2xlLCBhY2NYLCB0aGlzLmtpbmVtYXRpY3NYLCB0aGlzLmtpbmVtYXRpY3NZLCBlbGFwc2VkVGltZSwgbWFwKTtcbiAgICBhY2NZID0gdGhpcy5qdW1wQWN0aXZlICYmIHRoaXMua2luZW1hdGljc1kudmVsb2NpdHkgPCAwID8ga0p1bXBHcmF2aXR5QWNjIDoga0dyYXZpdHlBY2M7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlWShrQ29sbGlzaW9uUmVjdGFuZ2xlLCBhY2NZLCB0aGlzLmtpbmVtYXRpY3NYLCB0aGlzLmtpbmVtYXRpY3NZLCBlbGFwc2VkVGltZSwgbWFwKTtcbiAgfTtcbiAgcHJvdG90eXBlLnRha2VEYW1hZ2UgPSBmdW5jdGlvbihkYW1hZ2Upe1xuICAgIGRhbWFnZSA9PSBudWxsICYmIChkYW1hZ2UgPSAxKTtcbiAgICBpZiAoIXRoaXMuaW52aW5jaWJsZVRpbWVyLmlzQWN0aXZlKSB7XG4gICAgICB0aGlzLmhlYWx0aC50YWtlRGFtYWdlKGRhbWFnZSk7XG4gICAgICB0aGlzLmtpbmVtYXRpY3NZLnZlbG9jaXR5ID0gc3RkLm1pbigta1Nob3J0SnVtcFNwZWVkLCB0aGlzLmtpbmVtYXRpY3NZLnZlbG9jaXR5KTtcbiAgICAgIHRoaXMuaW52aW5jaWJsZSA9IHRydWU7XG4gICAgICB0aGlzLmludmluY2libGVUaW1lci5yZXNldCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZGFtYWdlVGV4dC5zZXREYW1hZ2UoZGFtYWdlKTtcbiAgICB9XG4gIH07XG4gIHByb3RvdHlwZS5jb2xsZWN0UGlja3VwID0gZnVuY3Rpb24ocGlja3VwKXtcbiAgICBzdGQubG9nKCdTRlg6IERpbmchJyk7XG4gICAgc3RkLmxvZyhwaWNrdXAsIFBpY2t1cC5FWFBFUklFTkNFKTtcbiAgICBpZiAocGlja3VwLnR5cGUgPT09IFBpY2t1cC5FWFBFUklFTkNFKSB7XG4gICAgICB0aGlzLmd1bi5jb2xsZWN0RXhwZXJpZW5jZShwaWNrdXAudmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXMuZ3VuSHVkLmFjdGl2YXRlRmxhc2goKTtcbiAgICB9XG4gIH07XG4gIHByb3RvdHlwZS5zcHJpdGVJc1Zpc2libGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBkdXR5O1xuICAgIGR1dHkgPSBzdGQuZGl2KHRoaXMuaW52aW5jaWJsZVRpbWVyLmN1cnJlbnRUaW1lLCBrSW52aW5jaWJsZUZsYXNoVGltZSkgJSAyID09PSAwO1xuICAgIHJldHVybiAhKHRoaXMuaW52aW5jaWJsZVRpbWVyLmlzQWN0aXZlICYmIGR1dHkpO1xuICB9O1xuICBwcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGdyYXBoaWNzKXtcbiAgICB2YXIgc3RhdGU7XG4gICAgaWYgKGNvbmZpZy5zaG93Q29sbGlzaW9ucykge1xuICAgICAgZ3JhcGhpY3MudmlzdWFsaXNlUmVjdCh0aGlzLmRhbWFnZUNvbGxpc2lvbigpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3ByaXRlSXNWaXNpYmxlKCkpIHtcbiAgICAgIHN0YXRlID0gdGhpcy5nZXRTcHJpdGVTdGF0ZSgpO1xuICAgICAgdGhpcy5ndW4uZHJhdyhncmFwaGljcywgdGhpcy5raW5lbWF0aWNzWC5wb3NpdGlvbiwgdGhpcy5raW5lbWF0aWNzWS5wb3NpdGlvbiwgc3RhdGUpO1xuICAgICAgcmV0dXJuIHRoaXMuc3ByaXRlc1tzdGF0ZS5rZXldLmRyYXcoZ3JhcGhpY3MsIHRoaXMua2luZW1hdGljc1gucG9zaXRpb24sIHRoaXMua2luZW1hdGljc1kucG9zaXRpb24pO1xuICAgIH1cbiAgfTtcbiAgcHJvdG90eXBlLmRyYXdIdWQgPSBmdW5jdGlvbihncmFwaGljcyl7XG4gICAgaWYgKCF0aGlzLnNwcml0ZUlzVmlzaWJsZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZ3VuLmRyYXdIdWQoZ3JhcGhpY3MsIHRoaXMuZ3VuSHVkKTtcbiAgICByZXR1cm4gdGhpcy5oZWFsdGguZHJhdyhncmFwaGljcyk7XG4gIH07XG4gIHByb3RvdHlwZS5nZXRTcHJpdGVTdGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIG1vdGlvblR5cGU7XG4gICAgbW90aW9uVHlwZSA9IHRoaXMuaW50ZXJhY3RpbmdcbiAgICAgID8gU3RhdGUuSU5URVJBQ1RJTkdcbiAgICAgIDogdGhpcy5vbkdyb3VuZFxuICAgICAgICA/IHRoaXMuYWNjZWxlcmF0aW9uWCA9PT0gMFxuICAgICAgICAgID8gU3RhdGUuU1RBTkRJTkdcbiAgICAgICAgICA6IFN0YXRlLldBTEtJTkdcbiAgICAgICAgOiB0aGlzLmtpbmVtYXRpY3NZLnZlbG9jaXR5IDwgMFxuICAgICAgICAgID8gU3RhdGUuSlVNUElOR1xuICAgICAgICAgIDogU3RhdGUuRkFMTElORztcbiAgICByZXR1cm4gU3ByaXRlU3RhdGUubWFrZSh0aGlzLmhvcml6b250YWxGYWNpbmcsIHRoaXMudmVydGljYWxGYWNpbmcoKSwgbW90aW9uVHlwZSwgdGhpcy53YWxrQW5pbWF0aW9uLnN0cmlkZSgpKTtcbiAgfTtcbiAgcHJvdG90eXBlLm9uQ29sbGlzaW9uID0gZnVuY3Rpb24oc2lkZSwgaXNEZWx0YURpcmVjdGlvbil7XG4gICAgc3dpdGNoIChzaWRlKSB7XG4gICAgY2FzZSBTaWRlLlRPUDpcbiAgICAgIGlmIChpc0RlbHRhRGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMua2luZW1hdGljc1kudmVsb2NpdHkgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucHRvb2xzLmZyb250U3lzdGVtLmFkZE5ld1BhcnRpY2xlKG5ldyBIZWFkQnVtcFBhcnRpY2xlKHRoaXMucHRvb2xzLmdyYXBoaWNzLCB0aGlzLmNlbnRlclgsIHRoaXMua2luZW1hdGljc1kucG9zaXRpb24gKyBrQ29sbGlzaW9uUmVjdGFuZ2xlLmJvdW5kaW5nQm94LnRvcCkpO1xuICAgIGNhc2UgU2lkZS5CT1RUT006XG4gICAgICB0aGlzLm9uR3JvdW5kID0gdHJ1ZTtcbiAgICAgIGlmIChpc0RlbHRhRGlyZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtpbmVtYXRpY3NZLnZlbG9jaXR5ID0gMDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU2lkZS5MRUZUOlxuICAgICAgaWYgKGlzRGVsdGFEaXJlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2luZW1hdGljc1gudmVsb2NpdHkgPSAwO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTaWRlLlJJR0hUOlxuICAgICAgaWYgKGlzRGVsdGFEaXJlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2luZW1hdGljc1gudmVsb2NpdHkgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcHJvdG90eXBlLm9uRGVsdGEgPSBmdW5jdGlvbihzaWRlKXtcbiAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICBjYXNlIFNpZGUuVE9QOlxuICAgICAgcmV0dXJuIHRoaXMub25Hcm91bmQgPSBmYWxzZTtcbiAgICBjYXNlIFNpZGUuQk9UVE9NOlxuICAgICAgcmV0dXJuIHRoaXMub25Hcm91bmQgPSBmYWxzZTtcbiAgICBjYXNlIFNpZGUuTEVGVDpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU2lkZS5SSUdIVDpcbiAgICB9XG4gIH07XG4gIHByb3RvdHlwZS5kYW1hZ2VDb2xsaXNpb24gPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBrQ29sbGlzaW9uUmVjdGFuZ2xlLmJvdW5kaW5nQm94LnRyYW5zbGF0ZSh0aGlzLmtpbmVtYXRpY3NYLnBvc2l0aW9uLCB0aGlzLmtpbmVtYXRpY3NZLnBvc2l0aW9uKTtcbiAgfTtcbiAgcHJvdG90eXBlLnN0YXJ0TW92aW5nTGVmdCA9IGZ1bmN0aW9uKCl7XG4gICAgaWYgKHRoaXMub25Hcm91bmQgJiYgdGhpcy5hY2NlbGVyYXRpb25YID09PSAwKSB7XG4gICAgICB0aGlzLndhbGtBbmltYXRpb24ucmVzZXQoKTtcbiAgICB9XG4gICAgdGhpcy5ob3Jpem9udGFsRmFjaW5nID0gU3RhdGUuTEVGVDtcbiAgICB0aGlzLmFjY2VsZXJhdGlvblggPSAtMTtcbiAgICByZXR1cm4gdGhpcy5pbnRlcmFjdGluZyA9IGZhbHNlO1xuICB9O1xuICBwcm90b3R5cGUuc3RhcnRNb3ZpbmdSaWdodCA9IGZ1bmN0aW9uKCl7XG4gICAgaWYgKHRoaXMub25Hcm91bmQgJiYgdGhpcy5hY2NlbGVyYXRpb25YID09PSAwKSB7XG4gICAgICB0aGlzLndhbGtBbmltYXRpb24ucmVzZXQoKTtcbiAgICB9XG4gICAgdGhpcy5ob3Jpem9udGFsRmFjaW5nID0gU3RhdGUuUklHSFQ7XG4gICAgdGhpcy5hY2NlbGVyYXRpb25YID0gMTtcbiAgICByZXR1cm4gdGhpcy5pbnRlcmFjdGluZyA9IGZhbHNlO1xuICB9O1xuICBwcm90b3R5cGUuc3RvcE1vdmluZyA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuYWNjZWxlcmF0aW9uWCA9IDA7XG4gIH07XG4gIHByb3RvdHlwZS5zdGFydEp1bXAgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuanVtcEFjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5pbnRlcmFjdGluZyA9IGZhbHNlO1xuICAgIGlmICh0aGlzLm9uR3JvdW5kKSB7XG4gICAgICByZXR1cm4gdGhpcy5raW5lbWF0aWNzWS52ZWxvY2l0eSA9IC1rSnVtcFNwZWVkO1xuICAgIH1cbiAgfTtcbiAgcHJvdG90eXBlLnN0b3BKdW1wID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5qdW1wQWN0aXZlID0gZmFsc2U7XG4gIH07XG4gIHByb3RvdHlwZS5zdGFydEZpcmUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmd1bi5zdGFydEZpcmUodGhpcy5nZXRTcHJpdGVTdGF0ZSgpLCB0aGlzLmtpbmVtYXRpY3NYLnBvc2l0aW9uLCB0aGlzLmtpbmVtYXRpY3NZLnBvc2l0aW9uKTtcbiAgfTtcbiAgcHJvdG90eXBlLnN0b3BGaXJlID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5ndW4uc3RvcEZpcmUoKTtcbiAgfTtcbiAgcHJvdG90eXBlLmxvb2tVcCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5pbnRlbmRlZFZlcnRpY2FsRmFjaW5nID0gU3RhdGUuVVA7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJhY3RpbmcgPSBmYWxzZTtcbiAgfTtcbiAgcHJvdG90eXBlLmxvb2tEb3duID0gZnVuY3Rpb24oKXtcbiAgICBpZiAodGhpcy5pbnRlbmRlZFZlcnRpY2FsRmFjaW5nID09PSBTdGF0ZS5ET1dOKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaW50ZW5kZWRWZXJ0aWNhbEZhY2luZyA9IFN0YXRlLkRPV047XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJhY3RpbmcgPSB0aGlzLm9uR3JvdW5kO1xuICB9O1xuICBwcm90b3R5cGUubG9va0hvcml6b250YWwgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmludGVuZGVkVmVydGljYWxGYWNpbmcgPSBTdGF0ZS5IT1JJWk9OVEFMO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCAnY2VudGVyWCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5raW5lbWF0aWNzWC5wb3NpdGlvbiArIGtIYWxmVGlsZTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCAnY2VudGVyWScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5raW5lbWF0aWNzWS5wb3NpdGlvbiArIGtIYWxmVGlsZTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xuICBwcm90b3R5cGUuZ2V0RGFtYWdlVGV4dCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuZGFtYWdlVGV4dDtcbiAgfTtcbiAgcHJvdG90eXBlLmdldFByb2plY3RpbGVzID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5ndW4uZ2V0UHJvamVjdGlsZXMoKTtcbiAgfTtcbiAgcHJvdG90eXBlLnZlcnRpY2FsRmFjaW5nID0gZnVuY3Rpb24oKXtcbiAgICBpZiAodGhpcy5vbkdyb3VuZCAmJiB0aGlzLmludGVuZGVkVmVydGljYWxGYWNpbmcgPT09IFN0YXRlLkRPV04pIHtcbiAgICAgIHJldHVybiBTdGF0ZS5IT1JJWk9OVEFMO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnRlbmRlZFZlcnRpY2FsRmFjaW5nO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFBsYXllcjtcbn0oRGFtYWdlYWJsZS5wcm90b3R5cGUsIE1hcENvbGxpZGFibGUucHJvdG90eXBlKSk7XG5mdW5jdGlvbiBpbXBvcnRBbGwkKG9iaiwgc3JjKXtcbiAgZm9yICh2YXIga2V5IGluIHNyYykgb2JqW2tleV0gPSBzcmNba2V5XTtcbiAgcmV0dXJuIG9iajtcbn0iLCJ2YXIgc3RkLCBQb2xhclZlY3Rvciwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcbnN0ZCA9IHJlcXVpcmUoJ3N0ZCcpO1xub3V0JC5Qb2xhclZlY3RvciA9IFBvbGFyVmVjdG9yID0gKGZ1bmN0aW9uKCl7XG4gIFBvbGFyVmVjdG9yLmRpc3BsYXlOYW1lID0gJ1BvbGFyVmVjdG9yJztcbiAgdmFyIHByb3RvdHlwZSA9IFBvbGFyVmVjdG9yLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBQb2xhclZlY3RvcjtcbiAgZnVuY3Rpb24gUG9sYXJWZWN0b3IobWFnLCBhbmdsZSl7XG4gICAgdGhpcy5tYWcgPSBtYWc7XG4gICAgdGhpcy5hbmdsZSA9IGFuZ2xlO1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsICd4Jywge1xuICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLm1hZyAqIHN0ZC5jb3ModGhpcy5hbmdsZSk7XG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgJ3knLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMubWFnICogc3RkLnNpbih0aGlzLmFuZ2xlKTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gUG9sYXJWZWN0b3I7XG59KCkpOyIsInZhciBQcm9qZWN0aWxlLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xub3V0JC5Qcm9qZWN0aWxlID0gUHJvamVjdGlsZSA9IChmdW5jdGlvbigpe1xuICBQcm9qZWN0aWxlLmRpc3BsYXlOYW1lID0gJ1Byb2plY3RpbGUnO1xuICB2YXIgcHJvdG90eXBlID0gUHJvamVjdGlsZS5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gUHJvamVjdGlsZTtcbiAgZnVuY3Rpb24gUHJvamVjdGlsZShkYW1hZ2Upe1xuICAgIHRoaXMuY29udGFjdERhbWFnZSA9IGRhbWFnZTtcbiAgfVxuICBwcm90b3R5cGUuY29sbGlzaW9uUmVjdGFuZ2xlID0gZnVuY3Rpb24oKXt9O1xuICBwcm90b3R5cGUuY29sbGlkZVdpdGhFbmVteSA9IGZ1bmN0aW9uKCl7fTtcbiAgcmV0dXJuIFByb2plY3RpbGU7XG59KCkpOyIsInZhciBjb25maWcsIGVsbSwgYXBwbHlTdHlsZXMsIFJlYWRlciwgaG9zdCwgcmVhZGVycywgaW5zdGFsbCwgYWRkUmVhZGVyLCB1cGRhdGUsIHJlbW92ZVJlYWRlciwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcbmNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5lbG0gPSBiaW5kJChkb2N1bWVudCwgJ2NyZWF0ZUVsZW1lbnQnKTtcbmFwcGx5U3R5bGVzID0gZnVuY3Rpb24oZWwsIHN0eWxlcyl7XG4gIHZhciBrLCB2LCByZXN1bHRzJCA9IFtdO1xuICBmb3IgKGsgaW4gc3R5bGVzKSB7XG4gICAgdiA9IHN0eWxlc1trXTtcbiAgICByZXN1bHRzJC5wdXNoKGVsLnN0eWxlW2tdID0gdik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHMkO1xufTtcblJlYWRlciA9IChmdW5jdGlvbigpe1xuICBSZWFkZXIuZGlzcGxheU5hbWUgPSAnUmVhZGVyJztcbiAgdmFyIHByb3RvdHlwZSA9IFJlYWRlci5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gUmVhZGVyO1xuICBmdW5jdGlvbiBSZWFkZXIobmFtZSwgbGFiZWxUZXh0LCB2YWx1ZSl7XG4gICAgdmFyIHRoYXQ7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmxhYmVsVGV4dCA9IGxhYmVsVGV4dDtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5kb20gPSBlbG0oJ3RyJyk7XG4gICAgdGhpcy5sYWJlbCA9IGVsbSgndGQnKTtcbiAgICB0aGlzLm91dHB1dCA9IGVsbSgndGQnKTtcbiAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLmxhYmVsKTtcbiAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLm91dHB1dCk7XG4gICAgdGhpcy5sYWJlbC5pbm5lckhUTUwgPSB0aGlzLmxhYmVsVGV4dDtcbiAgICBpZiAodGhhdCA9IHRoaXMudmFsdWUpIHtcbiAgICAgIHRoaXMub3V0cHV0LmlubmVySFRNTCA9IHRoYXQ7XG4gICAgfVxuICB9XG4gIHByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbih2YWx1ZSl7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzLm91dHB1dC5pbm5lckhUTUwgPSB0aGlzLnZhbHVlO1xuICB9O1xuICBwcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuZG9tLnN0eWxlcy5kaXNwbGF5ID0gJ25vbmUnO1xuICB9O1xuICBwcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuZG9tLnN0eWxlcy5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgfTtcbiAgcHJvdG90eXBlLmluc3RhbGwgPSBmdW5jdGlvbihob3N0KXtcbiAgICByZXR1cm4gaG9zdC5hcHBlbmRDaGlsZCh0aGlzLmRvbSk7XG4gIH07XG4gIHByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tKTtcbiAgfTtcbiAgcmV0dXJuIFJlYWRlcjtcbn0oKSk7XG5ob3N0ID0gZWxtKCd0YWJsZScpO1xucmVhZGVycyA9IHt9O1xuYXBwbHlTdHlsZXMoaG9zdCwge1xuICBmb250RmFtaWx5OiAnbW9ub3NwYWNlJyxcbiAgd2lkdGg6ICcxMDAlJyxcbiAgcGFkZGluZ0xlZnQ6ICcxMHB4JyxcbiAgY29sb3I6ICdsaWdodGdyZXknLFxuICBib3JkZXJXaWR0aDogXCIzcHggMXB4XCJcbn0pO1xub3V0JC5pbnN0YWxsID0gaW5zdGFsbCA9IGZ1bmN0aW9uKCl7XG4gIGlmIChjb25maWcuc2hvd1JlYWRvdXQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChob3N0KTtcbiAgfVxufTtcbm91dCQuYWRkUmVhZGVyID0gYWRkUmVhZGVyID0gZnVuY3Rpb24obmFtZSwgbGFiZWwsIHZhbHVlKXtcbiAgcmVhZGVyc1tuYW1lXSA9IG5ldyBSZWFkZXIobmFtZSwgbGFiZWwsIHZhbHVlKTtcbiAgcmV0dXJuIHJlYWRlcnNbbmFtZV0uaW5zdGFsbChob3N0KTtcbn07XG5vdXQkLnVwZGF0ZSA9IHVwZGF0ZSA9IGZ1bmN0aW9uKHJlYWRlck5hbWUsIHZhbHVlKXtcbiAgdmFyIHJlZiQ7XG4gIHJldHVybiAocmVmJCA9IHJlYWRlcnNbcmVhZGVyTmFtZV0pICE9IG51bGwgPyByZWYkLnVwZGF0ZSh2YWx1ZSkgOiB2b2lkIDg7XG59O1xub3V0JC5yZW1vdmVSZWFkZXIgPSByZW1vdmVSZWFkZXIgPSBmdW5jdGlvbihuYW1lKXtcbiAgdmFyIHJlZiQ7XG4gIHJlYWRlcnNbbmFtZV1bJ2RlbGV0ZSddKCk7XG4gIHJldHVybiByZWYkID0gcmVhZGVyc1tuYW1lXSwgZGVsZXRlIHJlYWRlcnNbbmFtZV0sIHJlZiQ7XG59O1xuZnVuY3Rpb24gYmluZCQob2JqLCBrZXksIHRhcmdldCl7XG4gIHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gKHRhcmdldCB8fCBvYmopW2tleV0uYXBwbHkob2JqLCBhcmd1bWVudHMpIH07XG59IiwidmFyIHVuaXRzLCBSZWN0YW5nbGUsIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG51bml0cyA9IHJlcXVpcmUoJy4vdW5pdHMnKTtcbm91dCQuUmVjdGFuZ2xlID0gUmVjdGFuZ2xlID0gKGZ1bmN0aW9uKCl7XG4gIFJlY3RhbmdsZS5kaXNwbGF5TmFtZSA9ICdSZWN0YW5nbGUnO1xuICB2YXIgcHJvdG90eXBlID0gUmVjdGFuZ2xlLnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBSZWN0YW5nbGU7XG4gIGZ1bmN0aW9uIFJlY3RhbmdsZSh4LCB5LCB3LCBoLCBtKXtcbiAgICBtID09IG51bGwgJiYgKG0gPSAxKTtcbiAgICB0aGlzLnggPSB4ICogbTtcbiAgICB0aGlzLnkgPSB5ICogbTtcbiAgICB0aGlzLncgPSB3ICogbTtcbiAgICB0aGlzLmggPSBoICogbTtcbiAgICB0aGlzLnRvcCA9IHRoaXMueTtcbiAgICB0aGlzLmxlZnQgPSB0aGlzLng7XG4gICAgdGhpcy5yaWdodCA9IHRoaXMueCArIHRoaXMudztcbiAgICB0aGlzLmJvdHRvbSA9IHRoaXMueSArIHRoaXMuaDtcbiAgfVxuICBwcm90b3R5cGUuY29sbGlkZXNXaXRoID0gZnVuY3Rpb24ob3RoZXIpe1xuICAgIHJldHVybiB0aGlzLnJpZ2h0ID49IG90aGVyLmxlZnQgJiYgdGhpcy5sZWZ0IDw9IG90aGVyLnJpZ2h0ICYmIHRoaXMudG9wIDw9IG90aGVyLmJvdHRvbSAmJiB0aGlzLmJvdHRvbSA+PSBvdGhlci50b3A7XG4gIH07XG4gIHByb3RvdHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbih4LCB5KXtcbiAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLnggKyB4LCB0aGlzLnkgKyB5LCB0aGlzLncsIHRoaXMuaCk7XG4gIH07XG4gIHJldHVybiBSZWN0YW5nbGU7XG59KCkpOyIsInZhciByYWYsIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5yYWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5pbXBvcnQkKG91dCQsIHtcbiAgZGVsYXk6IGZ1bmN0aW9uKHRpbWUsIM67KXtcbiAgICByZXR1cm4gcmFmKM67KTtcbiAgfVxufSk7XG5mdW5jdGlvbiBpbXBvcnQkKG9iaiwgc3JjKXtcbiAgdmFyIG93biA9IHt9Lmhhc093blByb3BlcnR5O1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSBpZiAob3duLmNhbGwoc3JjLCBrZXkpKSBvYmpba2V5XSA9IHNyY1trZXldO1xuICByZXR1cm4gb2JqO1xufSIsInZhciBzdGQsIHF1ZXVlLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG5xdWV1ZSA9IFtdO1xuaW1wb3J0JChvdXQkLCB7XG4gIHB1c2hFdmVudDogZnVuY3Rpb24oZXZlbnQpe1xuICAgIHJldHVybiBxdWV1ZS5wdXNoKGV2ZW50KTtcbiAgfSxcbiAgcG9sbEV2ZW50OiBmdW5jdGlvbigpe1xuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBxdWV1ZS5zaGlmdCgpO1xuICAgIH1cbiAgfVxufSk7XG5mdW5jdGlvbiBpbXBvcnQkKG9iaiwgc3JjKXtcbiAgdmFyIG93biA9IHt9Lmhhc093blByb3BlcnR5O1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSBpZiAob3duLmNhbGwoc3JjLCBrZXkpKSBvYmpba2V5XSA9IHNyY1trZXldO1xuICByZXR1cm4gb2JqO1xufSIsInZhciBzdGQsIGRlbGF5LCB0aW1lciwgc2NyZWVuLCBrZXlib2FyZCwgZXZlbnRRdWV1ZSwgUmVjdCwgU3VyZmFjZSwgcmVmJCwgSU5JVF9FVkVSWVRISU5HLCBGVUxMU0NSRUVOLCBpbml0LCBLRVksIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5zdGQgPSByZXF1aXJlKCdzdGQnKTtcbmRlbGF5ID0gcmVxdWlyZSgnLi9kZWxheScpO1xudGltZXIgPSByZXF1aXJlKCcuL3RpbWVyJyk7XG5zY3JlZW4gPSByZXF1aXJlKCcuL3NjcmVlbicpO1xua2V5Ym9hcmQgPSByZXF1aXJlKCcuL2tleWJvYXJkJyk7XG5ldmVudFF1ZXVlID0gcmVxdWlyZSgnLi9ldmVudC1xdWV1ZScpO1xub3V0JC5SZWN0ID0gUmVjdCA9IHJlcXVpcmUoJy4vcmVjdCcpO1xub3V0JC5TdXJmYWNlID0gU3VyZmFjZSA9IHJlcXVpcmUoJy4vc3VyZmFjZScpO1xucmVmJCA9IHN0ZFsnZW51bSddLCBJTklUX0VWRVJZVEhJTkcgPSByZWYkWzBdLCBGVUxMU0NSRUVOID0gcmVmJFsxXTtcbm91dCQuaW5pdCA9IGluaXQgPSBmdW5jdGlvbihtb2RlKXtcbiAgc3RkLmxvZyhcIlNETDo6SW5pdCAtIHdpdGggbW9kZTpcIiwgbW9kZSk7XG4gIHRpbWVyLmluaXQoKTtcbiAgcmV0dXJuIGtleWJvYXJkLmluaXQoKTtcbn07XG5vdXQkLklOSVRfRVZFUllUSElORyA9IElOSVRfRVZFUllUSElORztcbm91dCQuRlVMTFNDUkVFTiA9IEZVTExTQ1JFRU47XG5vdXQkLktFWURPV04gPSBrZXlib2FyZC5LRVlET1dOO1xub3V0JC5LRVlVUCA9IGtleWJvYXJkLktFWVVQO1xub3V0JC5LRVkgPSBLRVkgPSBrZXlib2FyZC5LRVlDT0RFUztcbm91dCQuZGVsYXkgPSBkZWxheS5kZWxheTtcbm91dCQuZ2V0VGlja3MgPSB0aW1lci5nZXRUaWNrcztcbm91dCQucG9sbEV2ZW50ID0gZXZlbnRRdWV1ZS5wb2xsRXZlbnQ7XG5vdXQkLnNldFZpZGVvTW9kZSA9IHNjcmVlbi5zZXRWaWRlb01vZGU7XG5vdXQkLmJsaXRTdXJmYWNlID0gU3VyZmFjZS5ibGl0U3VyZmFjZTtcbm91dCQuc2V0Q29sb3JLZXkgPSBTdXJmYWNlLnNldENvbG9yS2V5O1xub3V0JC5sb2FkSW1hZ2UgPSBTdXJmYWNlLmxvYWRJbWFnZTsiLCJ2YXIgc3RkLCBxdWV1ZSwgcmVmJCwgS0VZRE9XTiwgS0VZVVAsIEtFWUNPREVTLCBtb25pdG9yS2V5cywgaW5pdCwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcbnN0ZCA9IHJlcXVpcmUoJ3N0ZCcpO1xucXVldWUgPSByZXF1aXJlKCcuL2V2ZW50LXF1ZXVlJyk7XG5yZWYkID0gc3RkWydlbnVtJ10sIEtFWURPV04gPSByZWYkWzBdLCBLRVlVUCA9IHJlZiRbMV07XG5vdXQkLktFWUNPREVTID0gS0VZQ09ERVMgPSB7XG4gIEVTQ0FQRTogMjcsXG4gIExFRlQ6IDM3LFxuICBVUDogMzgsXG4gIFJJR0hUOiAzOSxcbiAgRE9XTjogNDAsXG4gIE9ORTogNDksXG4gIFRXTzogNTAsXG4gIFRIUkVFOiA1MSxcbiAgRk9VUjogNTIsXG4gIEZJVkU6IDUzLFxuICBTSVg6IDU0LFxuICBTRVZFTjogNTUsXG4gIEVJR0hUOiA1NixcbiAgTklORTogNTcsXG4gIEE6IDY1LFxuICBROiA4MSxcbiAgUzogODMsXG4gIFc6IDg3LFxuICBYOiA4OCxcbiAgWjogOTBcbn07XG5tb25pdG9yS2V5cyA9IGZ1bmN0aW9uKCl7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbihldmVudCl7XG4gICAgdmFyIHdoaWNoO1xuICAgIHdoaWNoID0gZXZlbnQud2hpY2g7XG4gICAgcXVldWUucHVzaEV2ZW50KHtcbiAgICAgIHR5cGU6IEtFWURPV04sXG4gICAgICBrZXk6IHdoaWNoXG4gICAgfSk7XG4gICAgaWYgKHdoaWNoID09PSBLRVlDT0RFUy5VUCB8fCB3aGljaCA9PT0gS0VZQ09ERVMuRE9XTiB8fCB3aGljaCA9PT0gS0VZQ09ERVMuTEVGVCB8fCB3aGljaCA9PT0gS0VZQ09ERVMuUklHSFQpIHtcbiAgICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGZ1bmN0aW9uKGV2ZW50KXtcbiAgICB2YXIgd2hpY2g7XG4gICAgd2hpY2ggPSBldmVudC53aGljaDtcbiAgICBxdWV1ZS5wdXNoRXZlbnQoe1xuICAgICAgdHlwZTogS0VZVVAsXG4gICAgICBrZXk6IHdoaWNoXG4gICAgfSk7XG4gICAgcmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xufTtcbm91dCQuaW5pdCA9IGluaXQgPSBmdW5jdGlvbigpe1xuICBzdGQubG9nKFwiU0RMOjpLZXlib2FyZCAtIE1vbml0b3Jpbmcga2V5IGlucHV0XCIpO1xuICByZXR1cm4gbW9uaXRvcktleXMoKTtcbn07XG5vdXQkLktFWURPV04gPSBLRVlET1dOO1xub3V0JC5LRVlVUCA9IEtFWVVQOyIsInZhciBSZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBSZWN0ID0gKGZ1bmN0aW9uKCl7XG4gIFJlY3QuZGlzcGxheU5hbWUgPSAnUmVjdCc7XG4gIHZhciBwcm90b3R5cGUgPSBSZWN0LnByb3RvdHlwZSwgY29uc3RydWN0b3IgPSBSZWN0O1xuICBmdW5jdGlvbiBSZWN0KHgsIHksIHcsIGgpe1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLncgPSB3O1xuICAgIHRoaXMuaCA9IGg7XG4gIH1cbiAgUmVjdC5jbG9uZSA9IGZ1bmN0aW9uKGFyZyQpe1xuICAgIHZhciB4LCB5LCB3LCBoO1xuICAgIHggPSBhcmckLngsIHkgPSBhcmckLnksIHcgPSBhcmckLncsIGggPSBhcmckLmg7XG4gICAgcmV0dXJuIG5ldyBSZWN0KHgsIHksIHcsIGgpO1xuICB9O1xuICByZXR1cm4gUmVjdDtcbn0oKSk7IiwidmFyIHN0ZCwgU3VyZmFjZSwgYXBwbHlTY2FsZVN0eWxlcywgY3JlYXRlTmV3U2NyZWVuLCBzZXRWaWRlb01vZGUsIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5zdGQgPSByZXF1aXJlKCdzdGQnKTtcblN1cmZhY2UgPSByZXF1aXJlKCcuL3N1cmZhY2UnKTtcbmFwcGx5U2NhbGVTdHlsZXMgPSBmdW5jdGlvbihjYW52YXMsIHNjYWxlRmFjdG9yKXtcbiAgaWYgKHNjYWxlRmFjdG9yICE9PSAwKSB7XG4gICAgcmV0dXJuIGNhbnZhcy5zdHlsZS53aWR0aCA9IGNhbnZhcy53aWR0aCAqIHNjYWxlRmFjdG9yICsgJ3B4JztcbiAgfVxufTtcbmNyZWF0ZU5ld1NjcmVlbiA9IGZ1bmN0aW9uKHcsIGgsIHNjYWxlRmFjdG9yKXtcbiAgdmFyIHNjcmVlbjtcbiAgc2NyZWVuID0gbmV3IFN1cmZhY2UobnVsbCwgdywgaCk7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyZWVuLmNhbnZhcyk7XG4gIGFwcGx5U2NhbGVTdHlsZXMoc2NyZWVuLmNhbnZhcywgc2NhbGVGYWN0b3IpO1xuICByZXR1cm4gc2NyZWVuO1xufTtcbm91dCQuc2V0VmlkZW9Nb2RlID0gc2V0VmlkZW9Nb2RlID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgc2NhbGVGYWN0b3Ipe1xuICBzY2FsZUZhY3RvciA9PSBudWxsICYmIChzY2FsZUZhY3RvciA9IDEpO1xuICByZXR1cm4gY3JlYXRlTmV3U2NyZWVuKHdpZHRoLCBoZWlnaHQsIHNjYWxlRmFjdG9yKTtcbn07IiwidmFyIHN0ZCwgUmVjdCwgbWFrZVRyYW5zcGFyZW50LCBTdXJmYWNlO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG5SZWN0ID0gcmVxdWlyZSgnLi9yZWN0Jyk7XG5tYWtlVHJhbnNwYXJlbnQgPSBmdW5jdGlvbihkYXRhLCBjb2xvcil7XG4gIHZhciBjYW52YXMsIGNvbnRleHQsIHBpeGVscywgaSQsIHRvJCwgaTtcbiAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIGNhbnZhcy53aWR0aCA9IGRhdGEud2lkdGg7XG4gIGNhbnZhcy5oZWlnaHQgPSBkYXRhLmhlaWdodDtcbiAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBjb250ZXh0LmRyYXdJbWFnZShkYXRhLCAwLCAwKTtcbiAgcGl4ZWxzID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgZm9yIChpJCA9IDAsIHRvJCA9IHBpeGVscy5kYXRhLmxlbmd0aDsgaSQgPD0gdG8kOyBpJCArPSA0KSB7XG4gICAgaSA9IGkkO1xuICAgIGlmIChwaXhlbHMuZGF0YVtpICsgMF0gPT09IGNvbG9yWzBdICYmIHBpeGVscy5kYXRhW2kgKyAxXSA9PT0gY29sb3JbMV0gJiYgcGl4ZWxzLmRhdGFbaSArIDJdID09PSBjb2xvclsyXSkge1xuICAgICAgcGl4ZWxzLmRhdGFbaSArIDNdID0gMDtcbiAgICB9XG4gIH1cbiAgY29udGV4dC5wdXRJbWFnZURhdGEocGl4ZWxzLCAwLCAwKTtcbiAgcmV0dXJuIGNhbnZhcztcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFN1cmZhY2UgPSAoZnVuY3Rpb24oKXtcbiAgU3VyZmFjZS5kaXNwbGF5TmFtZSA9ICdTdXJmYWNlJztcbiAgdmFyIHByb3RvdHlwZSA9IFN1cmZhY2UucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IFN1cmZhY2U7XG4gIGZ1bmN0aW9uIFN1cmZhY2Uoc3JjLCB3aWR0aCwgaGVpZ2h0KXtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICAgIHRoaXMuY29sb3JLZXkgPSBudWxsO1xuICAgIHRoaXMucmVzZXRDYW52YXNTaXplKCk7XG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gJ3JlZCc7XG4gICAgdGhpcy5jdHguZmlsbFJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIGlmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5sb2FkSW1hZ2VEYXRhKHNyYyk7XG4gICAgfSBlbHNlIGlmIChzcmMgIT0gbnVsbCkge1xuICAgICAgdGhpcy5zYXZlSW1hZ2VEYXRhKHNyYyk7XG4gICAgfSBlbHNlIHt9XG4gIH1cbiAgcHJvdG90eXBlLnJlc2V0Q2FudmFzU2l6ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLndpZHRoO1xuICAgIHJldHVybiB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgfTtcbiAgcHJvdG90eXBlLmluaGVyaXRTaXplRnJvbUltYWdlID0gZnVuY3Rpb24oZGF0YSl7XG4gICAgaWYgKHRoaXMud2lkdGggPT0gbnVsbCAmJiB0aGlzLmhlaWdodCA9PSBudWxsKSB7XG4gICAgICB0aGlzLndpZHRoID0gZGF0YS5uYXR1cmFsV2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGRhdGEubmF0dXJhbEhlaWdodDtcbiAgICAgIHJldHVybiB0aGlzLnJlc2V0Q2FudmFzU2l6ZSgpO1xuICAgIH1cbiAgfTtcbiAgcHJvdG90eXBlLmxvYWRJbWFnZURhdGEgPSBmdW5jdGlvbihwYXRoKXtcbiAgICB2YXIgZGF0YSwgdGhpcyQgPSB0aGlzO1xuICAgIGRhdGEgPSBuZXcgSW1hZ2U7XG4gICAgZGF0YS5vbmxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAgdGhpcyQuaW5oZXJpdFNpemVGcm9tSW1hZ2UoZGF0YSk7XG4gICAgICByZXR1cm4gdGhpcyQuc2F2ZUltYWdlRGF0YShkYXRhKTtcbiAgICB9O1xuICAgIGRhdGEub25lcnJvciA9IGZ1bmN0aW9uKCl7XG4gICAgICBzdGQubG9nKFwiQ2FudCBsb2FkOlwiLCBwYXRoKTtcbiAgICAgIHJldHVybiB0aGlzJC5jdHguZmlsbFJlY3QoMCwgMCwgdGhpcyQud2lkdGgsIHRoaXMkLmhlaWdodCk7XG4gICAgfTtcbiAgICByZXR1cm4gZGF0YS5zcmMgPSBwYXRoO1xuICB9O1xuICBwcm90b3R5cGUuc2F2ZUltYWdlRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICAgIHRoaXMuZGF0YSA9IHRoaXMuY29sb3JLZXkgPyBtYWtlVHJhbnNwYXJlbnQoZGF0YSwgdGhpcy5jb2xvcktleSkgOiBkYXRhO1xuICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgcmV0dXJuIHRoaXMuY3R4LmRyYXdJbWFnZSh0aGlzLmRhdGEsIDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgfTtcbiAgcHJvdG90eXBlLnNldENvbG9yS2V5ID0gZnVuY3Rpb24oY29sb3Ipe1xuICAgIHRoaXMuY29sb3JLZXkgPSBjb2xvcjtcbiAgICBpZiAodGhpcy5yZWFkeSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2F2ZUltYWdlRGF0YSh0aGlzLmRhdGEpO1xuICAgIH1cbiAgfTtcbiAgcHJvdG90eXBlLmRyYXdSZWN0ID0gZnVuY3Rpb24ocmVjdCwgY29sb3Ipe1xuICAgIGNvbG9yID09IG51bGwgJiYgKGNvbG9yID0gJ2JsYWNrJyk7XG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgcmV0dXJuIHRoaXMuY3R4LmZpbGxSZWN0KHJlY3QueCwgcmVjdC55LCByZWN0LncsIHJlY3QuaCk7XG4gIH07XG4gIHByb3RvdHlwZS5kcmF3Qm94ID0gZnVuY3Rpb24ocmVjdCwgY29sb3Ipe1xuICAgIGNvbG9yID09IG51bGwgJiYgKGNvbG9yID0gJ2JsYWNrJyk7XG4gICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcbiAgICB0aGlzLmN0eC5tb3ZlVG8oMC41ICsgcmVjdC54LCAwLjUgKyByZWN0LnkpO1xuICAgIHRoaXMuY3R4LmxpbmVUbygwLjUgKyByZWN0LngsIC0wLjUgKyByZWN0LnkgKyByZWN0LmgpO1xuICAgIHRoaXMuY3R4LmxpbmVUbygtMC41ICsgcmVjdC54ICsgcmVjdC53LCAtMC41ICsgcmVjdC55ICsgcmVjdC5oKTtcbiAgICB0aGlzLmN0eC5saW5lVG8oLTAuNSArIHJlY3QueCArIHJlY3QudywgMC41ICsgcmVjdC55KTtcbiAgICB0aGlzLmN0eC5saW5lVG8oMC41ICsgcmVjdC54LCAwLjUgKyByZWN0LnkpO1xuICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgIHJldHVybiB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcbiAgfTtcbiAgcHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgfTtcbiAgU3VyZmFjZS5zZXRDb2xvcktleSA9IGZ1bmN0aW9uKHN1cmZhY2UsIGNvbG9yKXtcbiAgICByZXR1cm4gc3VyZmFjZS5zZXRDb2xvcktleShjb2xvcik7XG4gIH07XG4gIFN1cmZhY2UuYmxpdFN1cmZhY2UgPSBmdW5jdGlvbihzb3VyY2UsIHNyY1JlY3QsIGRlc3QsIGRlc3RSZWN0KXtcbiAgICBpZiAoc3JjUmVjdCkge1xuICAgICAgcmV0dXJuIGRlc3QuY3R4LmRyYXdJbWFnZShzb3VyY2UuY2FudmFzLCBzcmNSZWN0LngsIHNyY1JlY3QueSwgc3JjUmVjdC53LCBzcmNSZWN0LmgsIGRlc3RSZWN0LngsIGRlc3RSZWN0LnksIGRlc3RSZWN0LncsIGRlc3RSZWN0LmgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGVzdC5jdHguZHJhd0ltYWdlKHNvdXJjZS5jYW52YXMsIGRlc3RSZWN0LngsIGRlc3RSZWN0LnksIGRlc3RSZWN0LncsIGRlc3RSZWN0LmgpO1xuICAgIH1cbiAgfTtcbiAgU3VyZmFjZS5sb2FkSW1hZ2UgPSBmdW5jdGlvbihwYXRoKXtcbiAgICByZXR1cm4gbmV3IFN1cmZhY2UocGF0aCk7XG4gIH07XG4gIHJldHVybiBTdXJmYWNlO1xufSgpKTsiLCJ2YXIgc3RhcnRUaW1lLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RhcnRUaW1lID0gMDtcbmltcG9ydCQob3V0JCwge1xuICBpbml0OiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICB9LFxuICBnZXRUaWNrczogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgfVxufSk7XG5mdW5jdGlvbiBpbXBvcnQkKG9iaiwgc3JjKXtcbiAgdmFyIG93biA9IHt9Lmhhc093blByb3BlcnR5O1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSBpZiAob3duLmNhbGwoc3JjLCBrZXkpKSBvYmpba2V5XSA9IHNyY1trZXldO1xuICByZXR1cm4gb2JqO1xufSIsInZhciBTREwsIHN0ZCwgdW5pdHMsIGRpdiwga0hhbGZUaWxlLCB0cHgsIGdhbWVUb1B4LCBUaW1lciwgUmVjdCwgU3ByaXRlLCBBbmltYXRlZFNwcml0ZSwgTnVtYmVyU3ByaXRlLCBWYXJ5aW5nV2lkdGhTcHJpdGUsIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5TREwgPSByZXF1aXJlKCdTREwnKTtcbnN0ZCA9IHJlcXVpcmUoJ3N0ZCcpO1xudW5pdHMgPSByZXF1aXJlKCcuL3VuaXRzJyk7XG5kaXYgPSBzdGQuZGl2O1xua0hhbGZUaWxlID0gdW5pdHMua0hhbGZUaWxlLCB0cHggPSB1bml0cy50aWxlVG9QeCwgZ2FtZVRvUHggPSB1bml0cy5nYW1lVG9QeDtcblRpbWVyID0gcmVxdWlyZSgnLi90aW1lcicpLlRpbWVyO1xuUmVjdCA9IHJlcXVpcmUoJy4vcmVjdGFuZ2xlJykuUmVjdGFuZ2xlO1xub3V0JC5TcHJpdGUgPSBTcHJpdGUgPSAoZnVuY3Rpb24oKXtcbiAgU3ByaXRlLmRpc3BsYXlOYW1lID0gJ1Nwcml0ZSc7XG4gIHZhciBwcm90b3R5cGUgPSBTcHJpdGUucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IFNwcml0ZTtcbiAgZnVuY3Rpb24gU3ByaXRlKGdyYXBoaWNzLCBwYXRoLCB4LCB5LCB3LCBoKXtcbiAgICB0aGlzLncgPSB3O1xuICAgIHRoaXMuaCA9IGg7XG4gICAgdGhpcy5zb3VyY2VSZWN0ID0gbmV3IFJlY3QoeCwgeSwgdGhpcy53LCB0aGlzLmgpO1xuICAgIHRoaXMuc3ByaXRlU2hlZXQgPSBncmFwaGljcy5sb2FkSW1hZ2UocGF0aCwgdHJ1ZSk7XG4gIH1cbiAgcHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7fTtcbiAgcHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihncmFwaGljcywgeCwgeSl7XG4gICAgdmFyIGRlc3RSZWN0O1xuICAgIGRlc3RSZWN0ID0gbmV3IFNETC5SZWN0KGdhbWVUb1B4KHgpLCBnYW1lVG9QeCh5KSwgdGhpcy53LCB0aGlzLmgpO1xuICAgIHJldHVybiBncmFwaGljcy5ibGl0U3VyZmFjZSh0aGlzLnNwcml0ZVNoZWV0LCB0aGlzLnNvdXJjZVJlY3QsIGRlc3RSZWN0KTtcbiAgfTtcbiAgcmV0dXJuIFNwcml0ZTtcbn0oKSk7XG5vdXQkLkFuaW1hdGVkU3ByaXRlID0gQW5pbWF0ZWRTcHJpdGUgPSAoZnVuY3Rpb24oc3VwZXJjbGFzcyl7XG4gIHZhciBwcm90b3R5cGUgPSBleHRlbmQkKChpbXBvcnQkKEFuaW1hdGVkU3ByaXRlLCBzdXBlcmNsYXNzKS5kaXNwbGF5TmFtZSA9ICdBbmltYXRlZFNwcml0ZScsIEFuaW1hdGVkU3ByaXRlKSwgc3VwZXJjbGFzcykucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IEFuaW1hdGVkU3ByaXRlO1xuICBmdW5jdGlvbiBBbmltYXRlZFNwcml0ZShncmFwaGljcywgcGF0aCwgc3JjWCwgc3JjWSwgdywgaCwgZnBzLCBudW1GcmFtZXMpe1xuICAgIHZhciByZXMkLCBpJCwgdG8kLCByaWR4JDtcbiAgICB0aGlzLncgPSB3O1xuICAgIHRoaXMuaCA9IGg7XG4gICAgdGhpcy5mcHMgPSBmcHM7XG4gICAgdGhpcy5udW1GcmFtZXMgPSBudW1GcmFtZXM7XG4gICAgQW5pbWF0ZWRTcHJpdGUuc3VwZXJjbGFzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuZnJhbWVUaW1lciA9IG5ldyBUaW1lcigxMDAwIC8gdGhpcy5mcHMpO1xuICAgIHJlcyQgPSBbXTtcbiAgICBmb3IgKGkkID0gMCwgdG8kID0gdGhpcy5udW1GcmFtZXM7IGkkIDwgdG8kOyArK2kkKSB7XG4gICAgICByaWR4JCA9IGkkO1xuICAgICAgcmVzJC5wdXNoKHJpZHgkKTtcbiAgICB9XG4gICAgdGhpcy5rZXlmcmFtZXMgPSByZXMkO1xuICAgIHRoaXMuY3VycmVudEZyYW1lID0gMDtcbiAgICB0aGlzLmN1cnJlbnRLZXlmcmFtZSA9IHRoaXMua2V5ZnJhbWVzWzBdO1xuICAgIHRoaXMub3JpZ2luWCA9IHNyY1g7XG4gICAgdGhpcy5udW1Db21wbGV0ZWRMb29wcyA9IDA7XG4gIH1cbiAgcHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihncmFwaGljcywgeCwgeSwgZnJhbWVPZmZzZXQpe1xuICAgIHZhciBkZXN0UmVjdDtcbiAgICBmcmFtZU9mZnNldCA9PSBudWxsICYmIChmcmFtZU9mZnNldCA9IHRoaXMuY3VycmVudEtleWZyYW1lKTtcbiAgICB0aGlzLnNvdXJjZVJlY3QueCA9IHRoaXMub3JpZ2luWCArIGZyYW1lT2Zmc2V0ICogdGhpcy5zb3VyY2VSZWN0Lnc7XG4gICAgZGVzdFJlY3QgPSBuZXcgU0RMLlJlY3QoZ2FtZVRvUHgoeCksIGdhbWVUb1B4KHkpLCB0aGlzLncsIHRoaXMuaCk7XG4gICAgcmV0dXJuIGdyYXBoaWNzLmJsaXRTdXJmYWNlKHRoaXMuc3ByaXRlU2hlZXQsIHRoaXMuc291cmNlUmVjdCwgZGVzdFJlY3QpO1xuICB9O1xuICBwcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICBpZiAodGhpcy5mcmFtZVRpbWVyLmlzRXhwaXJlZCkge1xuICAgICAgdGhpcy5mcmFtZVRpbWVyLnJlc2V0KCk7XG4gICAgICB0aGlzLmN1cnJlbnRGcmFtZSArPSAxO1xuICAgICAgaWYgKHRoaXMuY3VycmVudEZyYW1lID49IHRoaXMua2V5ZnJhbWVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLm51bUNvbXBsZXRlZExvb3BzICs9IDE7XG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRLZXlmcmFtZSA9IHRoaXMua2V5ZnJhbWVzW3RoaXMuY3VycmVudEZyYW1lXTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBBbmltYXRlZFNwcml0ZTtcbn0oU3ByaXRlKSk7XG5vdXQkLk51bWJlclNwcml0ZSA9IE51bWJlclNwcml0ZSA9IChmdW5jdGlvbigpe1xuICBOdW1iZXJTcHJpdGUuZGlzcGxheU5hbWUgPSAnTnVtYmVyU3ByaXRlJztcbiAgdmFyIGtEaWdpdFNyY1ksIGtPcFBsdXNTcmNYLCBrT3BNaW51c1NyY1gsIGtPcFNyY1ksIGtEaWdpdFNpemUsIGtSYWRpeCwgcmVmJCwgV0hJVEUsIFJFRCwgUExVUywgTUlOVVMsIE5PTkUsIHByb3RvdHlwZSA9IE51bWJlclNwcml0ZS5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gTnVtYmVyU3ByaXRlO1xuICBrRGlnaXRTcmNZID0gMy41O1xuICBrT3BQbHVzU3JjWCA9IDI7XG4gIGtPcE1pbnVzU3JjWCA9IDIuNTtcbiAga09wU3JjWSA9IDM7XG4gIGtEaWdpdFNpemUgPSB1bml0cy5rSGFsZlRpbGU7XG4gIGtSYWRpeCA9IDEwO1xuICByZWYkID0gc3RkWydlbnVtJ10sIFdISVRFID0gcmVmJFswXSwgUkVEID0gcmVmJFsxXTtcbiAgcmVmJCA9IHN0ZFsnZW51bSddLCBQTFVTID0gcmVmJFswXSwgTUlOVVMgPSByZWYkWzFdLCBOT05FID0gcmVmJFsyXTtcbiAgZnVuY3Rpb24gTnVtYmVyU3ByaXRlKGdyYXBoaWNzLCBudW0sIGxlbiwgY29sb3IsIG9wKXtcbiAgICB2YXIgc3JjWTtcbiAgICB0aGlzLm51bSA9IG51bTtcbiAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gICAgdGhpcy5vcCA9IG9wO1xuICAgIHRoaXMuZGlnaXRzID0gTnVtYmVyU3ByaXRlLnNlcGVyYXRlRGlnaXRzKHRoaXMubnVtKTtcbiAgICB0aGlzLm51bURpZ2l0cyA9IHRoaXMuZGlnaXRzLmxlbmd0aDtcbiAgICB0aGlzLnBhZGRpbmcgPSB0aGlzLmxlbiA9PT0gMFxuICAgICAgPyAwXG4gICAgICA6IGtEaWdpdFNpemUgKiAodGhpcy5sZW4gLSB0aGlzLm51bURpZ2l0cyk7XG4gICAgc3JjWSA9IHRoaXMuY29sb3IgPT09IFdISVRFXG4gICAgICA/IGtEaWdpdFNyY1lcbiAgICAgIDoga0RpZ2l0U3JjWSArIDAuNTtcbiAgICB0aGlzLmdseXBocyA9IHRoaXMuZGlnaXRzLm1hcChmdW5jdGlvbihpdCl7XG4gICAgICByZXR1cm4gbmV3IFNwcml0ZShncmFwaGljcywgJ1RleHRCb3gnLCB0cHgoMC41ICogaXQpLCB0cHgoc3JjWSksIHRweCgwLjUpLCB0cHgoMC41KSk7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMub3AgPT09IFBMVVMpIHtcbiAgICAgIHRoaXMuZ2x5cGhzLnB1c2gobmV3IFNwcml0ZShncmFwaGljcywgJ1RleHRCb3gnLCB0cHgoa09wUGx1c1NyY1gpLCB0cHgoa09wU3JjWSksIHRweCgwLjUpLCB0cHgoMC41KSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcCA9PT0gTUlOVVMpIHtcbiAgICAgIHRoaXMuZ2x5cGhzLnB1c2gobmV3IFNwcml0ZShncmFwaGljcywgJ1RleHRCb3gnLCB0cHgoa09wTWludXNTcmNYKSwgdHB4KGtPcFNyY1kpLCB0cHgoMC41KSwgdHB4KDAuNSkpKTtcbiAgICB9XG4gICAgdGhpcy53aWR0aCA9IGtIYWxmVGlsZSAqIHRoaXMuZ2x5cGhzLmxlbmd0aDtcbiAgICB0aGlzLmhlaWdodCA9IGtIYWxmVGlsZTtcbiAgfVxuICBwcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGdyYXBoaWNzLCB4LCB5KXtcbiAgICB2YXIgaSQsIHJlZiQsIGxlbiQsIGksIGdseXBoLCBvZmZzZXQsIHJlc3VsdHMkID0gW107XG4gICAgZm9yIChpJCA9IDAsIGxlbiQgPSAocmVmJCA9IHRoaXMuZ2x5cGhzKS5sZW5ndGg7IGkkIDwgbGVuJDsgKytpJCkge1xuICAgICAgaSA9IGkkO1xuICAgICAgZ2x5cGggPSByZWYkW2kkXTtcbiAgICAgIG9mZnNldCA9IGtEaWdpdFNpemUgKiAodGhpcy5nbHlwaHMubGVuZ3RoIC0gMSAtIGkpO1xuICAgICAgcmVzdWx0cyQucHVzaChnbHlwaC5kcmF3KGdyYXBoaWNzLCB4ICsgdGhpcy5wYWRkaW5nICsgb2Zmc2V0LCB5KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzJDtcbiAgfTtcbiAgcHJvdG90eXBlLmRyYXdDZW50ZXJlZCA9IGZ1bmN0aW9uKGdyYXBoaWNzLCB4LCB5KXtcbiAgICByZXR1cm4gdGhpcy5kcmF3KGdyYXBoaWNzLCB4IC0gdGhpcy53aWR0aCAvIDIsIHkgLSB0aGlzLmhlaWdodCAvIDIpO1xuICB9O1xuICBOdW1iZXJTcHJpdGUuc2VwZXJhdGVEaWdpdHMgPSBmdW5jdGlvbihudW0pe1xuICAgIHZhciBkaWdpdCwgcmVzdWx0cyQgPSBbXTtcbiAgICBpZiAobnVtID09PSAwKSB7XG4gICAgICByZXR1cm4gWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAobnVtICE9PSAwKSB7XG4gICAgICAgIGRpZ2l0ID0gbnVtICUga1JhZGl4O1xuICAgICAgICBudW0gPSBkaXYobnVtLCBrUmFkaXgpO1xuICAgICAgICByZXN1bHRzJC5wdXNoKGRpZ2l0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzJDtcbiAgICB9XG4gIH07XG4gIE51bWJlclNwcml0ZS5IVUROdW1iZXIgPSBmdW5jdGlvbihncmFwaGljcywgbnVtLCBsZW4pe1xuICAgIHRoaXMubnVtID0gbnVtO1xuICAgIHRoaXMubGVuID0gbGVuO1xuICAgIHJldHVybiBuZXcgTnVtYmVyU3ByaXRlKGdyYXBoaWNzLCB0aGlzLm51bSwgdGhpcy5sZW4sIFdISVRFLCBOT05FKTtcbiAgfTtcbiAgTnVtYmVyU3ByaXRlLkRhbWFnZU51bWJlciA9IGZ1bmN0aW9uKGdyYXBoaWNzLCBudW0pe1xuICAgIHRoaXMubnVtID0gbnVtO1xuICAgIHJldHVybiBuZXcgTnVtYmVyU3ByaXRlKGdyYXBoaWNzLCB0aGlzLm51bSwgMCwgUkVELCBNSU5VUyk7XG4gIH07XG4gIE51bWJlclNwcml0ZS5FeHBlcmllbmNlTnVtYmVyID0gZnVuY3Rpb24oZ3JhcGhpY3MsIG51bSl7XG4gICAgdGhpcy5udW0gPSBudW07XG4gICAgcmV0dXJuIG5ldyBOdW1iZXJTcHJpdGUoZ3JhcGhpY3MsIHRoaXMubnVtLCAwLCBXSElURSwgUExVUyk7XG4gIH07XG4gIHJldHVybiBOdW1iZXJTcHJpdGU7XG59KCkpO1xub3V0JC5WYXJ5aW5nV2lkdGhTcHJpdGUgPSBWYXJ5aW5nV2lkdGhTcHJpdGUgPSAoZnVuY3Rpb24oc3VwZXJjbGFzcyl7XG4gIHZhciBwcm90b3R5cGUgPSBleHRlbmQkKChpbXBvcnQkKFZhcnlpbmdXaWR0aFNwcml0ZSwgc3VwZXJjbGFzcykuZGlzcGxheU5hbWUgPSAnVmFyeWluZ1dpZHRoU3ByaXRlJywgVmFyeWluZ1dpZHRoU3ByaXRlKSwgc3VwZXJjbGFzcykucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IFZhcnlpbmdXaWR0aFNwcml0ZTtcbiAgZnVuY3Rpb24gVmFyeWluZ1dpZHRoU3ByaXRlKGdyYXBoaWNzLCBwYXRoLCB4LCB5LCB3LCBoLCBtYXhXaWR0aCl7XG4gICAgdGhpcy53ID0gdztcbiAgICB0aGlzLmggPSBoO1xuICAgIHRoaXMubWF4V2lkdGggPSBtYXhXaWR0aCAhPSBudWxsXG4gICAgICA/IG1heFdpZHRoXG4gICAgICA6IHRoaXMudztcbiAgICBWYXJ5aW5nV2lkdGhTcHJpdGUuc3VwZXJjbGFzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIHByb3RvdHlwZS5zZXRXaWR0aCA9IGZ1bmN0aW9uKHdpZHRoKXtcbiAgICByZXR1cm4gdGhpcy53ID0gd2lkdGg7XG4gIH07XG4gIHByb3RvdHlwZS5zZXRQZXJjZW50YWdlV2lkdGggPSBmdW5jdGlvbihmcmFjdGlvbil7XG4gICAgcmV0dXJuIHRoaXMudyA9IGZyYWN0aW9uICogdGhpcy5tYXhXaWR0aDtcbiAgfTtcbiAgcmV0dXJuIFZhcnlpbmdXaWR0aFNwcml0ZTtcbn0oU3ByaXRlKSk7XG5mdW5jdGlvbiBleHRlbmQkKHN1Yiwgc3VwKXtcbiAgZnVuY3Rpb24gZnVuKCl7fSBmdW4ucHJvdG90eXBlID0gKHN1Yi5zdXBlcmNsYXNzID0gc3VwKS5wcm90b3R5cGU7XG4gIChzdWIucHJvdG90eXBlID0gbmV3IGZ1bikuY29uc3RydWN0b3IgPSBzdWI7XG4gIGlmICh0eXBlb2Ygc3VwLmV4dGVuZGVkID09ICdmdW5jdGlvbicpIHN1cC5leHRlbmRlZChzdWIpO1xuICByZXR1cm4gc3ViO1xufVxuZnVuY3Rpb24gaW1wb3J0JChvYmosIHNyYyl7XG4gIHZhciBvd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbiAgZm9yICh2YXIga2V5IGluIHNyYykgaWYgKG93bi5jYWxsKHNyYywga2V5KSkgb2JqW2tleV0gPSBzcmNba2V5XTtcbiAgcmV0dXJuIG9iajtcbn0iLCJ2YXIgc3RkLCB1bml0cywgTk9ORSwgU1RBTkRJTkcsIFdBTEtJTkcsIEpVTVBJTkcsIEZBTExJTkcsIElOVEVSQUNUSU5HLCBMRUZULCBSSUdIVCwgVVAsIERPV04sIEhPUklaT05UQUwsIFNUUklERV9MRUZULCBTVFJJREVfUklHSFQsIFNUUklERV9NSURETEUsIFN0YXRlLCBtb3Rpb25zLCBoZmFjaW5ncywgdmZhY2luZ3MsIHN0cmlkZXMsIFNwcml0ZVN0YXRlLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG51bml0cyA9IHJlcXVpcmUoJy4vdW5pdHMnKTtcbk5PTkUgPSBNYXRoLnBvdygyLCAwKTtcblNUQU5ESU5HID0gTWF0aC5wb3coMiwgMSk7XG5XQUxLSU5HID0gTWF0aC5wb3coMiwgMik7XG5KVU1QSU5HID0gTWF0aC5wb3coMiwgMyk7XG5GQUxMSU5HID0gTWF0aC5wb3coMiwgNCk7XG5JTlRFUkFDVElORyA9IE1hdGgucG93KDIsIDUpO1xuTEVGVCA9IE1hdGgucG93KDIsIDYpO1xuUklHSFQgPSBNYXRoLnBvdygyLCA3KTtcblVQID0gTWF0aC5wb3coMiwgOCk7XG5ET1dOID0gTWF0aC5wb3coMiwgOSk7XG5IT1JJWk9OVEFMID0gTWF0aC5wb3coMiwgMTApO1xuU1RSSURFX0xFRlQgPSBNYXRoLnBvdygyLCAxMSk7XG5TVFJJREVfUklHSFQgPSBNYXRoLnBvdygyLCAxMik7XG5TVFJJREVfTUlERExFID0gTWF0aC5wb3coMiwgMTMpO1xub3V0JC5TdGF0ZSA9IFN0YXRlID0ge1xuICBOT05FOiBOT05FLFxuICBTVEFORElORzogU1RBTkRJTkcsXG4gIFdBTEtJTkc6IFdBTEtJTkcsXG4gIEpVTVBJTkc6IEpVTVBJTkcsXG4gIEZBTExJTkc6IEZBTExJTkcsXG4gIElOVEVSQUNUSU5HOiBJTlRFUkFDVElORyxcbiAgTEVGVDogTEVGVCxcbiAgUklHSFQ6IFJJR0hULFxuICBVUDogVVAsXG4gIERPV046IERPV04sXG4gIEhPUklaT05UQUw6IEhPUklaT05UQUwsXG4gIFNUUklERV9MRUZUOiBTVFJJREVfTEVGVCxcbiAgU1RSSURFX1JJR0hUOiBTVFJJREVfUklHSFQsXG4gIFNUUklERV9NSURETEU6IFNUUklERV9NSURETEVcbn07XG5vdXQkLm1vdGlvbnMgPSBtb3Rpb25zID0gW1NUQU5ESU5HLCBXQUxLSU5HLCBKVU1QSU5HLCBGQUxMSU5HLCBJTlRFUkFDVElOR107XG5vdXQkLmhmYWNpbmdzID0gaGZhY2luZ3MgPSBbTEVGVCwgUklHSFRdO1xub3V0JC52ZmFjaW5ncyA9IHZmYWNpbmdzID0gW1VQLCBET1dOLCBIT1JJWk9OVEFMXTtcbm91dCQuc3RyaWRlcyA9IHN0cmlkZXMgPSBbU1RSSURFX0xFRlQsIFNUUklERV9SSUdIVCwgU1RSSURFX01JRERMRV07XG5vdXQkLlNwcml0ZVN0YXRlID0gU3ByaXRlU3RhdGUgPSB7XG4gIG1ha2U6IGZ1bmN0aW9uKGhmYWNpbmcsIHZmYWNpbmcsIG1vdGlvbiwgc3RyaWRlKXtcbiAgICBtb3Rpb24gPT0gbnVsbCAmJiAobW90aW9uID0gTk9ORSk7XG4gICAgc3RyaWRlID09IG51bGwgJiYgKHN0cmlkZSA9IE5PTkUpO1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IGhmYWNpbmcgfCB2ZmFjaW5nIHwgbW90aW9uIHwgc3RyaWRlLFxuICAgICAgVVA6IHZmYWNpbmcgPT09IFVQLFxuICAgICAgRE9XTjogdmZhY2luZyA9PT0gRE9XTixcbiAgICAgIExFRlQ6IGhmYWNpbmcgPT09IExFRlQsXG4gICAgICBSSUdIVDogaGZhY2luZyA9PT0gUklHSFQsXG4gICAgICBXQUxLSU5HOiBtb3Rpb24gPT09IFdBTEtJTkcsXG4gICAgICBKVU1QSU5HOiBtb3Rpb24gPT09IEpVTVBJTkcsXG4gICAgICBGQUxMSU5HOiBtb3Rpb24gPT09IEZBTExJTkcsXG4gICAgICBTVEFORElORzogbW90aW9uID09PSBTVEFORElORyxcbiAgICAgIEhPUklaT05UQUw6IHZmYWNpbmcgPT09IEhPUklaT05UQUwsXG4gICAgICBJTlRFUkFDVElORzogbW90aW9uID09PSBJTlRFUkFDVElORyxcbiAgICAgIFNUUklERV9MRUZUOiBzdHJpZGUgPT09IFNUUklERV9MRUZULFxuICAgICAgU1RSSURFX1JJR0hUOiBzdHJpZGUgPT09IFNUUklERV9SSUdIVCxcbiAgICAgIFNUUklERV9NSURETEU6IHN0cmlkZSA9PT0gU1RSSURFX01JRERMRVxuICAgIH07XG4gIH0sXG4gIGdlbmVyYXRlV2l0aDogZnVuY3Rpb24oZm4pe1xuICAgIHZhciBtLCBoLCB2LCBzLCBzcztcbiAgICByZXR1cm4gc3RkLm1hc2goKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgaSQsIHJlZiQsIGxlbiQsIGokLCByZWYxJCwgbGVuMSQsIGskLCByZWYyJCwgbGVuMiQsIGwkLCByZWYzJCwgbGVuMyQsIHJlc3VsdHMkID0gW107XG4gICAgICBmb3IgKGkkID0gMCwgbGVuJCA9IChyZWYkID0gbW90aW9ucykubGVuZ3RoOyBpJCA8IGxlbiQ7ICsraSQpIHtcbiAgICAgICAgbSA9IHJlZiRbaSRdO1xuICAgICAgICBmb3IgKGokID0gMCwgbGVuMSQgPSAocmVmMSQgPSBoZmFjaW5ncykubGVuZ3RoOyBqJCA8IGxlbjEkOyArK2okKSB7XG4gICAgICAgICAgaCA9IHJlZjEkW2okXTtcbiAgICAgICAgICBmb3IgKGskID0gMCwgbGVuMiQgPSAocmVmMiQgPSB2ZmFjaW5ncykubGVuZ3RoOyBrJCA8IGxlbjIkOyArK2skKSB7XG4gICAgICAgICAgICB2ID0gcmVmMiRbayRdO1xuICAgICAgICAgICAgZm9yIChsJCA9IDAsIGxlbjMkID0gKHJlZjMkID0gc3RyaWRlcykubGVuZ3RoOyBsJCA8IGxlbjMkOyArK2wkKSB7XG4gICAgICAgICAgICAgIHMgPSByZWYzJFtsJF07XG4gICAgICAgICAgICAgIHNzID0gU3ByaXRlU3RhdGUubWFrZShoLCB2LCBtLCBzKTtcbiAgICAgICAgICAgICAgcmVzdWx0cyQucHVzaChbc3Mua2V5LCBmbihzcyldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzJDtcbiAgICB9KCkpKTtcbiAgfVxufTsiLCJ2YXIgc3RkLCB0cHgsIEltbW9iaWxlU2luZ2xlTG9vcFBhcnRpY2xlLCBTdGFyUGFydGljbGUsIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHRoaXM7XG5zdGQgPSByZXF1aXJlKCdzdGQnKTtcbnRweCA9IHJlcXVpcmUoJy4vdW5pdHMnKS50aWxlVG9QeDtcbkltbW9iaWxlU2luZ2xlTG9vcFBhcnRpY2xlID0gcmVxdWlyZSgnLi9pbW1vYmlsZS1zaW5nbGUtbG9vcC1wYXJ0aWNsZScpLkltbW9iaWxlU2luZ2xlTG9vcFBhcnRpY2xlO1xub3V0JC5TdGFyUGFydGljbGUgPSBTdGFyUGFydGljbGUgPSAoZnVuY3Rpb24oc3VwZXJjbGFzcyl7XG4gIHZhciBwcm90b3R5cGUgPSBleHRlbmQkKChpbXBvcnQkKFN0YXJQYXJ0aWNsZSwgc3VwZXJjbGFzcykuZGlzcGxheU5hbWUgPSAnU3RhclBhcnRpY2xlJywgU3RhclBhcnRpY2xlKSwgc3VwZXJjbGFzcykucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IFN0YXJQYXJ0aWNsZTtcbiAgZnVuY3Rpb24gU3RhclBhcnRpY2xlKGdyYXBoaWNzLCB4LCB5KXtcbiAgICBTdGFyUGFydGljbGUuc3VwZXJjbGFzcy5jYWxsKHRoaXMsIGdyYXBoaWNzLCB4LCB5LCAnQ2FyZXQnLCB0cHgoMCksIHRweCgzKSwgdHB4KDEpLCB0cHgoMSksIDE4LCA0KTtcbiAgfVxuICByZXR1cm4gU3RhclBhcnRpY2xlO1xufShJbW1vYmlsZVNpbmdsZUxvb3BQYXJ0aWNsZSkpO1xuZnVuY3Rpb24gZXh0ZW5kJChzdWIsIHN1cCl7XG4gIGZ1bmN0aW9uIGZ1bigpe30gZnVuLnByb3RvdHlwZSA9IChzdWIuc3VwZXJjbGFzcyA9IHN1cCkucHJvdG90eXBlO1xuICAoc3ViLnByb3RvdHlwZSA9IG5ldyBmdW4pLmNvbnN0cnVjdG9yID0gc3ViO1xuICBpZiAodHlwZW9mIHN1cC5leHRlbmRlZCA9PSAnZnVuY3Rpb24nKSBzdXAuZXh0ZW5kZWQoc3ViKTtcbiAgcmV0dXJuIHN1Yjtcbn1cbmZ1bmN0aW9uIGltcG9ydCQob2JqLCBzcmMpe1xuICB2YXIgb3duID0ge30uaGFzT3duUHJvcGVydHk7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIGlmIChvd24uY2FsbChzcmMsIGtleSkpIG9ialtrZXldID0gc3JjW2tleV07XG4gIHJldHVybiBvYmo7XG59IiwidmFyIHJlZiQsIGlkLCBtYXAsIGZpbHRlciwgcmVqZWN0LCBhbnksIGRpdiwgcmV2ZXJzZSwgbG9nLCBpbmZvLCBvYmpNYXAsIG1hc2gsIGZsaXAsIGRlbGF5LCByb3VuZCwgZmxvb3IsIGFicywgbWF4LCBtaW4sIHNpbiwgY29zLCBwaSwgdGF1LCByYW5kLCBJbnRlcmZhY2VFcnJvciwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcbnJlZiQgPSByZXF1aXJlKCdwcmVsdWRlLWxzJyksIGlkID0gcmVmJC5pZCwgbWFwID0gcmVmJC5tYXAsIGZpbHRlciA9IHJlZiQuZmlsdGVyLCByZWplY3QgPSByZWYkLnJlamVjdCwgYW55ID0gcmVmJC5hbnksIGRpdiA9IHJlZiQuZGl2LCByZXZlcnNlID0gcmVmJC5yZXZlcnNlO1xub3V0JC5sb2cgPSBsb2cgPSBmdW5jdGlvbigpe1xuICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICByZXR1cm4gYXJndW1lbnRzWzBdO1xufTtcbm91dCQuaW5mbyA9IGluZm8gPSBmdW5jdGlvbigpe1xuICBjb25zb2xlLmluZm8uYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbn07XG5vdXQkLm9iak1hcCA9IG9iak1hcCA9IGN1cnJ5JChmdW5jdGlvbijOuywgbyl7XG4gIHZhciBrLCB2LCByZXN1bHRzJCA9IFtdO1xuICBmb3IgKGsgaW4gbykge1xuICAgIHYgPSBvW2tdO1xuICAgIHJlc3VsdHMkLnB1c2gozrsoaywgdikpO1xuICB9XG4gIHJldHVybiByZXN1bHRzJDtcbn0pO1xub3V0JC5tYXNoID0gbWFzaCA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIGkkLCBsZW4kLCByZWYkLCBrLCB2LCByZXN1bHRzJCA9IHt9O1xuICBmb3IgKGkkID0gMCwgbGVuJCA9IGl0Lmxlbmd0aDsgaSQgPCBsZW4kOyArK2kkKSB7XG4gICAgcmVmJCA9IGl0W2kkXSwgayA9IHJlZiRbMF0sIHYgPSByZWYkWzFdO1xuICAgIHJlc3VsdHMkW2tdID0gdjtcbiAgfVxuICByZXR1cm4gcmVzdWx0cyQ7XG59O1xub3V0JC5mbGlwID0gZmxpcCA9IGZ1bmN0aW9uKM67KXtcbiAgcmV0dXJuIGN1cnJ5JChmdW5jdGlvbihhLCBiKXtcbiAgICByZXR1cm4gzrsoYiwgYSk7XG4gIH0pO1xufTtcbm91dCQuZGVsYXkgPSBkZWxheSA9IGZsaXAoc2V0VGltZW91dCk7XG5vdXQkLnJvdW5kID0gcm91bmQgPSBNYXRoLnJvdW5kO1xub3V0JC5mbG9vciA9IGZsb29yID0gTWF0aC5mbG9vcjtcbm91dCQuYWJzID0gYWJzID0gTWF0aC5hYnM7XG5vdXQkLm1heCA9IG1heCA9IE1hdGgubWF4O1xub3V0JC5taW4gPSBtaW4gPSBNYXRoLm1pbjtcbm91dCQuc2luID0gc2luID0gTWF0aC5zaW47XG5vdXQkLmNvcyA9IGNvcyA9IE1hdGguY29zO1xub3V0JC5waSA9IHBpID0gTWF0aC5QSTtcbm91dCQudGF1ID0gdGF1ID0gTWF0aC5QSSAqIDI7XG5vdXQkLnJhbmQgPSByYW5kID0gZnVuY3Rpb24obWluLCBtYXgpe1xuICByZXR1cm4gbWluICsgTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pO1xufTtcbm91dCQuSW50ZXJmYWNlRXJyb3IgPSBJbnRlcmZhY2VFcnJvciA9IChmdW5jdGlvbihzdXBlcmNsYXNzKXtcbiAgdmFyIHByb3RvdHlwZSA9IGV4dGVuZCQoKGltcG9ydCQoSW50ZXJmYWNlRXJyb3IsIHN1cGVyY2xhc3MpLmRpc3BsYXlOYW1lID0gJ0ludGVyZmFjZUVycm9yJywgSW50ZXJmYWNlRXJyb3IpLCBzdXBlcmNsYXNzKS5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gSW50ZXJmYWNlRXJyb3I7XG4gIGZ1bmN0aW9uIEludGVyZmFjZUVycm9yKG1lc3NhZ2Upe1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5uYW1lID0gJ0ludGVyZmFjZUVycm9yJztcbiAgfVxuICByZXR1cm4gSW50ZXJmYWNlRXJyb3I7XG59KEVycm9yKSk7XG5yZWYkID0gb3V0JDtcbnJlZiQuaWQgPSBpZDtcbnJlZiQuYW55ID0gYW55O1xucmVmJC5tYXAgPSBtYXA7XG5yZWYkLmZpbHRlciA9IGZpbHRlcjtcbnJlZiQucmVqZWN0ID0gcmVqZWN0O1xucmVmJC5kaXYgPSBkaXY7XG5yZWYkLnJldmVyc2UgPSByZXZlcnNlO1xucmVmJFsnZW51bSddID0gWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsIDE2LCAxNywgMTgsIDE5LCAyMF07XG5yZWYkLmJpdG1hc2sgPSBbMSwgMiwgNCwgOCwgMTYsIDMyLCA2NCwgMTI4LCAyNTYsIDUxMiwgMTAyNCwgMjA0OCwgNDA5Nl07XG5mdW5jdGlvbiBjdXJyeSQoZiwgYm91bmQpe1xuICB2YXIgY29udGV4dCxcbiAgX2N1cnJ5ID0gZnVuY3Rpb24oYXJncykge1xuICAgIHJldHVybiBmLmxlbmd0aCA+IDEgPyBmdW5jdGlvbigpe1xuICAgICAgdmFyIHBhcmFtcyA9IGFyZ3MgPyBhcmdzLmNvbmNhdCgpIDogW107XG4gICAgICBjb250ZXh0ID0gYm91bmQgPyBjb250ZXh0IHx8IHRoaXMgOiB0aGlzO1xuICAgICAgcmV0dXJuIHBhcmFtcy5wdXNoLmFwcGx5KHBhcmFtcywgYXJndW1lbnRzKSA8XG4gICAgICAgICAgZi5sZW5ndGggJiYgYXJndW1lbnRzLmxlbmd0aCA/XG4gICAgICAgIF9jdXJyeS5jYWxsKGNvbnRleHQsIHBhcmFtcykgOiBmLmFwcGx5KGNvbnRleHQsIHBhcmFtcyk7XG4gICAgfSA6IGY7XG4gIH07XG4gIHJldHVybiBfY3VycnkoKTtcbn1cbmZ1bmN0aW9uIGV4dGVuZCQoc3ViLCBzdXApe1xuICBmdW5jdGlvbiBmdW4oKXt9IGZ1bi5wcm90b3R5cGUgPSAoc3ViLnN1cGVyY2xhc3MgPSBzdXApLnByb3RvdHlwZTtcbiAgKHN1Yi5wcm90b3R5cGUgPSBuZXcgZnVuKS5jb25zdHJ1Y3RvciA9IHN1YjtcbiAgaWYgKHR5cGVvZiBzdXAuZXh0ZW5kZWQgPT0gJ2Z1bmN0aW9uJykgc3VwLmV4dGVuZGVkKHN1Yik7XG4gIHJldHVybiBzdWI7XG59XG5mdW5jdGlvbiBpbXBvcnQkKG9iaiwgc3JjKXtcbiAgdmFyIG93biA9IHt9Lmhhc093blByb3BlcnR5O1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSBpZiAob3duLmNhbGwoc3JjLCBrZXkpKSBvYmpba2V5XSA9IHNyY1trZXldO1xuICByZXR1cm4gb2JqO1xufSIsInZhciBzdGQsIHVuaXRzLCBUaW1lciwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcbnN0ZCA9IHJlcXVpcmUoJ3N0ZCcpO1xudW5pdHMgPSByZXF1aXJlKCcuL3VuaXRzJyk7XG5vdXQkLlRpbWVyID0gVGltZXIgPSAoZnVuY3Rpb24oKXtcbiAgVGltZXIuZGlzcGxheU5hbWUgPSAnVGltZXInO1xuICB2YXIgYWxsVGltZXJzLCBwcm90b3R5cGUgPSBUaW1lci5wcm90b3R5cGUsIGNvbnN0cnVjdG9yID0gVGltZXI7XG4gIGFsbFRpbWVycyA9IFtdO1xuICBmdW5jdGlvbiBUaW1lcihleHBpcmF0aW9uVGltZSwgc3RhcnRBY3RpdmUpe1xuICAgIHRoaXMuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICBzdGFydEFjdGl2ZSA9PSBudWxsICYmIChzdGFydEFjdGl2ZSA9IGZhbHNlKTtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gc3RhcnRBY3RpdmVcbiAgICAgID8gMFxuICAgICAgOiB0aGlzLmV4cGlyYXRpb25UaW1lO1xuICAgIGFsbFRpbWVycy5wdXNoKHRoaXMpO1xuICB9XG4gIHByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihlbGFwc2VkVGltZSl7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFRpbWUgKz0gZWxhcHNlZFRpbWU7XG4gIH07XG4gIHByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFRpbWUgPSAwO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCAnaXNBY3RpdmUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFRpbWUgPCB0aGlzLmV4cGlyYXRpb25UaW1lO1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsICdpc0V4cGlyZWQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuICF0aGlzLmlzQWN0aXZlO1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG4gIHByb3RvdHlwZS5hY3RpdmUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRUaW1lIDwgdGhpcy5leHBpcmF0aW9uVGltZTtcbiAgfTtcbiAgcHJvdG90eXBlLmV4cGlyZWQgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiAhKHRoaXMuY3VycmVudFRpbWUgPCB0aGlzLmV4cGlyYXRpb25UaW1lKTtcbiAgfTtcbiAgVGltZXIudXBkYXRlQWxsID0gZnVuY3Rpb24oZWxhcHNlZFRpbWUpe1xuICAgIHJldHVybiBhbGxUaW1lcnMubWFwKGZ1bmN0aW9uKGl0KXtcbiAgICAgIHJldHVybiBpdC51cGRhdGUoZWxhcHNlZFRpbWUpO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gVGltZXI7XG59KCkpOyIsInZhciBzdGQsIGNvbmZpZywga1BpLCBrR2FtZVVuaXRzUGVyVGlsZSwga1BpeGVsU2NhbGVGYWN0b3IsIEdhbWUsIFBpeGVsLCBUaWxlLCBEZWdyZWVzLCBHdW5MZXZlbCwgR3VuWFAsIEZQUywgTVMsIFZlbG9jaXR5LCBBY2NlbGVyYXRpb24sIEhQLCBnYW1lVG9QeCwgZ2FtZVRvVGlsZSwgdGlsZVRvR2FtZSwgdGlsZVRvUHgsIHB4VG9HYW1lLCBweFRvVGlsZSwgZGVnVG9SYWQsIGtPbmVUaWxlLCBrSGFsZlRpbGUsIGtUaWxlUHgsIGtNYXhHdW5MZXZlbCwgb3V0JCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIGV4cG9ydHMgfHwgdGhpcztcbnN0ZCA9IHJlcXVpcmUoJ3N0ZCcpO1xuY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcbmtQaSA9IE1hdGguUEk7XG5rR2FtZVVuaXRzUGVyVGlsZSA9IDMyO1xua1BpeGVsU2NhbGVGYWN0b3IgPSBrR2FtZVVuaXRzUGVyVGlsZSAvIGNvbmZpZy5rR3JhcGhpY3NRdWFsaXR5O1xub3V0JC5HYW1lID0gR2FtZSA9IHN0ZC5pZDtcbm91dCQuUGl4ZWwgPSBQaXhlbCA9IHN0ZC5mbG9vcjtcbm91dCQuVGlsZSA9IFRpbGUgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gc3RkLmFicyhzdGQuZmxvb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG59O1xub3V0JC5EZWdyZWVzID0gRGVncmVlcyA9IHN0ZC5pZDtcbm91dCQuR3VuTGV2ZWwgPSBHdW5MZXZlbCA9IHN0ZC5mbG9vcjtcbm91dCQuR3VuWFAgPSBHdW5YUCA9IHN0ZC5mbG9vcjtcbm91dCQuRlBTID0gRlBTID0gc3RkLmlkO1xub3V0JC5NUyA9IE1TID0gc3RkLmlkO1xub3V0JC5WZWxvY2l0eSA9IFZlbG9jaXR5ID0gc3RkLmlkO1xub3V0JC5BY2NlbGVyYXRpb24gPSBBY2NlbGVyYXRpb24gPSBzdGQuaWQ7XG5vdXQkLkhQID0gSFAgPSBzdGQuZmxvb3I7XG5vdXQkLmdhbWVUb1B4ID0gZ2FtZVRvUHggPSBmdW5jdGlvbigpe1xuICByZXR1cm4gUGl4ZWwoKGZ1bmN0aW9uKGl0KXtcbiAgICByZXR1cm4gaXQgLyBrUGl4ZWxTY2FsZUZhY3RvcjtcbiAgfSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG59O1xub3V0JC5nYW1lVG9UaWxlID0gZ2FtZVRvVGlsZSA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiBUaWxlKChmdW5jdGlvbihpdCl7XG4gICAgcmV0dXJuIGl0IC8ga0dhbWVVbml0c1BlclRpbGU7XG4gIH0pLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xufTtcbm91dCQudGlsZVRvR2FtZSA9IHRpbGVUb0dhbWUgPSAoZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgKiBrR2FtZVVuaXRzUGVyVGlsZTtcbn0pO1xub3V0JC50aWxlVG9QeCA9IHRpbGVUb1B4ID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGdhbWVUb1B4KHRpbGVUb0dhbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG59O1xub3V0JC5weFRvR2FtZSA9IHB4VG9HYW1lID0gKGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ICoga1BpeGVsU2NhbGVGYWN0b3I7XG59KTtcbm91dCQucHhUb1RpbGUgPSBweFRvVGlsZSA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiAoZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiBpdCAvIGtHYW1lVW5pdHNQZXJUaWxlO1xuICB9KShweFRvR2FtZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbn07XG5vdXQkLmRlZ1RvUmFkID0gZGVnVG9SYWQgPSAoZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgKiBrUGkgLyAxODA7XG59KTtcbm91dCQua09uZVRpbGUgPSBrT25lVGlsZSA9IHRpbGVUb0dhbWUoMSk7XG5vdXQkLmtIYWxmVGlsZSA9IGtIYWxmVGlsZSA9IHRpbGVUb0dhbWUoMC41KTtcbm91dCQua1RpbGVQeCA9IGtUaWxlUHggPSB0aWxlVG9QeCgxKTtcbm91dCQua01heEd1bkxldmVsID0ga01heEd1bkxldmVsID0gMzsiLCJ2YXIgc3RkLCB1bml0cywgdHB4LCBJbW1vYmlsZVNpbmdsZUxvb3BQYXJ0aWNsZSwgV2FsbFBhcnRpY2xlLCBvdXQkID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyB8fCB0aGlzO1xuc3RkID0gcmVxdWlyZSgnc3RkJyk7XG51bml0cyA9IHJlcXVpcmUoJy4vdW5pdHMnKTtcbnRweCA9IHJlcXVpcmUoJy4vdW5pdHMnKS50aWxlVG9QeDtcbkltbW9iaWxlU2luZ2xlTG9vcFBhcnRpY2xlID0gcmVxdWlyZSgnLi9pbW1vYmlsZS1zaW5nbGUtbG9vcC1wYXJ0aWNsZScpLkltbW9iaWxlU2luZ2xlTG9vcFBhcnRpY2xlO1xub3V0JC5XYWxsUGFydGljbGUgPSBXYWxsUGFydGljbGUgPSAoZnVuY3Rpb24oc3VwZXJjbGFzcyl7XG4gIHZhciBwcm90b3R5cGUgPSBleHRlbmQkKChpbXBvcnQkKFdhbGxQYXJ0aWNsZSwgc3VwZXJjbGFzcykuZGlzcGxheU5hbWUgPSAnV2FsbFBhcnRpY2xlJywgV2FsbFBhcnRpY2xlKSwgc3VwZXJjbGFzcykucHJvdG90eXBlLCBjb25zdHJ1Y3RvciA9IFdhbGxQYXJ0aWNsZTtcbiAgZnVuY3Rpb24gV2FsbFBhcnRpY2xlKGdyYXBoaWNzLCB4LCB5KXtcbiAgICBXYWxsUGFydGljbGUuc3VwZXJjbGFzcy5jYWxsKHRoaXMsIGdyYXBoaWNzLCB4LCB5LCAnQ2FyZXQnLCB0cHgoMTEpLCB0cHgoMCksIHRweCgxKSwgdHB4KDEpLCAxOCwgNCk7XG4gIH1cbiAgcmV0dXJuIFdhbGxQYXJ0aWNsZTtcbn0oSW1tb2JpbGVTaW5nbGVMb29wUGFydGljbGUpKTtcbmZ1bmN0aW9uIGV4dGVuZCQoc3ViLCBzdXApe1xuICBmdW5jdGlvbiBmdW4oKXt9IGZ1bi5wcm90b3R5cGUgPSAoc3ViLnN1cGVyY2xhc3MgPSBzdXApLnByb3RvdHlwZTtcbiAgKHN1Yi5wcm90b3R5cGUgPSBuZXcgZnVuKS5jb25zdHJ1Y3RvciA9IHN1YjtcbiAgaWYgKHR5cGVvZiBzdXAuZXh0ZW5kZWQgPT0gJ2Z1bmN0aW9uJykgc3VwLmV4dGVuZGVkKHN1Yik7XG4gIHJldHVybiBzdWI7XG59XG5mdW5jdGlvbiBpbXBvcnQkKG9iaiwgc3JjKXtcbiAgdmFyIG93biA9IHt9Lmhhc093blByb3BlcnR5O1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSBpZiAob3duLmNhbGwoc3JjLCBrZXkpKSBvYmpba2V5XSA9IHNyY1trZXldO1xuICByZXR1cm4gb2JqO1xufSJdfQ==
